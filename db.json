<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":0},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0},{"_id":"themes/next/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0}],"Cache":[{"_id":"source/_posts/9-4总结.md","shasum":"41e028b5b5e49ee6e2976034025460ab25a3c2e6","modified":1453816536817},{"_id":"source/_posts/AC自动机算法详解.md","shasum":"8adf5365470e4ef2fbd753467d363c80b90089be","modified":1453816536823},{"_id":"source/_posts/Debian-7-安装教程.md","shasum":"72cb3c318c941ba6c9f6c8f767837845b1c73756","modified":1453816536824},{"_id":"source/_posts/Git-简明指南.md","shasum":"915124a1b1e2cebb03be7f2b0ad387600fb8b6ff","modified":1453816536834},{"_id":"source/_posts/Github资源整理.md","shasum":"4b36f16e1093c9a36e30346f9da0cffa7749420e","modified":1453816536877},{"_id":"source/_posts/Find-the-Path.md","shasum":"21940f33aa6cadaabf59266f48674f2af33863d6","modified":1453816536832},{"_id":"source/_posts/NOIP-10-27总结.md","shasum":"64d440ca5cb1efa1b728674d87f20076b75162e9","modified":1453816536885},{"_id":"source/_posts/NOIP-考前必备.md","shasum":"e86cd78d458df0ede23a8b3a3c57218ce17eb05a","modified":1453816536901},{"_id":"source/_posts/NOIP-11-21总结.md","shasum":"8fcf5767af3b714f2c01f083991960af8a29edba","modified":1453816536886},{"_id":"source/_posts/NOIP2015提高组复赛-总结.md","shasum":"6dc846a21b8fff2720f600227528fd08927034cb","modified":1453816536902},{"_id":"source/_posts/Road.md","shasum":"e95dfe452945b7d5f972e0c6f7e5577a2f1f6993","modified":1453816536903},{"_id":"source/_posts/bzoj3732-Network.md","shasum":"2a0bd2cc143ddfaab0e08b8d52849a3c0154af1e","modified":1453816536904},{"_id":"source/_posts/hello-world.md","shasum":"9ef6a60a9b81000ec3e327167db36f73701d3553","modified":1453816536915},{"_id":"source/_posts/cc软件集.md","shasum":"4f830a27e73352dc4d7c6bb9b2470f57074d3627","modified":1453816536913},{"_id":"source/_posts/【NOIP2013模拟联考9】阿Q的停车场.md","shasum":"8d47c20d73b1133a7123132c26aa3f692cb07c94","modified":1453816536972},{"_id":"source/_posts/【NOIP2015】10-30总结.md","shasum":"63bf7d04627f9b03df2852a20b2387a306d8302b","modified":1453816536976},{"_id":"source/_posts/【NOIP】10-29总结-B组.md","shasum":"0e06d4472c45ac4ee95bdc40093c870393db843f","modified":1453816536998},{"_id":"source/_posts/【NOIP】10-31总结.md","shasum":"6e80dd1dd99c8cf500ba6df4d8b0ff04b126e6de","modified":1453816536998},{"_id":"source/_posts/【NOIP】11-13-11-14总结.md","shasum":"915ea5fad65c361ae2fb55d7bfa3f7cfc6536395","modified":1453816537038},{"_id":"source/_posts/【NOIP】剑与魔法(dragons).md","shasum":"4981282e272f546a0fef504d100d9c8456b70fe3","modified":1453816537056},{"_id":"source/_posts/【NOIP】独立集-bubble.md","shasum":"a125045408a485ca14d786b3317dcd39c8390b91","modified":1453816537061},{"_id":"source/_posts/【转载】有向图强连通分量的Tarjan算法.md","shasum":"e683a01dededa3e52661e677bcf72f51e5555bd6","modified":1453816537062},{"_id":"source/_posts/【转载】表达式求值问题.md","shasum":"0cc717b9dbed724a6c772802b9a2b31a03eccb51","modified":1453816537068},{"_id":"source/_posts/五校联考7-总结.md","shasum":"a7a8f1e34b5969e91e8287ced6e054bfd4be1cc1","modified":1453816537068},{"_id":"source/_posts/从头到尾彻底理解KMP.md","shasum":"7ef90a0e08d9aae3cf82bf8dbdfeff2583029e74","modified":1453816537069},{"_id":"source/_posts/使用七牛云存储作个人博客图床.md","shasum":"1e46f4acc16c1f8745c3947daf57089b6fa6a911","modified":1453816537070},{"_id":"source/_posts/信息学程序模板.md","shasum":"5300879f3653586d7fca0716576646c5fd2151b0","modified":1453816537081},{"_id":"source/_posts/【NOIP】总结-10-30晚-11-5.md","shasum":"e6ae0c4774a7830cfd13a32a612e2f276e2c9f80","modified":1453816537059},{"_id":"source/_posts/抽签程序.md","shasum":"e639cd48f9fed86a7b6bfc00d56b37536bd2f6ee","modified":1453816537083},{"_id":"source/_posts/图形变换-transform.md","shasum":"5b69dce7997344e3fd53f01ae0ab1b0c203c0e65","modified":1453816537082},{"_id":"source/_posts/铺砖问题.md","shasum":"2395aece942382d5f5564b6b1d66f1fc5b6b2d7a","modified":1453816537087},{"_id":"source/about/index.md","shasum":"cdfdda151747e2c3fe1b0137d98ba635c18ea80d","modified":1453816537088},{"_id":"source/categories/index.md","shasum":"725b598e4c04118279ed53013efa7d63e27b7b38","modified":1453816537097},{"_id":"source/tags/index.md","shasum":"d99b072725fcb3411592bc4c34f24d4f4b1fa876","modified":1453816537099},{"_id":"source/_posts/线段-segment.md","shasum":"b0b732046357d262e1137b736b99b8c6d4f98c34","modified":1453816537084},{"_id":"source/_posts/Git教程.md","shasum":"2f4f95a72cb86c6e24b57793f7dc4125a4e0dbc4","modified":1453816536883},{"_id":"source/_posts/【NOIP】10-28总结-A组.md","shasum":"8f7924b9202cadf6c6991f8cb56b3e0225b9e56c","modified":1453816536997},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1453816545379},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1453816545688},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1453816545690},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1453816545996},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1453816545691},{"_id":"themes/next/README.en.md","shasum":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1453816544180},{"_id":"themes/next/README.md","shasum":"b2499c61ef9cf6ee31ed5606ed43ef247c73de63","modified":1453816544181},{"_id":"themes/next/_config.yml","shasum":"ad5724d168b24cc58ddd62f4fd78e01e08f43e45","modified":1453816544182},{"_id":"themes/next/bower.json","shasum":"d46717b4a025790cda33d78339780c8749aee7fd","modified":1453816544182},{"_id":"themes/next/languages/de.yml","shasum":"3af67eda28640a99e17d06eec0c664e54e95fb2d","modified":1453816544195},{"_id":"themes/next/languages/default.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1453816544196},{"_id":"themes/next/languages/en.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1453816544196},{"_id":"themes/next/languages/fr-FR.yml","shasum":"eb05b50f49a29d46e90e45fabb12a14be6d7631d","modified":1453816544208},{"_id":"themes/next/languages/pt.yml","shasum":"e32711ad646d05911b515cc30e14c57f534a0045","modified":1453816544210},{"_id":"themes/next/languages/ru.yml","shasum":"4d1c2d4f4040d447a3511da51dc9fea7b177a7a6","modified":1453816544217},{"_id":"themes/next/languages/zh-hk.yml","shasum":"f80a494ecf23166152011cb5f4e9174fefa9197c","modified":1453816544233},{"_id":"themes/next/layout/_layout.swig","shasum":"43dc8e01ca4d2e508db830250f2dcba7ded94830","modified":1453816544237},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"60766ca0cf5ba834d445c3304695d1a7ce0e1a36","modified":1453816544299},{"_id":"themes/next/layout/_macro/post.swig","shasum":"affea948ef5ad04dd089350340af722bcb2e7892","modified":1453816544300},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"c0f68851e8835b41fb60e7a78f096235067f7754","modified":1453816544300},{"_id":"themes/next/layout/_partials/comments.swig","shasum":"93055fc8e034037321280c182997a2a726e10c41","modified":1453816544322},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","shasum":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1453816544323},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"779fc2ec44464d66cadcc85913c49b2d8aad3d22","modified":1453816544376},{"_id":"themes/next/languages/zh-tw.yml","shasum":"f60af901f90fab657a1d27f981ad3381069842d0","modified":1453816544235},{"_id":"themes/next/layout/_partials/head.swig","shasum":"471e197800829e9704ba9bb8f2d8f342c3e65c44","modified":1453816544386},{"_id":"themes/next/layout/_partials/header.swig","shasum":"8c8ae71c41722815540950ccefac47d6876d0413","modified":1453816544388},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"3c4d930d34c234725065173780a23673e1c574f5","modified":1453816544389},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1453816544405},{"_id":"themes/next/layout/_partials/search.swig","shasum":"1b86eb85017599392071d1230171e900045f8e69","modified":1453816544396},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1453816544448},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"12684840de632eb16e53ffa863166306a756fd4f","modified":1453816544451},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1453816544565},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1453816544565},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1453816544588},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"5e1b2b547a8f07ea0e3ab2a97dac9cc7d1e13c9a","modified":1453816544562},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"640d4dda003f54a0dffa4508fba4d91ac0dcfa6e","modified":1453816544589},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"0aad8d447567b683108b274c841c536b2daa176d","modified":1453816544639},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"ba22a703638a23fce2cc51fcdfb1ba4dd7bcd114","modified":1453816544218},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1453816544694},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"701dfc53d750635de2f08f08d072d6ceb83b636c","modified":1453816544696},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1453816544697},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"b03b2f596b7b9795f63dc4174329bf14aee7a48c","modified":1453816544696},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"de1fc505acbe8dc84f7376fe6ae9871f22d5582e","modified":1453816544702},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"8eecd19c756df615afb3f5ec6a527cd7bd06d20c","modified":1453816544701},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1453816544390},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"ac600616e83e23ee446a646c57500706936bb45e","modified":1453816544705},{"_id":"themes/next/layout/archive.swig","shasum":"40e899e690172d8dd19317b17ec7be94406f114f","modified":1453816544742},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1453816544719},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"73e8294939bbbb46755798215c605ebe5af5918f","modified":1453816544400},{"_id":"themes/next/layout/page.swig","shasum":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1453816544798},{"_id":"themes/next/layout/category.swig","shasum":"c777432e1587826ccad5a4aa50309763a82df52b","modified":1453816544743},{"_id":"themes/next/scripts/filters/sticky.js","shasum":"4e4c9a837e186f94f256bd6eabb89b138cfc0db6","modified":1453816544851},{"_id":"themes/next/scripts/merge-configs.js","shasum":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1453816544852},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"99b66949f18398689b904907af23c013be1b978f","modified":1453816544862},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1453816544865},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1453816544867},{"_id":"themes/next/layout/tag.swig","shasum":"06417b0b050c66d816323b6178c9376ba2e58dd9","modified":1453816544803},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"dac21141c7893ab9de697a8183d3b3f4eb7f0a5a","modified":1453816544929},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1453816545074},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"0a1730773478d843e123404ab4dae24d7cb0f2b7","modified":1453816545094},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1453816545099},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1453816545111},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"70d7c3b5f8f2485dcce1a27e2c9b43df988fbc6f","modified":1453816545112},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"cd2ec04433d6c98a0994945475fb47155d1015c0","modified":1453816545101},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1453816545113},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"88559b13ce94311405b170a0506ded91273beceb","modified":1453816545114},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8909298333c6dfc6e3686d85e4d98c76dfcf75c9","modified":1453816545136},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"008d5f951144c7fe5c7e66dac330d5fb715a0a83","modified":1453816545150},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"f28f00b2acb0df0343e77400bcc8246b40ac046c","modified":1453816545150},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"52badf0e8a0a44bb67f16486ada44d945b1aba6b","modified":1453816545151},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1453816545208},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"b8e1b52b7aaa94b7c52d1681225e80f1af1219fa","modified":1453816545215},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"90a36892f5f595dda58a86901782b1addbdb3b46","modified":1453816545215},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1453816545218},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"16a98866f5025c050c56e52312228355a16d00d9","modified":1453816545259},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"3702c4c350524622f7dd658b05449fc425a819ef","modified":1453816545258},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"c46d16429b85570347373fd11db8c222f6ff914e","modified":1453816545330},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"7bdc92a55f2eee20b6b546e93e4566696b459b9d","modified":1453816545331},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"dbb0843ea5aa7c2ac2755a2d1ce60fa662f1b939","modified":1453816545341},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"a9f5260198225801eb5c16345a69a7e3cab904fe","modified":1453816545355},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"df9e5a418f6e54abe69c1ab84649be46fb0c51a6","modified":1453816545360},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1453816545361},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1453816545394},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"6eaa5d9cb08ecfb2d377a475e541e41fbfe4c1b6","modified":1453816545397},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1453816545437},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"cd6527e4877f62f08e8668b020ec9f9e53f625a9","modified":1453816545440},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"9a9630b7aae08b5008f3a0ff1152bdca427ff644","modified":1453816545490},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"482784c04c0cd15a3f0d86444966fe306af7d13a","modified":1453816545492},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"627cdd38b34b15c9fc17f4dc332b1be928f8ed0d","modified":1453816545579},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"406b78061c45bda0376ce2360ff2932262f5f2f0","modified":1453816545544},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1453816545644},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1453816545637},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1453816545689},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"e4b5b56e1a035c99ebd50d00e93d89e2e8d0b735","modified":1453816545768},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1453816545791},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"452e71caf2c37fa5a06f8d9ada81337a57485885","modified":1453816545771},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"3b0a186e8d9d5cfe30dd611456b61053ea535d7b","modified":1453816545855},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1453816545856},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1453816545886},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"dd667be3f5f24cebdc15d0262c7d397f23d751c5","modified":1453816545886},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"f10be4b0c642104a6f533b94ac09e22019aa640e","modified":1453816545857},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"ecd76494cea5fbf592cc13ba1e4ccdfedbc5bf1b","modified":1453816545968},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"692c01dcdc612c3e1e245cf93d0ace0a4e2aaf3f","modified":1453816545344},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"932cb9c53d64b086638adca05dcf4e2df239a8f9","modified":1453816545970},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"e315ee6f604c2bcc44a5ef9078f5ce420c153a4b","modified":1453816545887},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1453816546072},{"_id":"themes/next/source/css/main.styl","shasum":"6bb842ad45a575774299bed3848d46475820fb9f","modified":1453816546102},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1453816546135},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1453816546137},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1453816546175},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1453816546178},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1453816546233},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1453816546245},{"_id":"themes/next/source/images/cc-by.svg","shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1453816546234},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1453816546244},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1453816546246},{"_id":"themes/next/source/images/quote-l.svg","shasum":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1453816546247},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"9bc1cad0c7a9f4fdfa665098fb5c542dc9e640db","modified":1453816545971},{"_id":"themes/next/source/images/quote-r.svg","shasum":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1453816546273},{"_id":"themes/next/source/js/bootstrap.js","shasum":"5a963f40fb81d265a31679f8f543e50ffdcc7485","modified":1453816546276},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1453816546274},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"97640be11a524b203781c1a03f623ef0b9195a02","modified":1453816546299},{"_id":"themes/next/source/js/fancy-box.js","shasum":"fbeabc936667a9e15556c8defb5fcd582add8067","modified":1453816546301},{"_id":"themes/next/source/js/helpers.js","shasum":"69d8ae9b686a82e3a4397b61a477eb8da68bd153","modified":1453816546305},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1453816546307},{"_id":"themes/next/source/js/motion.js","shasum":"a9327a3c0a5df289799c5ffe3e8bf7dd6e407797","modified":1453816546316},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1453816546330},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"fc57202d8d952fceb3f1ad5b6e7183f47a3f1a0e","modified":1453816546317},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1453816546346},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1453816546348},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1453816546368},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1453816546386},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1453816546389},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1453816546369},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1453816546492},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1453816546494},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1453816546495},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1453816546388},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1453816546496},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1453816546579},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1453816546580},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1453816546590},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1453816546589},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1453816546718},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1453816546758},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1453816546616},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1453816546761},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1453816546617},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1453816546796},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1453816546760},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1453816546583},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1453816546816},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","shasum":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1453816547019},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1453816546955},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","shasum":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1453816546956},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1453816547044},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1453816547048},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1453816547205},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1453816547202},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1453816547120},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1453816547281},{"_id":"themes/next/test/helpers.js","shasum":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1453816547286},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1453816546598},{"_id":"themes/next/layout/index.swig","shasum":"56a70d0cd51ce739787da3e07638969ccb6abd2f","modified":1453816544743},{"_id":"themes/next/layout/post.swig","shasum":"e67a6aabe4d71cbcf01a4cace652424bd49acc9b","modified":1453816544801},{"_id":"themes/next/test/intern.js","shasum":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1453816547297},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1453816546800},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1453816546814},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1453816546912},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1453816546799},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1453816546810},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1453816547124},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1453816546806},{"_id":"public/vendors/velocity/velocity.ui.min.js","modified":1453817334808,"shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908"},{"_id":"public/vendors/velocity/velocity.ui.js","modified":1453817334850,"shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df"},{"_id":"public/vendors/velocity/velocity.min.js","modified":1453817334855,"shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6"},{"_id":"public/vendors/velocity/velocity.js","modified":1453817334864,"shasum":"9f08181baea0cc0e906703b7e5df9111b9ef3373"},{"_id":"public/vendors/velocity/bower.json","modified":1453817334876,"shasum":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409"},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","modified":1453817334923,"shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1"},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","modified":1453817334934,"shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3"},{"_id":"public/vendors/jquery_lazyload/bower.json","modified":1453817334939,"shasum":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53"},{"_id":"public/vendors/jquery_lazyload/README.html","modified":1453817335146,"shasum":"c593e16f0d63d24b5d3933f3b9297884867ce4a0"},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","modified":1453817335157,"shasum":"bf8e477ee2d81833cff12572a8a5f61abffc187c"},{"_id":"public/vendors/jquery/index.js","modified":1453817335163,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1453817335197,"shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1453817335206,"shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1453817335213,"shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1453817335242,"shasum":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1453817335249,"shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6"},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","modified":1453817335255,"shasum":"0112e96f327d413938d37c1693806f468ffdbace"},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","modified":1453817335275,"shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22"},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","modified":1453817335286,"shasum":"1573904b82807abbb32c97a3632c6c6808eaac50"},{"_id":"public/vendors/font-awesome/css/font-awesome.css","modified":1453817335292,"shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7"},{"_id":"public/vendors/font-awesome/bower.json","modified":1453817335298,"shasum":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad"},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","modified":1453817335305,"shasum":"ed80b43dbc7e3009b2f436741b9796df8eb3be02"},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","modified":1453817335361,"shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18"},{"_id":"public/vendors/fastclick/lib/fastclick.js","modified":1453817335399,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/vendors/fastclick/bower.json","modified":1453817335404,"shasum":"4dcecf83afddba148464d5339c93f6d0aa9f42e9"},{"_id":"public/vendors/fastclick/README.html","modified":1453817335419,"shasum":"5bef8b8758435bc08129f6d374740527a6a9b942"},{"_id":"public/vendors/fastclick/LICENSE","modified":1453817335472,"shasum":"6f474ea75c42442da7bbcf2e9143ce98258efd8d"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","modified":1453817335494,"shasum":"53360764b429c212f424399384417ccc233bb3be"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","modified":1453817335517,"shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","modified":1453817335521,"shasum":"5f163444617b6cf267342f06ac166a237bb62df9"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1453817335553,"shasum":"53e194f4a72e649c04fb586dd57762b8c022800b"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1453817335597,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1453817335609,"shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1453817335629,"shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1453817335633,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1453817335689,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","modified":1453817335705,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","modified":1453817335717,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","modified":1453817335724,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","modified":1453817335734,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","modified":1453817335739,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/vendors/fancybox/source/blank.gif","modified":1453817335743,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/js/ua-parser.min.js","modified":1453817335749,"shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6"},{"_id":"public/js/motion.js","modified":1453817335754,"shasum":"b4132517fe499538ad725094593fb7ead8c04bf7"},{"_id":"public/js/hook-duoshuo.js","modified":1453817335759,"shasum":"eedaf52377991728f1e3e94f2bc4bf23ec41ecea"},{"_id":"public/js/helpers.js","modified":1453817335762,"shasum":"c15216ef897334362789ba37464298948b2eef95"},{"_id":"public/js/fancy-box.js","modified":1453817335771,"shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2"},{"_id":"public/js/bootstrap.scrollspy.js","modified":1453817335784,"shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625"},{"_id":"public/js/bootstrap.js","modified":1453817335789,"shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299"},{"_id":"public/images/searchicon.png","modified":1453817335793,"shasum":"67727a6a969be0b2659b908518fa6706eed307b8"},{"_id":"public/images/quote-r.svg","modified":1453817335831,"shasum":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41"},{"_id":"public/images/quote-l.svg","modified":1453817335838,"shasum":"cd108d6f44351cadf8e6742565217f88818a0458"},{"_id":"public/images/placeholder.gif","modified":1453817335843,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/loading.gif","modified":1453817335849,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/cc-zero.svg","modified":1453817335866,"shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d"},{"_id":"public/images/cc-by.svg","modified":1453817335870,"shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70"},{"_id":"public/images/cc-by-sa.svg","modified":1453817335877,"shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398"},{"_id":"public/images/cc-by-nd.svg","modified":1453817335909,"shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8"},{"_id":"public/images/cc-by-nc.svg","modified":1453817335913,"shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab"},{"_id":"public/images/cc-by-nc-sa.svg","modified":1453817335932,"shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3"},{"_id":"public/images/cc-by-nc-nd.svg","modified":1453817335937,"shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668"},{"_id":"public/css/main.css","modified":1453817336740,"shasum":"b543a601b41111fa81f89b2ea35847c9ca930161"},{"_id":"public/tags/index.html","modified":1453817337154,"shasum":"3f027d676f791c7f42d713a389bdc006974c81d1"},{"_id":"public/categories/index.html","modified":1453817337281,"shasum":"dcc044128f72e3dd76b5dff7cbc02330172145f3"},{"_id":"public/about/index.html","modified":1453817337346,"shasum":"348f0d55550b3b2c423bf9b0bb9744573a302f74"},{"_id":"public/2016/01/26/使用七牛云存储作个人博客图床/index.html","modified":1453817337481,"shasum":"de637fc60620d95d098746040bb125643e37d4d7"},{"_id":"public/2016/01/26/从头到尾彻底理解KMP/index.html","modified":1453817337644,"shasum":"5fdec307ac6a98cb54f38fba6b2ede2a96a82e5e"},{"_id":"public/2016/01/26/Github资源整理/index.html","modified":1453817337746,"shasum":"068bee7ca546a464167609d03e1d7f29204f979d"},{"_id":"public/2016/01/26/AC自动机算法详解/index.html","modified":1453817337875,"shasum":"4858466cacc0dcfb6f13923ac85516bf45edd29c"},{"_id":"public/2015/12/20/Road/index.html","modified":1453817338028,"shasum":"0f85d842121822b252f7028e536e2613f6a104a1"},{"_id":"public/2015/12/20/Git-简明指南/index.html","modified":1453817338184,"shasum":"66fdf0f840ca7be78e9a952d1ad8003804ef70b9"},{"_id":"public/2015/12/17/hello-world/index.html","modified":1453817338284,"shasum":"fbc0ce99dc88a9f1ae47271031b637705f85281f"},{"_id":"public/2015/12/12/Git教程/index.html","modified":1453817338485,"shasum":"f80260e6ba75c3d083065ada6ef28c5f82ee47c7"},{"_id":"public/2015/11/21/NOIP-11-21总结/index.html","modified":1453817338608,"shasum":"49df089d99e9cdf721c44d31744626a4a9be6a20"},{"_id":"public/2015/11/17/NOIP2015提高组复赛-总结/index.html","modified":1453817338706,"shasum":"cb08c0edfec86e661bb0d3136707d3c1dd56b01f"},{"_id":"public/2015/11/06/信息学程序模板/index.html","modified":1453817338818,"shasum":"61ced55b993b82fd9b8769affae1efa040089024"},{"_id":"public/2015/11/06/【转载】表达式求值问题/index.html","modified":1453817339004,"shasum":"64c256889b52df4302e0cf671fae12a0e0d01f12"},{"_id":"public/2015/11/06/【NOIP】总结-10-30晚-11-5/index.html","modified":1453817339138,"shasum":"e2c165501f680802af4728e956ccacbb187d2375"},{"_id":"public/2015/11/05/【NOIP】10-31总结/index.html","modified":1453817339245,"shasum":"1299f1bf05c2ce97589b43b778d6994c2a3c2c76"},{"_id":"public/2015/11/03/NOIP-考前必备/index.html","modified":1453817339374,"shasum":"f79f944238b549a19d79616434719496a2c758a7"},{"_id":"public/2015/10/30/【NOIP2015】10-30总结/index.html","modified":1453817339509,"shasum":"3dc6a5a31ce96c69ae92ff46619cd8e5d755e841"},{"_id":"public/2015/10/29/【NOIP】11-13-11-14总结/index.html","modified":1453817339682,"shasum":"9e4e2e3caf90d9b3668c6b04234981d8814a0f6c"},{"_id":"public/2015/10/29/【转载】有向图强连通分量的Tarjan算法/index.html","modified":1453817339794,"shasum":"c67043663017aff2b1eea745f2a646bcd5745a7b"},{"_id":"public/2015/10/29/【NOIP】10-29总结-B组/index.html","modified":1453817339924,"shasum":"e810f13b9949832a311f1cdcfc06b6dfb1fb5832"},{"_id":"public/2015/10/28/【NOIP】10-28总结-A组/index.html","modified":1453817340028,"shasum":"def7736503c5e65aea8bf8c10bed313715523d33"},{"_id":"public/2015/10/28/Debian-7-安装教程/index.html","modified":1453817340139,"shasum":"52b3a55b82cfa19ff4890316668f6dd2da887ab6"},{"_id":"public/2015/10/27/五校联考7-总结/index.html","modified":1453817340243,"shasum":"f8402a534e8f29584493bf7363393582189c6282"},{"_id":"public/2015/10/27/NOIP-10-27总结/index.html","modified":1453817340352,"shasum":"3d1e90eff29dd30af0f8a360dad6e386a47dd472"},{"_id":"public/2015/09/05/9-4总结/index.html","modified":1453817340548,"shasum":"83d707df788ec403d3d77c7ce1520c3f663c1bad"},{"_id":"public/2015/08/21/图形变换-transform/index.html","modified":1453817340662,"shasum":"5886b48e29ef48dc3d3b951fc3b99f83be9ecd6d"},{"_id":"public/2015/08/18/线段-segment/index.html","modified":1453817340827,"shasum":"5ca048abf18355c4515b445233053067ce1cdce1"},{"_id":"public/2015/08/17/Find-the-Path/index.html","modified":1453817340972,"shasum":"58350a7e3eb2d998f5e1ce26b625322200389715"},{"_id":"public/2015/08/16/【NOIP】独立集-bubble/index.html","modified":1453817341089,"shasum":"489e4c7ae1f206ede85af99c7505f381a0fd4d85"},{"_id":"public/2015/08/16/【NOIP】剑与魔法(dragons)/index.html","modified":1453817341220,"shasum":"3c126d362e33d5d102b74b488ccbe9f4ddc138c5"},{"_id":"public/2015/08/11/bzoj3732-Network/index.html","modified":1453817341332,"shasum":"9008e4bd6c5bfd738fec7a08b94ce04059891f00"},{"_id":"public/2015/08/11/铺砖问题/index.html","modified":1453817341445,"shasum":"cb30e88fe4f445d8a2cd7f6f7c0e235d119ac3fc"},{"_id":"public/2015/08/11/【NOIP2013模拟联考9】阿Q的停车场/index.html","modified":1453817341575,"shasum":"bca6a6fe41d5da5e61f61f40887c5a87fc1b2ccf"},{"_id":"public/2013/11/09/抽签程序/index.html","modified":1453817341703,"shasum":"17a059d80a34ffcebea0cc8dd4b1d97059b05c32"},{"_id":"public/2012/03/24/cc软件集/index.html","modified":1453817341881,"shasum":"18d7c106d181b3120404518129a3f477be4430fb"},{"_id":"public/categories/信息学/index.html","modified":1453817342154,"shasum":"ffb5e7997e6792591b2f89c09c2a1748c063b44f"},{"_id":"public/categories/信息学/page/2/index.html","modified":1453817342289,"shasum":"c56c123fd1373c8f97454cc2e4bfb7320389db0e"},{"_id":"public/categories/信息学/page/3/index.html","modified":1453817342429,"shasum":"86b4e2d3decced9e7321d49d870c2be3a0c1bb46"},{"_id":"public/categories/信息学/原创/index.html","modified":1453817342588,"shasum":"e1a1fce2202412aa97387347a10fad3431ce0c4e"},{"_id":"public/categories/信息学/原创/page/2/index.html","modified":1453817342729,"shasum":"bad45b72577e20f2028b7a73af659534fcc06c84"},{"_id":"public/categories/信息学/原创/page/3/index.html","modified":1453817342835,"shasum":"6b7dd5415a92d809c3c14538dc330c0cb297a67d"},{"_id":"public/categories/易语言/index.html","modified":1453817342931,"shasum":"b6a503311645711b4b1cb4303a2dc947f0ae8977"},{"_id":"public/categories/易语言/原创/index.html","modified":1453817343032,"shasum":"227752c44e17c35e41ae45e66ae421684bd4cc3a"},{"_id":"public/categories/互联网/index.html","modified":1453817343147,"shasum":"621658e0dbf007a0714c005785bfd5945d6df866"},{"_id":"public/categories/互联网/转载/index.html","modified":1453817343272,"shasum":"bd19f02983bb6c6c2ba3fe35a02668d87ca80a0c"},{"_id":"public/categories/信息学/转载/index.html","modified":1453817343431,"shasum":"d88b7686c5241fd2c140a90ed9b505dc8dde17a8"},{"_id":"public/categories/互联网/原创/index.html","modified":1453817343528,"shasum":"f43bce39b715d9c52bccb1d80f9ed4c7febe82af"},{"_id":"public/archives/index.html","modified":1453817343764,"shasum":"49687038cdf6b291badc0c17a22451accad5d037"},{"_id":"public/archives/page/2/index.html","modified":1453817343972,"shasum":"fa0774135ad9749f483337194e3207da379c0dd0"},{"_id":"public/archives/2012/index.html","modified":1453817344084,"shasum":"6015a54f4d10635a2689ff5c7579bb0b6018bb3f"},{"_id":"public/archives/2012/03/index.html","modified":1453817344150,"shasum":"290417428be3011ee37471370e4c1b4ea6b3dc2a"},{"_id":"public/archives/2013/index.html","modified":1453817344234,"shasum":"202dff86ece0a5bf4d1c55e35cb57fd505efc0bd"},{"_id":"public/archives/2013/11/index.html","modified":1453817344304,"shasum":"5a2593117a7df01df818613f0ce8e69d40cb250f"},{"_id":"public/archives/2015/index.html","modified":1453817344495,"shasum":"8adda595c84f1f9d3dbba0df37fec50aa62682dd"},{"_id":"public/archives/2015/page/2/index.html","modified":1453817344625,"shasum":"c14491e62e505ef5ec09c9dc1e8221868ca19d09"},{"_id":"public/archives/2015/08/index.html","modified":1453817344780,"shasum":"f5ee5cbdf50f649b7d72b438fe63e0a004faed1d"},{"_id":"public/archives/2015/09/index.html","modified":1453817344866,"shasum":"9a1e7addb95884f80d7b29f742e6edb9a5867abe"},{"_id":"public/archives/2015/10/index.html","modified":1453817345020,"shasum":"efc6d26edf819d179eb57f85589a5a556847d520"},{"_id":"public/archives/2015/11/index.html","modified":1453817345163,"shasum":"6357ee7b1be89b20df471de8484cd07c463f530c"},{"_id":"public/archives/2015/12/index.html","modified":1453817345287,"shasum":"4bab88071cc55c202e1062bd30346ac0bea1b95e"},{"_id":"public/archives/2016/index.html","modified":1453817345386,"shasum":"8266f00a0f2ceb813f38dc64eee9c1fd8df90796"},{"_id":"public/archives/2016/01/index.html","modified":1453817345610,"shasum":"3ac983aaf740e464c752a63a3eb7ba5552941531"},{"_id":"public/index.html","modified":1453817345746,"shasum":"f28437dbe8e0d22b06320351570e28bd0c4cbc1c"},{"_id":"public/page/2/index.html","modified":1453817345872,"shasum":"b1365e653850a29515064233643202931e6acba3"},{"_id":"public/page/3/index.html","modified":1453817345992,"shasum":"95bac249638fb9423329f39c6ffa2e032bcb1c4b"},{"_id":"public/page/4/index.html","modified":1453817346144,"shasum":"768140cc95177237721322bc3ab478ed3475d175"},{"_id":"public/page/5/index.html","modified":1453817346273,"shasum":"4243e13724a5d16ed1fa3b4a632b1ec15e34ae75"},{"_id":"public/page/6/index.html","modified":1453817346437,"shasum":"1b76eff57a9eed7aff682bd29f31c7c73eceadf4"},{"_id":"public/page/7/index.html","modified":1453817346575,"shasum":"d02c525f31345fc615dd1b77373134d470c10456"},{"_id":"public/tags/总结/index.html","modified":1453817346708,"shasum":"73e6c991815f68417033ad21b65535d218910a2a"},{"_id":"public/tags/总结/page/2/index.html","modified":1453817346783,"shasum":"8ef64ff5e02dd9c1a92277838e307e58917a1587"},{"_id":"public/tags/题解/index.html","modified":1453817346892,"shasum":"01c54fdab131c0b01da5284a50ed812b1a53fe3f"},{"_id":"public/tags/矩阵乘法/index.html","modified":1453817347013,"shasum":"2058fd755f69141daca33caea7a8452ffc30c925"},{"_id":"public/tags/线段树/index.html","modified":1453817347082,"shasum":"f17905f0d9f8f280339893c9bbab2407ff8a95ff"},{"_id":"public/tags/hash/index.html","modified":1453817347179,"shasum":"ee268756d8ab980f9a6af3e13bd59ab9ff8b63a7"},{"_id":"public/tags/快速幂/index.html","modified":1453817347241,"shasum":"803aff812c4f71cf93e3d9d2c6456ce839594c4c"},{"_id":"public/tags/软件/index.html","modified":1453817347325,"shasum":"24fa61ac5b7b54607c400ec704659e6f1ef92607"},{"_id":"public/tags/模板/index.html","modified":1453817347393,"shasum":"a4d39a0c8da02f5e9c37788071c4b54eda5b1570"},{"_id":"public/tags/工具/index.html","modified":1453817347606,"shasum":"b9928f0e1d18de2f863d44682945461a9c361c3e"},{"_id":"public/tags/KMP/index.html","modified":1453817347702,"shasum":"fc0ca138f2e9903441f1c96fa925eea816d98384"},{"_id":"public/tags/LCA/index.html","modified":1453817347818,"shasum":"4344d9956c8d2db837c37ed06fe990e1da46c294"},{"_id":"public/tags/RMQ/index.html","modified":1453817347897,"shasum":"a40e30b410d305209719fe1c602b2ea00e2a47b0"},{"_id":"public/tags/教程/index.html","modified":1453817348082,"shasum":"cbdd55f0986b8a66df550dd7731ab25f88056ffe"},{"_id":"public/tags/版本控制/index.html","modified":1453817348165,"shasum":"1ee20d3ed6886779af26c37b83f6a4f2a370cf67"},{"_id":"public/tags/floyd算法/index.html","modified":1453817348659,"shasum":"f25c829549c47b6be7fb9ef89375cf62b1bacf77"},{"_id":"public/tags/AC自动机/index.html","modified":1453817348890,"shasum":"6765a5d7fcf71f755065116917611b8d40044006"}],"Category":[{"name":"信息学","_id":"cijvhas250001dcoqkxtp7lt7"},{"name":"原创","parent":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas290003dcoqnthzbcdc"},{"name":"易语言","_id":"cijvhas5b000sdcoqvuy0ezme"},{"name":"原创","parent":"cijvhas5b000sdcoqvuy0ezme","_id":"cijvhas5c000udcoqdf7slen8"},{"name":"互联网","_id":"cijvhas5v0019dcoqa9eketut"},{"name":"转载","parent":"cijvhas5v0019dcoqa9eketut","_id":"cijvhas5x001bdcoqffuxyt0a"},{"name":"转载","parent":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas66001gdcoqwawgfc7e"},{"name":"原创","parent":"cijvhas5v0019dcoqa9eketut","_id":"cijvhasad004fdcoqdydo3wqh"}],"Data":[],"Page":[{"title":"Tagcloud","date":"2015-12-12T07:40:37.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: Tagcloud\ndate: 2015-12-12 15:40:37\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-01-26T13:55:37.099Z","path":"tags/index.html","layout":"page","_id":"cijvhas2g0007dcoqq6gsi6ap"},{"title":"categories","date":"2015-12-12T07:43:24.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-12 15:43:24\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-01-26T13:55:37.097Z","path":"categories/index.html","layout":"page","_id":"cijvhas390008dcoqoq9vl1n6"},{"title":"about","date":"2015-12-11T10:55:44.000Z","type":"about","comments":0,"_content":"Not Ready!","source":"about/index.md","raw":"title: about\ndate: 2015-12-11 18:55:44\ntype: \"about\"\ncomments: false\n---\nNot Ready!","updated":"2016-01-26T13:55:37.088Z","path":"about/index.html","layout":"page","_id":"cijvhas3d0009dcoqfjr1bghr"}],"Post":[{"title":"9.4总结","date":"2015-09-05T00:20:00.000Z","_content":"今天是5校联考的第一天,然而我犯了很多小错误。\n****\nT1：感觉像是数学问题，然而并没有发现什么规律。最后还是想着暴力，去打搜索，每一次向上有四种转移。但是我计算的时间复杂度计算错误。所以我认为拿不了太多分。最后，交了搜索，只拿了30分。因为我犯了一个错误，没有把max开到long long的最大范围，只开到了int的最大范围。改一下这个可以拿50分。最后与100分失之交臂，是因为我搜索的减枝做的不是很好。一个很给力的剪枝（r-l+1>l）没有发现，这个剪枝是答案可行性剪枝。\n****\nT2：一开始想到与题解类似的想法，但是因为无法处理好合法串中有可能在一个位置右括号多余左括号，最后面发现我完全想错了。所以就抛弃了这种方法。转而向题目所给的（A）与AB方向想，先找到最简单的符合条件的串，再一次扩展，就能把这个字符串中多有的合法子串找出。最后我先打了个暴力，然后就去打这种方法。但最后因为时间不够没有调出来。只不过我觉得调出来也应该拿不到满分，因为有一些东西可以与处理出来，一个个构造相加太慢了。后面是看到一个人的程序，他的想法和我的类似，只不过他通过多个预处理实现了出来，每一组数据的时间复杂度只有O（len）。\n****\nT3：这道题非常的神奇，因为完全摸不着正解的头绪，蒟蒻只能打搜索了，然而又一次我的搜索打挂了。我并没有测多组数据，然后多组数据就挂了。最后面发现是哈夫曼树，然后跟着WWT大神的证明听了一遍，然后又请教了一下LB，最后将这道题的解与哈夫曼树相同性的证明弄懂了","source":"_posts/9-4总结.md","raw":"---\ntitle: 9.4总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-09-05 08:20:00\n---\n今天是5校联考的第一天,然而我犯了很多小错误。\n****\nT1：感觉像是数学问题，然而并没有发现什么规律。最后还是想着暴力，去打搜索，每一次向上有四种转移。但是我计算的时间复杂度计算错误。所以我认为拿不了太多分。最后，交了搜索，只拿了30分。因为我犯了一个错误，没有把max开到long long的最大范围，只开到了int的最大范围。改一下这个可以拿50分。最后与100分失之交臂，是因为我搜索的减枝做的不是很好。一个很给力的剪枝（r-l+1>l）没有发现，这个剪枝是答案可行性剪枝。\n****\nT2：一开始想到与题解类似的想法，但是因为无法处理好合法串中有可能在一个位置右括号多余左括号，最后面发现我完全想错了。所以就抛弃了这种方法。转而向题目所给的（A）与AB方向想，先找到最简单的符合条件的串，再一次扩展，就能把这个字符串中多有的合法子串找出。最后我先打了个暴力，然后就去打这种方法。但最后因为时间不够没有调出来。只不过我觉得调出来也应该拿不到满分，因为有一些东西可以与处理出来，一个个构造相加太慢了。后面是看到一个人的程序，他的想法和我的类似，只不过他通过多个预处理实现了出来，每一组数据的时间复杂度只有O（len）。\n****\nT3：这道题非常的神奇，因为完全摸不着正解的头绪，蒟蒻只能打搜索了，然而又一次我的搜索打挂了。我并没有测多组数据，然后多组数据就挂了。最后面发现是哈夫曼树，然后跟着WWT大神的证明听了一遍，然后又请教了一下LB，最后将这道题的解与哈夫曼树相同性的证明弄懂了","slug":"9-4总结","published":1,"updated":"2016-01-26T13:55:36.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas1v0000dcoqyr8b8low","sticky":0},{"title":"铺砖问题","date":"2015-08-11T01:44:00.000Z","_content":"Description\n==\n用1×2的 砖头铺满N*M的区域，不能有重叠，一共有多少种方案？如下图所示：\n![方式](http://img.blog.csdn.net/20150811093026083)\n\nData Constraint\n==\n20%的数据满足1<=N,M<=6\n50%的数据满足1<=N<=100,1<=M<=11\n另外50%的数据满足1<=N<=10^200,1<=M<=5\n\nAnalysis\n==\n**对于此题的前50%的数据**\n可以参照此位大神的解析：\nhttp://blog.csdn.net/yan_____/article/details/8719748\n我的程序前50%就是参考了这篇文章\n\n**对于100%的数据**\n1. 我们发现N很大，但是M却很小。\n2. 前50%的数据我们都是通过不同的二进制状态转移并累加得到的。这种转移就显然就是矩阵自乘的结果。而他的答案就是$a[(1 shl m)-1,(1 shl m)-1]$,表示从(1 shl m)-1转移到(1 shl m)-1的方案数。\n3. 那么我们可以将前50%数据得到的st数组中的对应值映射到[0..1 shl m,0..1 shl m]的矩阵中，然后将这个矩阵自乘n次即可得到答案。\n4. 矩阵自乘可以用快速幂进行优化。\n5. 因为做一次矩阵乘法的时间复杂度为$O(N^3)$。所以整体的时间复杂度为$O((2^m)^3*log(10^100)/log(2))$。\n6. 因为n极其的庞大所以在做快速幂时我们需要用到单精除。\n7. 可能很多人会不理解为什么用矩阵乘法和为什么答案是$a[(1 shl m)-1,(1 shl m)-1]$。(懂得人可以忽略此部分内容)\n\n对于每一层来说，因为st数组中$st[i][0] $都可以到$st[i][1]$ 。所以我们首先想想最简单的情况:\n当n=1时，他的答案就是从$dp[0][1 shl m-1]$ 到$dp[1][1 shl m-1] $。就是 $base[1 shl m -1] [1 shl m-1]$。\n当n=2 时，我们可以看看矩阵乘法的工作原理 对于答案$ans[i,j] += a[i,k]*a[k,j]$，他是通过枚举k将第i行和第j列一一对应相乘并累加的道德结果。而在我们的基础矩阵base存放的就是第i行的状态可以转移到哪j个状态。当你要从i这个状态到j这个状态，我们可以枚举一个中间点k让i先到k，再从k到j\n,这样恰好进行了两次转移所以这个ans矩阵，就代表从第i个状态经过了n次转移(看你乘了多少次)到达第j个状态的方案数。\n其实矩阵乘法可以类比floyd求最短路的算法。\n\nCode\n==\n因为代码比较丑，所以不要见怪\n```\nconst\tmaxn=100+5;maxm=10+5;\n\t\tmo=1000000007;len=17;size=(1 shl 5);jw=100000000000000000;\ntype\tbignum=array[0..15] of int64;\n\t\tmatrix=array[0..size,0..size] of int64;\nvar\ti,j,m,n,tot,tmp:longint;\n\tst:array[0..(1 shl maxm),0..1] of longint;\n\tdp:array[0..maxn,0..(1 shl maxm)] of int64;\n\ts,nn,mm:string;\n\tbase,ans:matrix;\n\tn1:bignum;\n\tsum:int64;\nprocedure dfs(n,from,next:longint);\nbegin\n\tif (n>m) then begin\n\t\texit;\n\tend;\n\tif (n=m) then begin\n\t\tst[tot][0]:=from;\n\t\tst[tot][1]:=next;\n\t\tinc(tot);\n\t\texit;\n\tend;\n\tdfs(n+2,(from<<2)+3,(next<<2)+3);\n\tdfs(n+1,(from<<1)+1,(next<<1));\n\tdfs(n+1,(from<<1),(next<<1)+1);\nend;\nprocedure div2(var x:bignum);\nvar\ti,t:longint;\nbegin\n\tt:=0;\n\tfor i:=x[0] downto 1 do begin\n\t\tx[i]:=t*jw+x[i];\n\t\tt:=x[i] mod 2;\n\t\tx[i]:=x[i] div 2;\n\t\tif x[i]=0 then x[0]:=i-1;\n\tend;\nend;\nprocedure stom(var s:string;var num:bignum);\nvar\tts:string[len];\n\ti:longint;\nbegin\n\tfillchar(num,sizeof(num),0);\n\tts:='';\n\tfor i:=length(s) downto 1 do begin\n\t\tts:=s[i]+ts;\n\t\tif length(ts)=len then begin\n\t\t\tinc(num[0]);\n\t\t\tval(ts,num[num[0]]);\n\t\t\tts:='';\n\t\tend;\n\tend;\n\tif ts<>'' then begin\n\t\tinc(num[0]);\n\t\tval(ts,num[num[0]]);\n\tend;\nend;\nfunction mul(x,y:matrix):matrix;//矩阵乘法\nvar     i,j,k,size1:integer;\n\tz:matrix;\nbegin\n\tsize1:=(1<<m);\n        fillchar(z,sizeof(z),0);\n        for i:=0 to size1 do\n        for j:=0 to size1 do\n\tfor k:=0 to size1 do begin\n\t\tz[i,j]:=(z[i,j]+x[i,k]*y[k,j])mod mo;\n\tend;\n\texit(z);\nend;\nprocedure work(y:bignum);\nbegin\n\tfillchar(ans,sizeof(ans),0);\n\tfor i:=0 to (1<<m) do ans[i][i]:=1;\n\t//单位矩阵，就是实数中的1\n\twhile (y[0]<>0) do begin\n\t\tif odd(y[1]) then begin\n\t\t\tans:=mul(ans,base);\n\t\tend;\n\t\tbase:=mul(base,base);\n\t\tdiv2(y);\n\tend;\nend;\nbegin\n\treadln(s);\n\ttmp:=pos(' ',s);\n\tnn:=copy(s,1,tmp-1);\n\tmm:=copy(s,tmp + 1,length(s) - tmp);val(mm,m);\n\n\ttot:=0;\n\tdfs(0,0,0);\n\tif (length(nn)<=2) or (nn='100') then begin\n\t\t//前50%的做法\n\t\tval(nn,n);\n\t\tif odd(n*m) then begin\n\t\t\twriteln(0);\n\t\t\texit;\n\t\tend;\t\n\n\t\tdp[0][(1<<m)-1]:=1;\n\t\tfor i:=1 to n do \n\t\t\tfor j:=0 to tot-1 do begin\n\t\t\t\tdp[i][st[j][1]]:=(dp[i][st[j][1]]+dp[i-1][st[j][0]]) mod mo;\n\t\t\tend;\n\t\twriteln(dp[n][(1<<m)-1]);\n\tend else begin\n\t\tfillchar(base,sizeof(base),0);\n\t\tfor j:=0 to tot-1 do begin\n\t\t\tbase[st[j][0]][st[j][1]]:=1;\n\t\tend;\n\t\t//初始化基础对应矩阵\n\t\tstom(nn,n1);//将nn这个字符串转化为高精度数组\n\t\twork(n1);//快速幂做矩阵乘法\n\t\tsum:=ans[(1<<m)-1][(1<<m)-1];\n\t\twriteln(sum mod mo);\n\tend;\nend.\n```\nTips\n==\n此题源自：zoj1100\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1100\n据说此题有通项公式，具体请看维基百科\nhttps://en.wikipedia.org/wiki/Domino_tiling\n","source":"_posts/铺砖问题.md","raw":"---\ntitle: 铺砖问题\ndate: 2015-08-11 09:44\ntags:\n  - 题解\n  - 矩阵乘法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n==\n用1×2的 砖头铺满N*M的区域，不能有重叠，一共有多少种方案？如下图所示：\n![方式](http://img.blog.csdn.net/20150811093026083)\n\nData Constraint\n==\n20%的数据满足1<=N,M<=6\n50%的数据满足1<=N<=100,1<=M<=11\n另外50%的数据满足1<=N<=10^200,1<=M<=5\n\nAnalysis\n==\n**对于此题的前50%的数据**\n可以参照此位大神的解析：\nhttp://blog.csdn.net/yan_____/article/details/8719748\n我的程序前50%就是参考了这篇文章\n\n**对于100%的数据**\n1. 我们发现N很大，但是M却很小。\n2. 前50%的数据我们都是通过不同的二进制状态转移并累加得到的。这种转移就显然就是矩阵自乘的结果。而他的答案就是$a[(1 shl m)-1,(1 shl m)-1]$,表示从(1 shl m)-1转移到(1 shl m)-1的方案数。\n3. 那么我们可以将前50%数据得到的st数组中的对应值映射到[0..1 shl m,0..1 shl m]的矩阵中，然后将这个矩阵自乘n次即可得到答案。\n4. 矩阵自乘可以用快速幂进行优化。\n5. 因为做一次矩阵乘法的时间复杂度为$O(N^3)$。所以整体的时间复杂度为$O((2^m)^3*log(10^100)/log(2))$。\n6. 因为n极其的庞大所以在做快速幂时我们需要用到单精除。\n7. 可能很多人会不理解为什么用矩阵乘法和为什么答案是$a[(1 shl m)-1,(1 shl m)-1]$。(懂得人可以忽略此部分内容)\n\n对于每一层来说，因为st数组中$st[i][0] $都可以到$st[i][1]$ 。所以我们首先想想最简单的情况:\n当n=1时，他的答案就是从$dp[0][1 shl m-1]$ 到$dp[1][1 shl m-1] $。就是 $base[1 shl m -1] [1 shl m-1]$。\n当n=2 时，我们可以看看矩阵乘法的工作原理 对于答案$ans[i,j] += a[i,k]*a[k,j]$，他是通过枚举k将第i行和第j列一一对应相乘并累加的道德结果。而在我们的基础矩阵base存放的就是第i行的状态可以转移到哪j个状态。当你要从i这个状态到j这个状态，我们可以枚举一个中间点k让i先到k，再从k到j\n,这样恰好进行了两次转移所以这个ans矩阵，就代表从第i个状态经过了n次转移(看你乘了多少次)到达第j个状态的方案数。\n其实矩阵乘法可以类比floyd求最短路的算法。\n\nCode\n==\n因为代码比较丑，所以不要见怪\n```\nconst\tmaxn=100+5;maxm=10+5;\n\t\tmo=1000000007;len=17;size=(1 shl 5);jw=100000000000000000;\ntype\tbignum=array[0..15] of int64;\n\t\tmatrix=array[0..size,0..size] of int64;\nvar\ti,j,m,n,tot,tmp:longint;\n\tst:array[0..(1 shl maxm),0..1] of longint;\n\tdp:array[0..maxn,0..(1 shl maxm)] of int64;\n\ts,nn,mm:string;\n\tbase,ans:matrix;\n\tn1:bignum;\n\tsum:int64;\nprocedure dfs(n,from,next:longint);\nbegin\n\tif (n>m) then begin\n\t\texit;\n\tend;\n\tif (n=m) then begin\n\t\tst[tot][0]:=from;\n\t\tst[tot][1]:=next;\n\t\tinc(tot);\n\t\texit;\n\tend;\n\tdfs(n+2,(from<<2)+3,(next<<2)+3);\n\tdfs(n+1,(from<<1)+1,(next<<1));\n\tdfs(n+1,(from<<1),(next<<1)+1);\nend;\nprocedure div2(var x:bignum);\nvar\ti,t:longint;\nbegin\n\tt:=0;\n\tfor i:=x[0] downto 1 do begin\n\t\tx[i]:=t*jw+x[i];\n\t\tt:=x[i] mod 2;\n\t\tx[i]:=x[i] div 2;\n\t\tif x[i]=0 then x[0]:=i-1;\n\tend;\nend;\nprocedure stom(var s:string;var num:bignum);\nvar\tts:string[len];\n\ti:longint;\nbegin\n\tfillchar(num,sizeof(num),0);\n\tts:='';\n\tfor i:=length(s) downto 1 do begin\n\t\tts:=s[i]+ts;\n\t\tif length(ts)=len then begin\n\t\t\tinc(num[0]);\n\t\t\tval(ts,num[num[0]]);\n\t\t\tts:='';\n\t\tend;\n\tend;\n\tif ts<>'' then begin\n\t\tinc(num[0]);\n\t\tval(ts,num[num[0]]);\n\tend;\nend;\nfunction mul(x,y:matrix):matrix;//矩阵乘法\nvar     i,j,k,size1:integer;\n\tz:matrix;\nbegin\n\tsize1:=(1<<m);\n        fillchar(z,sizeof(z),0);\n        for i:=0 to size1 do\n        for j:=0 to size1 do\n\tfor k:=0 to size1 do begin\n\t\tz[i,j]:=(z[i,j]+x[i,k]*y[k,j])mod mo;\n\tend;\n\texit(z);\nend;\nprocedure work(y:bignum);\nbegin\n\tfillchar(ans,sizeof(ans),0);\n\tfor i:=0 to (1<<m) do ans[i][i]:=1;\n\t//单位矩阵，就是实数中的1\n\twhile (y[0]<>0) do begin\n\t\tif odd(y[1]) then begin\n\t\t\tans:=mul(ans,base);\n\t\tend;\n\t\tbase:=mul(base,base);\n\t\tdiv2(y);\n\tend;\nend;\nbegin\n\treadln(s);\n\ttmp:=pos(' ',s);\n\tnn:=copy(s,1,tmp-1);\n\tmm:=copy(s,tmp + 1,length(s) - tmp);val(mm,m);\n\n\ttot:=0;\n\tdfs(0,0,0);\n\tif (length(nn)<=2) or (nn='100') then begin\n\t\t//前50%的做法\n\t\tval(nn,n);\n\t\tif odd(n*m) then begin\n\t\t\twriteln(0);\n\t\t\texit;\n\t\tend;\t\n\n\t\tdp[0][(1<<m)-1]:=1;\n\t\tfor i:=1 to n do \n\t\t\tfor j:=0 to tot-1 do begin\n\t\t\t\tdp[i][st[j][1]]:=(dp[i][st[j][1]]+dp[i-1][st[j][0]]) mod mo;\n\t\t\tend;\n\t\twriteln(dp[n][(1<<m)-1]);\n\tend else begin\n\t\tfillchar(base,sizeof(base),0);\n\t\tfor j:=0 to tot-1 do begin\n\t\t\tbase[st[j][0]][st[j][1]]:=1;\n\t\tend;\n\t\t//初始化基础对应矩阵\n\t\tstom(nn,n1);//将nn这个字符串转化为高精度数组\n\t\twork(n1);//快速幂做矩阵乘法\n\t\tsum:=ans[(1<<m)-1][(1<<m)-1];\n\t\twriteln(sum mod mo);\n\tend;\nend.\n```\nTips\n==\n此题源自：zoj1100\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1100\n据说此题有通项公式，具体请看维基百科\nhttps://en.wikipedia.org/wiki/Domino_tiling\n","slug":"铺砖问题","published":1,"updated":"2016-01-26T13:55:37.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas3n000adcoqhk03ioac","sticky":0},{"title":"线段(segment)","date":"2015-08-18T14:25:00.000Z","_content":"Description\n--\n数轴上有很多单位线段，一开始时所有单位线段的权值都是1。有两种操作，第一种操作将某一区间内的单位线段权值乘以w，第二种操作将某一区间内的单位线段权值取w次幂。并且你还需要回答一些询问，每个询问需要求出某一区间的单位线段权值之积。由于答案可能很大，你只需要求出答案 mod (10^9+7)的值。\n\nInput\n--\n第一行一个整数n，表示操作数量。\n\n接下来n行，每行第一个整数表示操作类型，0表示第一种操作，1表示第二种操作，2表示询问，如果第一个数是0或1，则接下来3个数，表示操作区间和w，否则接下来两个数，表示询问区间。\n\nOutput\n--\n对于每组询问，输出一行，表示所求答案。\n\nSample Input\n--\n\n```\n7\n0 0 2 3\n1 1 3 2\n2 1 3\n0 0 3 2\n1 1 3 2\n2 1 3\n2 0 3\n```\n\nSample Output\n--\n\n```\n9\n1296\n7776\n```\n\nData Constraint\n--\n![下表中的“线段权值”表示“单位线段经过各种w处理后的权值范围”](http://img.blog.csdn.net/20150818220038129)\nAnalysis\n--\n看完标题和题目，就给人一种提醒，此题要用线段树。仔细观察可以发现这题类似于线段树维护区间和。所以同理能用线段树解决。只是将这道题改成了区间积和增加了对区间取幂次方的修改。因为有两种修改，所以我们要维护两个下传标记。但是区间的范围却非常大，这显然是要爆空间的节奏啊！！\n细心的我们发现，此题n很小，可是区间范围却很大，我们何不考虑一下离散化呢？这样子整个线段的长度就只有2n了。在做乘积的时候还需要用到快速幂。接下来就是怎么实现的问题了。\n实现过程还是挺复杂的！！首先我们把读入的数据离线掉，并将各个区间的值排序后塞入hash表中，在hash表中存入旧位置及新位置对应的匹配。这样我们就能很快的从旧的位置找到新的位置。\n剩下的问题就是如何去维护标记。我打了两个标记，一个是标记第一种操作在区间中乘了多少个w（没有他的L次幂，因为每个区间的L都有可能不同）。第二个标记是记录第二个操作（即这个区间乘了多少次方）。只用了这两个标记。剩下的就是线段树的实现了。\nCode\n--\n\n```\nconst\tmaxn=20000+2;mo=1000000007;hamo=200000+2;\ntype\tnode=record\n\t\tv,ad,ad2:longint;\n\tend;\n\tarr=array[1..2*maxn] of longint;\nvar\ti,n,sum,ret,x,y,z,t,kk:longint;\n\tq:array[1..maxn,1..4] of longint;\n\th:array[1..hamo] of node;\n\ta:arr;\n\tlen,d:array[1..hamo] of longint;\n\thash:array[0..hamo,1..2] of longint;\nprocedure times(var x:longint;y:longint);\nbegin\n\tx:=(int64(x) * (y mod mo)) mod mo;\nend;\nfunction pow(x:int64;y:longint):int64;\nbegin\n\tpow:=1;\n\twhile y<>0 do begin\n\t\tif odd(y) then pow:=(pow*x) mod mo;\n\t\tx:=(x*x) mod mo;\n\t\ty:=y>>1;\n\tend;\nend;\nprocedure qsort(var a1:arr;l,r:longint);\nvar\tm,i,j,t:longint;\nbegin\n\tm:=a1[(l+r) div 2];\n\ti:=l;j:=r;\n\trepeat\n\t\twhile a1[i]<m do inc(i);\n\t\twhile a1[j]>m do dec(j);\n\t\tif i<=j then begin\n\t\t\tt:=a1[i];\n\t\t\ta1[i]:=a1[j];\n\t\t\ta1[j]:=t;\n\t\t\tinc(i);dec(j);\n\t\tend;\n\tuntil i>j;\n\tif l<j then qsort(a1,l,j);\n\tif i<r then qsort(a1,i,r);\nend;\n\nprocedure maketree(x,l,r:longint);\nvar\tmid:longint;\nbegin\n\tif (l=r) then begin\n\t\th[x].v:=1;\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\t\td[x]:=len[l];\n\tend else begin\n\t\tmid:=(l+r) >> 1;\n\t\tmaketree(x*2,l,mid);\n\t\tmaketree(x*2+1,mid+1,r);\n\t\th[x].v:=1;\n\t\td[x]:=d[x*2]+d[x*2+1];\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\tend;\nend;\nprocedure change(x,l,r:longint);\nbegin\n        h[x*2].v\t:=pow(h[x*2].v,h[x].ad2);\n        h[x*2+1].v\t:=pow(h[x*2+1].v,h[x].ad2);\n        h[x*2].ad\t:=pow(h[x*2].ad,h[x].ad2);\n        h[x*2+1].ad\t:=pow(h[x*2+1].ad,h[x].ad2);\n        h[x*2].ad2\t:=(int64(h[x*2].ad2) * h[x].ad2) mod (mo-1);\n        h[x*2+1].ad2\t:=(int64(h[x*2+1].ad2) * h[x].ad2) mod (mo-1);\n        h[x].ad2\t:=1;\n\n        times(h[x*2].v,pow(h[x].ad,d[x*2]));\n        times(h[x*2].ad,h[x].ad);\n\ttimes(h[x*2+1].v,pow(h[x].ad,d[x*2+1]));\n        times(h[x*2+1].ad,h[x].ad);\n        h[x].ad := 1;\nend;\nprocedure modify1(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(h[x].v,pow(w,d[x]));\n\t\ttimes(h[x].ad,w);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify1(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify1(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify1(x*2,l,mid,st,mid,w);\n\t\t\tmodify1(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure modify2(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n                h[x].v := pow(h[x].v,w);\n                h[x].ad := pow(h[x].ad,w);\n                h[x].ad2 := (int64(h[x].ad2) * w) mod (mo-1);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify2(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify2(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify2(x*2,l,mid,st,mid,w);\n\t\t\tmodify2(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure query(x,l,r,st,en:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(ret,h[x].v);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then query(x*2,l,mid,st,en)\n\t\telse if st>mid then query(x*2+1,mid+1,r,st,en)\n\t\telse begin\n\t\t\tquery(x*2,l,mid,st,mid);\n\t\t\tquery(x*2+1,mid+1,r,mid+1,en);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\n\nprocedure enter(x,i:longint);\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,1]<>0 do y:=(y+1) mod hamo;\n\thash[y,1]:=i;\n\thash[y,2]:=x\nend;\nfunction ha(x:longint):longint;\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,2]<>x do y:=(y+1) mod hamo;\n\texit(hash[y,1]);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\tread(q[i,1],q[i,2],q[i,3]);\n\t\tif q[i,1]<>2 then read(q[i,4]);\n\t\tinc(t); a[t]:=q[i,2];\n\t\tinc(t); a[t]:=q[i,3];\n\tend;\n\tqsort(a,1,t);\n\tkk:=a[1];\n\tfor i:=2 to t do begin\n\t\tif kk<>a[i] then begin\n\t\t\tinc(sum);\n\t\t\tenter(kk,sum);\n\t\t\tlen[sum]:=a[i]-kk;\n\t\t\tkk:=a[i];\n\t\tend;\n\tend;\n\tinc(sum); enter(a[t],sum); dec(sum);\n\tmaketree(1,1,sum);\n\n\tfor i:=1 to n do begin\n\t\tx:=ha(q[i,2]);\n\t\ty:=ha(q[i,3])-1;\n\t\tcase q[i,1] of\n\t\t\t0:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify1(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t1:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify2(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t2:begin\n\t\t\t\tret:=1;\n\t\t\t\tquery(1,1,sum,x,y);\n\t\t\t\twriteln(ret);\n\t\t\tend;\n\t\tend;\n\tend; \nend.\n```","source":"_posts/线段-segment.md","raw":"---\ntitle: 线段(segment)\ndate: 2015-08-18 22:25:00\ntags:\n  - 题解\n  - 线段树\n  - hash\n  - 快速幂\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\n数轴上有很多单位线段，一开始时所有单位线段的权值都是1。有两种操作，第一种操作将某一区间内的单位线段权值乘以w，第二种操作将某一区间内的单位线段权值取w次幂。并且你还需要回答一些询问，每个询问需要求出某一区间的单位线段权值之积。由于答案可能很大，你只需要求出答案 mod (10^9+7)的值。\n\nInput\n--\n第一行一个整数n，表示操作数量。\n\n接下来n行，每行第一个整数表示操作类型，0表示第一种操作，1表示第二种操作，2表示询问，如果第一个数是0或1，则接下来3个数，表示操作区间和w，否则接下来两个数，表示询问区间。\n\nOutput\n--\n对于每组询问，输出一行，表示所求答案。\n\nSample Input\n--\n\n```\n7\n0 0 2 3\n1 1 3 2\n2 1 3\n0 0 3 2\n1 1 3 2\n2 1 3\n2 0 3\n```\n\nSample Output\n--\n\n```\n9\n1296\n7776\n```\n\nData Constraint\n--\n![下表中的“线段权值”表示“单位线段经过各种w处理后的权值范围”](http://img.blog.csdn.net/20150818220038129)\nAnalysis\n--\n看完标题和题目，就给人一种提醒，此题要用线段树。仔细观察可以发现这题类似于线段树维护区间和。所以同理能用线段树解决。只是将这道题改成了区间积和增加了对区间取幂次方的修改。因为有两种修改，所以我们要维护两个下传标记。但是区间的范围却非常大，这显然是要爆空间的节奏啊！！\n细心的我们发现，此题n很小，可是区间范围却很大，我们何不考虑一下离散化呢？这样子整个线段的长度就只有2n了。在做乘积的时候还需要用到快速幂。接下来就是怎么实现的问题了。\n实现过程还是挺复杂的！！首先我们把读入的数据离线掉，并将各个区间的值排序后塞入hash表中，在hash表中存入旧位置及新位置对应的匹配。这样我们就能很快的从旧的位置找到新的位置。\n剩下的问题就是如何去维护标记。我打了两个标记，一个是标记第一种操作在区间中乘了多少个w（没有他的L次幂，因为每个区间的L都有可能不同）。第二个标记是记录第二个操作（即这个区间乘了多少次方）。只用了这两个标记。剩下的就是线段树的实现了。\nCode\n--\n\n```\nconst\tmaxn=20000+2;mo=1000000007;hamo=200000+2;\ntype\tnode=record\n\t\tv,ad,ad2:longint;\n\tend;\n\tarr=array[1..2*maxn] of longint;\nvar\ti,n,sum,ret,x,y,z,t,kk:longint;\n\tq:array[1..maxn,1..4] of longint;\n\th:array[1..hamo] of node;\n\ta:arr;\n\tlen,d:array[1..hamo] of longint;\n\thash:array[0..hamo,1..2] of longint;\nprocedure times(var x:longint;y:longint);\nbegin\n\tx:=(int64(x) * (y mod mo)) mod mo;\nend;\nfunction pow(x:int64;y:longint):int64;\nbegin\n\tpow:=1;\n\twhile y<>0 do begin\n\t\tif odd(y) then pow:=(pow*x) mod mo;\n\t\tx:=(x*x) mod mo;\n\t\ty:=y>>1;\n\tend;\nend;\nprocedure qsort(var a1:arr;l,r:longint);\nvar\tm,i,j,t:longint;\nbegin\n\tm:=a1[(l+r) div 2];\n\ti:=l;j:=r;\n\trepeat\n\t\twhile a1[i]<m do inc(i);\n\t\twhile a1[j]>m do dec(j);\n\t\tif i<=j then begin\n\t\t\tt:=a1[i];\n\t\t\ta1[i]:=a1[j];\n\t\t\ta1[j]:=t;\n\t\t\tinc(i);dec(j);\n\t\tend;\n\tuntil i>j;\n\tif l<j then qsort(a1,l,j);\n\tif i<r then qsort(a1,i,r);\nend;\n\nprocedure maketree(x,l,r:longint);\nvar\tmid:longint;\nbegin\n\tif (l=r) then begin\n\t\th[x].v:=1;\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\t\td[x]:=len[l];\n\tend else begin\n\t\tmid:=(l+r) >> 1;\n\t\tmaketree(x*2,l,mid);\n\t\tmaketree(x*2+1,mid+1,r);\n\t\th[x].v:=1;\n\t\td[x]:=d[x*2]+d[x*2+1];\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\tend;\nend;\nprocedure change(x,l,r:longint);\nbegin\n        h[x*2].v\t:=pow(h[x*2].v,h[x].ad2);\n        h[x*2+1].v\t:=pow(h[x*2+1].v,h[x].ad2);\n        h[x*2].ad\t:=pow(h[x*2].ad,h[x].ad2);\n        h[x*2+1].ad\t:=pow(h[x*2+1].ad,h[x].ad2);\n        h[x*2].ad2\t:=(int64(h[x*2].ad2) * h[x].ad2) mod (mo-1);\n        h[x*2+1].ad2\t:=(int64(h[x*2+1].ad2) * h[x].ad2) mod (mo-1);\n        h[x].ad2\t:=1;\n\n        times(h[x*2].v,pow(h[x].ad,d[x*2]));\n        times(h[x*2].ad,h[x].ad);\n\ttimes(h[x*2+1].v,pow(h[x].ad,d[x*2+1]));\n        times(h[x*2+1].ad,h[x].ad);\n        h[x].ad := 1;\nend;\nprocedure modify1(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(h[x].v,pow(w,d[x]));\n\t\ttimes(h[x].ad,w);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify1(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify1(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify1(x*2,l,mid,st,mid,w);\n\t\t\tmodify1(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure modify2(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n                h[x].v := pow(h[x].v,w);\n                h[x].ad := pow(h[x].ad,w);\n                h[x].ad2 := (int64(h[x].ad2) * w) mod (mo-1);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify2(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify2(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify2(x*2,l,mid,st,mid,w);\n\t\t\tmodify2(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure query(x,l,r,st,en:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(ret,h[x].v);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then query(x*2,l,mid,st,en)\n\t\telse if st>mid then query(x*2+1,mid+1,r,st,en)\n\t\telse begin\n\t\t\tquery(x*2,l,mid,st,mid);\n\t\t\tquery(x*2+1,mid+1,r,mid+1,en);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\n\nprocedure enter(x,i:longint);\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,1]<>0 do y:=(y+1) mod hamo;\n\thash[y,1]:=i;\n\thash[y,2]:=x\nend;\nfunction ha(x:longint):longint;\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,2]<>x do y:=(y+1) mod hamo;\n\texit(hash[y,1]);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\tread(q[i,1],q[i,2],q[i,3]);\n\t\tif q[i,1]<>2 then read(q[i,4]);\n\t\tinc(t); a[t]:=q[i,2];\n\t\tinc(t); a[t]:=q[i,3];\n\tend;\n\tqsort(a,1,t);\n\tkk:=a[1];\n\tfor i:=2 to t do begin\n\t\tif kk<>a[i] then begin\n\t\t\tinc(sum);\n\t\t\tenter(kk,sum);\n\t\t\tlen[sum]:=a[i]-kk;\n\t\t\tkk:=a[i];\n\t\tend;\n\tend;\n\tinc(sum); enter(a[t],sum); dec(sum);\n\tmaketree(1,1,sum);\n\n\tfor i:=1 to n do begin\n\t\tx:=ha(q[i,2]);\n\t\ty:=ha(q[i,3])-1;\n\t\tcase q[i,1] of\n\t\t\t0:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify1(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t1:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify2(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t2:begin\n\t\t\t\tret:=1;\n\t\t\t\tquery(1,1,sum,x,y);\n\t\t\t\twriteln(ret);\n\t\t\tend;\n\t\tend;\n\tend; \nend.\n```","slug":"线段-segment","published":1,"updated":"2016-01-26T13:55:37.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas3v000hdcoqo65lnh2y","sticky":0},{"title":"抽签程序","date":"2013-11-09T15:54:24.000Z","_content":"最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","source":"_posts/抽签程序.md","raw":"title: 抽签程序\ndate: 2013-11-9 23:54:24\ntags: [软件]\ncategories: [易语言,原创]\n---\n最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","slug":"抽签程序","published":1,"updated":"2016-01-26T13:55:37.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas59000rdcoq1znvvh4n","sticky":0},{"title":"图形变换(transform)","date":"2015-08-21T02:39:00.000Z","_content":"Description\n--\n对一个由n个点组成的图形连续作平移、缩放、旋转变换。相关操作定义如下：\n\nTrans(dx,dy) 表示平移图形，即把图形上所有的点的横纵坐标分别加上dx和dy；\n\nScale(sx,sy) 表示缩放图形，即把图形上所有点的横纵坐标分别乘以sx和sy；\n\nRotate(θ,x0,y0) 表示旋转图形，即把图形上所有点的坐标绕(x0,y0)顺时针旋转θ角度\n\n由于某些操作会重复运行多次，还定义了循环指令：\n\nLoop(m)\n\n… \n\nEnd \n\n表示把Loop和对应End之间的操作循环执行m次，循环可以嵌套。\n\nInput\n--\n第一行一个整数n(n<=100)表示图形由n个点组成；\n\n接下来n行，每行空格隔开两个实数xi，yi表示点的坐标；\n\n接下来一直到文件结束，每行一条操作指令。保证指令格式合法，无多余空格。\nOutput\n--\n输出有n行，每行两个空格隔开实数xi，yi表示对应输入的点变换后的坐标。\n\n本题采用Special Judge判断，只要你输出的数值与标准答案误差不能超过1即可。\n\nSample Input\n--\n\n```\n3\n0.5 0\n2.5 2\n-4.5 1\nTrans(1.5,-1)\nLoop(2)\nTrans(1,1)\nLoop(2)\nRotate(90,0,0)\nEnd\nScale(2,3)\nEnd\n```\n\nSample Output\n--\n\n```\n10.0000 -3.0000\n18.0000 15.0000\n-10.0000 6.0000\n```\n\nData Constraint\n--\n保证操作中坐标值不会超过double范围，输出不会超过int范围；\n\n指令总共不超过1000行；\n\n对于所有的数据,所有循环指令中m<=1000000；\n\n对于60%的数据,所有循环指令中m<=1000；\n\n对于30%的数据不含嵌套循环。\nAnalysis\n--\n看到这道题，首先想到的肯定是模拟。平移和缩放都是很简单的操作，比较麻烦的是旋转操作。据说有一个公式可以求任意点绕着原点逆时针旋转θrad的公式。\n![绕原点旋转公式](http://img.blog.csdn.net/20150821112509577)\n因为题目要求的是顺时针我们将角度取反再加上2πrad就好了。对于绕着任一点旋转，我们可以平移所有的点，使得给定的点与原点重合，套用公式计算，再把所有的平移回去。这样就可以通过暴力模拟拿到30%的分了。\n\n因为循环的次数非常大，而给出的指令又比较少，所以我们应该想办法将循环之间的状态保存下来然后快速的做n次。因为我们注意到题目中的变换是对于两个变量的线性递推，所以可以用矩阵来实现。而每做一次相当于矩阵自乘一次。因为矩阵具有结合律，所以自乘的操作通过快速幂来实现就好了。\n\n我们可以将每一种操作用矩阵表示出来，O(M)的扫一遍整个指令后将每个矩阵相乘，即可得到做完所有操作后的最终矩阵。然后，我们O(N)的将每一个点都与这个矩阵相乘就能得到这个点经过M次操作后的最终结果了。\n\n接下来就是如何构造矩阵的问题了。平移，缩放的矩阵构造相对简单。基本上是通过系数于变量相乘和相加而得，具体可看程序实现。(可以自己手动模拟模拟矩阵乘法的工作过程)\n比较难得就是旋转的矩阵构造。\n我们不需要将一个旋转命令拆成几个命令，这样子太麻烦。可以一步构造矩阵实现平移与绕远点旋转。\n我们假设图形中的一个点为(x,y)，绕(x0,y0)这个点顺时针旋转θrad(可以通过取反再加上一圈转换)，那么举例说明x'是如何得到的。\nx' = (x-x0)cosθ-(y-y0)sinθ+x0=cosθx-sinθy+sinθy0-cosθx0+x0\ny' = 同理可得\n最后的矩阵就是这样的：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | cosθ | sinθ | 0\n| 2 | -sinθ | cosθ |0\n| 3 | sinθ*y0-cosθ*x0+x0 | cosθ*y0-sin*x0+y0 |1\n对于每一个点构造矩阵：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | x | y | 0\n| 2 | 0 | 0 |0\n| 3 | 0 | 0 |0\n最后就可以在O(M)的时间过啦~~~\nCode\n--\n\n```\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define pi M_PI\n#define rad(x) x*pi/180\nusing namespace std;\n\nconst int N = 105 , M = 1005;\ntypedef double matrix[4][4];\nstruct node\n{\n\tdouble x,y,angle;\n\tint type,time;\n} a[M];\nstruct point\n{\n\tdouble x,y;\n} p[N];\nint n,m,top,stack[M],end[M];\nmatrix H;\nchar ch;\n\nvoid mul(matrix &a,matrix b)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int k=1;k<=3;k++)\n\t\tfor (int i=1;i<=3;i++)\n\t\t\tfor (int j=1;j<=3;j++)\n\t\t\t\tc[i][j] += a[i][k]*b[k][j];\n\tmemcpy(a,c,sizeof c);\n}\nvoid pow(matrix &a,int y)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int i=1;i<=3;i ++) c[i][i]=1;\n\twhile (y>0)\n\t{\n\t\tif (y & 1 == 1) mul(c,a);\n\t\tmul(a,a);\n\t\ty >>= 1;\n\t}\n\tmemcpy(a,c,sizeof c);\n}\nvoid work(int st,int en)\n{\n\tif (st>en) return;\n\tmatrix F,G;\n\tmemset(F,0,sizeof F);\n\tfor (int i=1;i<=3;i++) F[i][i] = 1;\n\tfor (int i=st;i<=en;i++)\n\t{\n\t\tmemset(G,0,sizeof G);\n\t\tif (a[i].type==1)\n\t\t{\n\t\t\tG[1][1] = 1;\n\t\t\tG[2][2] = 1;\n\t\t\tG[3][1] = a[i].x;\n\t\t\tG[3][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==2)\n\t\t{\n\t\t\tG[1][1] = a[i].x;\n\t\t\tG[2][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==3)\n\t\t{\n\t\t\ta[i].angle = 360 - a[i].angle;\n\t\t\tdouble co=cos(rad(a[i].angle)),si=sin(rad(a[i].angle));\n\t\t\tG[1][1] = co;\n\t\t\tG[1][2] = si;\n\t\t\tG[2][1] = -si;\n\t\t\tG[2][2] = co;\n\t\t\tG[3][1] = si*a[i].y-co*a[i].x+a[i].x;\n\t\t\tG[3][2] = -co*a[i].y-si*a[i].x+a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==4)\n\t\t{\n\t\t\twork(i+1,end[i]-1);\n\t\t\tpow(H,a[i].time);\n\t\t\tmul(F,H);\n\t\t\ti = end[i];\n\t\t}\n\n\t}\n\tmemcpy(H,F,sizeof F);\n}\nint main()\n{\n\tfreopen(\"transform.in\",\"r\",stdin);\n\tfreopen(\"transform.out\",\"w\",stdout);\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lf%lf\\n\",&p[i].x,&p[i].y);\n\twhile (scanf(\"%c\",&ch) != EOF)\n\t{\n\t\tm ++;\n\t\tif (ch=='T') a[m].type = 1,scanf(\"rans(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='S') a[m].type = 2,scanf(\"cale(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='R') a[m].type = 3,scanf(\"otate(%lf,%lf,%lf)\\n\",&a[m].angle,&a[m].x,&a[m].y);\n\t\tif (ch=='L') a[m].type = 4,scanf(\"oop(%d)\\n\",&a[m].time);\n\t\tif (ch=='E') a[m].type = 5,scanf(\"nd\\n\");\n\t}\n\n\tint top = 0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (a[i].type == 4) stack[++ top] = i;\n\t\tif (a[i].type == 5) end[stack[top --]] = i;\n\t}\n\twork(1,m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmatrix F;\n\t\tmemset(F,0,sizeof F);\n\t\tF[1][1] = p[i].x , F[1][2] = p[i].y , F[1][3] = 1;\n\t\tmul(F,H);\n\t\tprintf(\"%.4lf %.4lf\\n\",F[1][1],F[1][2]);\n\t}\n\treturn 0;\n}\n```","source":"_posts/图形变换-transform.md","raw":"---\ntitle: 图形变换(transform)\ndate: 2015-08-21 10:39:00\ntags:\n  - 题解\n  - 矩阵乘法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\n对一个由n个点组成的图形连续作平移、缩放、旋转变换。相关操作定义如下：\n\nTrans(dx,dy) 表示平移图形，即把图形上所有的点的横纵坐标分别加上dx和dy；\n\nScale(sx,sy) 表示缩放图形，即把图形上所有点的横纵坐标分别乘以sx和sy；\n\nRotate(θ,x0,y0) 表示旋转图形，即把图形上所有点的坐标绕(x0,y0)顺时针旋转θ角度\n\n由于某些操作会重复运行多次，还定义了循环指令：\n\nLoop(m)\n\n… \n\nEnd \n\n表示把Loop和对应End之间的操作循环执行m次，循环可以嵌套。\n\nInput\n--\n第一行一个整数n(n<=100)表示图形由n个点组成；\n\n接下来n行，每行空格隔开两个实数xi，yi表示点的坐标；\n\n接下来一直到文件结束，每行一条操作指令。保证指令格式合法，无多余空格。\nOutput\n--\n输出有n行，每行两个空格隔开实数xi，yi表示对应输入的点变换后的坐标。\n\n本题采用Special Judge判断，只要你输出的数值与标准答案误差不能超过1即可。\n\nSample Input\n--\n\n```\n3\n0.5 0\n2.5 2\n-4.5 1\nTrans(1.5,-1)\nLoop(2)\nTrans(1,1)\nLoop(2)\nRotate(90,0,0)\nEnd\nScale(2,3)\nEnd\n```\n\nSample Output\n--\n\n```\n10.0000 -3.0000\n18.0000 15.0000\n-10.0000 6.0000\n```\n\nData Constraint\n--\n保证操作中坐标值不会超过double范围，输出不会超过int范围；\n\n指令总共不超过1000行；\n\n对于所有的数据,所有循环指令中m<=1000000；\n\n对于60%的数据,所有循环指令中m<=1000；\n\n对于30%的数据不含嵌套循环。\nAnalysis\n--\n看到这道题，首先想到的肯定是模拟。平移和缩放都是很简单的操作，比较麻烦的是旋转操作。据说有一个公式可以求任意点绕着原点逆时针旋转θrad的公式。\n![绕原点旋转公式](http://img.blog.csdn.net/20150821112509577)\n因为题目要求的是顺时针我们将角度取反再加上2πrad就好了。对于绕着任一点旋转，我们可以平移所有的点，使得给定的点与原点重合，套用公式计算，再把所有的平移回去。这样就可以通过暴力模拟拿到30%的分了。\n\n因为循环的次数非常大，而给出的指令又比较少，所以我们应该想办法将循环之间的状态保存下来然后快速的做n次。因为我们注意到题目中的变换是对于两个变量的线性递推，所以可以用矩阵来实现。而每做一次相当于矩阵自乘一次。因为矩阵具有结合律，所以自乘的操作通过快速幂来实现就好了。\n\n我们可以将每一种操作用矩阵表示出来，O(M)的扫一遍整个指令后将每个矩阵相乘，即可得到做完所有操作后的最终矩阵。然后，我们O(N)的将每一个点都与这个矩阵相乘就能得到这个点经过M次操作后的最终结果了。\n\n接下来就是如何构造矩阵的问题了。平移，缩放的矩阵构造相对简单。基本上是通过系数于变量相乘和相加而得，具体可看程序实现。(可以自己手动模拟模拟矩阵乘法的工作过程)\n比较难得就是旋转的矩阵构造。\n我们不需要将一个旋转命令拆成几个命令，这样子太麻烦。可以一步构造矩阵实现平移与绕远点旋转。\n我们假设图形中的一个点为(x,y)，绕(x0,y0)这个点顺时针旋转θrad(可以通过取反再加上一圈转换)，那么举例说明x'是如何得到的。\nx' = (x-x0)cosθ-(y-y0)sinθ+x0=cosθx-sinθy+sinθy0-cosθx0+x0\ny' = 同理可得\n最后的矩阵就是这样的：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | cosθ | sinθ | 0\n| 2 | -sinθ | cosθ |0\n| 3 | sinθ*y0-cosθ*x0+x0 | cosθ*y0-sin*x0+y0 |1\n对于每一个点构造矩阵：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | x | y | 0\n| 2 | 0 | 0 |0\n| 3 | 0 | 0 |0\n最后就可以在O(M)的时间过啦~~~\nCode\n--\n\n```\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define pi M_PI\n#define rad(x) x*pi/180\nusing namespace std;\n\nconst int N = 105 , M = 1005;\ntypedef double matrix[4][4];\nstruct node\n{\n\tdouble x,y,angle;\n\tint type,time;\n} a[M];\nstruct point\n{\n\tdouble x,y;\n} p[N];\nint n,m,top,stack[M],end[M];\nmatrix H;\nchar ch;\n\nvoid mul(matrix &a,matrix b)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int k=1;k<=3;k++)\n\t\tfor (int i=1;i<=3;i++)\n\t\t\tfor (int j=1;j<=3;j++)\n\t\t\t\tc[i][j] += a[i][k]*b[k][j];\n\tmemcpy(a,c,sizeof c);\n}\nvoid pow(matrix &a,int y)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int i=1;i<=3;i ++) c[i][i]=1;\n\twhile (y>0)\n\t{\n\t\tif (y & 1 == 1) mul(c,a);\n\t\tmul(a,a);\n\t\ty >>= 1;\n\t}\n\tmemcpy(a,c,sizeof c);\n}\nvoid work(int st,int en)\n{\n\tif (st>en) return;\n\tmatrix F,G;\n\tmemset(F,0,sizeof F);\n\tfor (int i=1;i<=3;i++) F[i][i] = 1;\n\tfor (int i=st;i<=en;i++)\n\t{\n\t\tmemset(G,0,sizeof G);\n\t\tif (a[i].type==1)\n\t\t{\n\t\t\tG[1][1] = 1;\n\t\t\tG[2][2] = 1;\n\t\t\tG[3][1] = a[i].x;\n\t\t\tG[3][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==2)\n\t\t{\n\t\t\tG[1][1] = a[i].x;\n\t\t\tG[2][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==3)\n\t\t{\n\t\t\ta[i].angle = 360 - a[i].angle;\n\t\t\tdouble co=cos(rad(a[i].angle)),si=sin(rad(a[i].angle));\n\t\t\tG[1][1] = co;\n\t\t\tG[1][2] = si;\n\t\t\tG[2][1] = -si;\n\t\t\tG[2][2] = co;\n\t\t\tG[3][1] = si*a[i].y-co*a[i].x+a[i].x;\n\t\t\tG[3][2] = -co*a[i].y-si*a[i].x+a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==4)\n\t\t{\n\t\t\twork(i+1,end[i]-1);\n\t\t\tpow(H,a[i].time);\n\t\t\tmul(F,H);\n\t\t\ti = end[i];\n\t\t}\n\n\t}\n\tmemcpy(H,F,sizeof F);\n}\nint main()\n{\n\tfreopen(\"transform.in\",\"r\",stdin);\n\tfreopen(\"transform.out\",\"w\",stdout);\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lf%lf\\n\",&p[i].x,&p[i].y);\n\twhile (scanf(\"%c\",&ch) != EOF)\n\t{\n\t\tm ++;\n\t\tif (ch=='T') a[m].type = 1,scanf(\"rans(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='S') a[m].type = 2,scanf(\"cale(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='R') a[m].type = 3,scanf(\"otate(%lf,%lf,%lf)\\n\",&a[m].angle,&a[m].x,&a[m].y);\n\t\tif (ch=='L') a[m].type = 4,scanf(\"oop(%d)\\n\",&a[m].time);\n\t\tif (ch=='E') a[m].type = 5,scanf(\"nd\\n\");\n\t}\n\n\tint top = 0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (a[i].type == 4) stack[++ top] = i;\n\t\tif (a[i].type == 5) end[stack[top --]] = i;\n\t}\n\twork(1,m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmatrix F;\n\t\tmemset(F,0,sizeof F);\n\t\tF[1][1] = p[i].x , F[1][2] = p[i].y , F[1][3] = 1;\n\t\tmul(F,H);\n\t\tprintf(\"%.4lf %.4lf\\n\",F[1][1],F[1][2]);\n\t}\n\treturn 0;\n}\n```","slug":"图形变换-transform","published":1,"updated":"2016-01-26T13:55:37.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas5f000ydcoqy9r317tc","sticky":0},{"title":"信息学程序模板","date":"2015-11-06T03:52:00.000Z","_content":"tarjan\n<script src=\"https://code.csdn.net/snippets/1310789.js\"></script> \n\n拓扑排序\n<script src=\"https://code.csdn.net/snippets/1310702.js\"></script> \n\n\n\n最小生成树 && 并查集\n<script src=\"https://code.csdn.net/snippets/1310674.js\"></script> \n\n\n\n快速幂\n<script src=\"https://code.csdn.net/snippets/1310653.js\"></script> \n\n\n\nLCA\n<script src=\"https://code.csdn.net/snippets/1310621.js\"></script> \n\n\n\ndijkstra\n<script src=\"https://code.csdn.net/snippets/1310589.js\"></script> \n\n\nspfa\n<script src=\"https://code.csdn.net/snippets/1310489.js\"></script> \n\n\nsort\n<script src=\"https://code.csdn.net/snippets/1310393.js\"></script> \n\n\n网络流最大流sap\n<script src=\"https://code.csdn.net/snippets/1375597.js\"></script> \n\ntri树\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int N = 300005, M = 4000005;\nstruct node\n{\n\tnode(){len = -1;}\n\tbool num;\n\tint len;\n\tint next,dep;\n\tint s[26];\n} h[M];\nint n,m,tot;\nint a[N],f[N];\nchar s[N];\nqueue <int> Q;\n\nvoid init()\n{\n\tscanf(\"%d\\n%s\\n%d\",&n,s,&m);\n\tfor (int i=0;i<n;i ++) a[i] = s[i] - 'a';\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint len = strlen(s),now = 0;\n\t\tfor (int j=0;j<len;j ++)\n\t\t{\n\t\t\tif (!h[now].s[s[j]-'a'])\n\t\t\t\th[now].s[s[j]-'a'] = ++ tot;\n\t\t\tnow = h[now].s[s[j]-'a'];\n\t\t}\n\t\th[now].num = 1;\n\t}\n\t//普通建tri\n\tfor (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);\n\t\n\tfor (int x=Q.front();!Q.empty();x=Q.front())\n\t{\n\t\tQ.pop();\n\t\tfor (int j=0;j<26;j ++)\n\t\t\tif (h[x].s[j])\n\t\t\t{\n\t\t\t\tint y = h[x].s[j];\n\t\t\t\th[y].next = h[h[x].next].s[j];\n\t\t\t\th[y].dep = h[x].dep + 1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t\telse h[x].s[j] = h[h[x].next].s[j];\n\t\tif (h[x].num) h[x].len = h[x].dep;\n\t\tif (h[x].len<0) h[x].len = h[h[x].next].len;\n\t}\n\t//求fail指针\n}\n\nvoid work()\n{\n\tfor (int i=0,x=0;i<n;i ++)\n\t{\n\t\tx = h[x].s[a[i]];\n\t\tif (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];\n\t}\n\tint ans = 0;\n\tfor (int i=0,sum = 0;i<n;i ++)\n\t\tsum += f[i],ans += !sum;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\t//freopen(\"3172.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n```","source":"_posts/信息学程序模板.md","raw":"---\ntitle: 信息学程序模板\ndate: 2015-11-06 11:52:00\ntags:\n  - 模板\ncategories:\n  - 信息学\n  - 原创\n---\ntarjan\n<script src=\"https://code.csdn.net/snippets/1310789.js\"></script> \n\n拓扑排序\n<script src=\"https://code.csdn.net/snippets/1310702.js\"></script> \n\n\n\n最小生成树 && 并查集\n<script src=\"https://code.csdn.net/snippets/1310674.js\"></script> \n\n\n\n快速幂\n<script src=\"https://code.csdn.net/snippets/1310653.js\"></script> \n\n\n\nLCA\n<script src=\"https://code.csdn.net/snippets/1310621.js\"></script> \n\n\n\ndijkstra\n<script src=\"https://code.csdn.net/snippets/1310589.js\"></script> \n\n\nspfa\n<script src=\"https://code.csdn.net/snippets/1310489.js\"></script> \n\n\nsort\n<script src=\"https://code.csdn.net/snippets/1310393.js\"></script> \n\n\n网络流最大流sap\n<script src=\"https://code.csdn.net/snippets/1375597.js\"></script> \n\ntri树\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int N = 300005, M = 4000005;\nstruct node\n{\n\tnode(){len = -1;}\n\tbool num;\n\tint len;\n\tint next,dep;\n\tint s[26];\n} h[M];\nint n,m,tot;\nint a[N],f[N];\nchar s[N];\nqueue <int> Q;\n\nvoid init()\n{\n\tscanf(\"%d\\n%s\\n%d\",&n,s,&m);\n\tfor (int i=0;i<n;i ++) a[i] = s[i] - 'a';\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint len = strlen(s),now = 0;\n\t\tfor (int j=0;j<len;j ++)\n\t\t{\n\t\t\tif (!h[now].s[s[j]-'a'])\n\t\t\t\th[now].s[s[j]-'a'] = ++ tot;\n\t\t\tnow = h[now].s[s[j]-'a'];\n\t\t}\n\t\th[now].num = 1;\n\t}\n\t//普通建tri\n\tfor (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);\n\t\n\tfor (int x=Q.front();!Q.empty();x=Q.front())\n\t{\n\t\tQ.pop();\n\t\tfor (int j=0;j<26;j ++)\n\t\t\tif (h[x].s[j])\n\t\t\t{\n\t\t\t\tint y = h[x].s[j];\n\t\t\t\th[y].next = h[h[x].next].s[j];\n\t\t\t\th[y].dep = h[x].dep + 1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t\telse h[x].s[j] = h[h[x].next].s[j];\n\t\tif (h[x].num) h[x].len = h[x].dep;\n\t\tif (h[x].len<0) h[x].len = h[h[x].next].len;\n\t}\n\t//求fail指针\n}\n\nvoid work()\n{\n\tfor (int i=0,x=0;i<n;i ++)\n\t{\n\t\tx = h[x].s[a[i]];\n\t\tif (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];\n\t}\n\tint ans = 0;\n\tfor (int i=0,sum = 0;i<n;i ++)\n\t\tsum += f[i],ans += !sum;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\t//freopen(\"3172.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n```","slug":"信息学程序模板","published":1,"updated":"2016-01-26T13:55:37.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas5k0013dcoqztgq56fe","sticky":0},{"title":"使用七牛云存储作个人博客图床","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2014/11/25/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/使用七牛云存储作个人博客图床.md","raw":"---\ntitle: 使用七牛云存储作个人博客图床\ntags:\n  - 工具\ncategories:\n  - 互联网\n  - 转载\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2014/11/25/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/\"><title></title></head><body></body></html>\n转载文章","slug":"使用七牛云存储作个人博客图床","published":1,"date":"2016-01-26T13:55:37.070Z","updated":"2016-01-26T13:55:37.070Z","layout":"post","photos":[],"link":"","_id":"cijvhas5t0018dcoq6edrw589","sticky":0},{"title":"从头到尾彻底理解KMP","comments":0,"_content":"<a href=\"http://blog.csdn.net/v_july_v/article/details/7041827\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://blog.csdn.net/v_july_v/article/details/7041827\"><title></title></head><body></body></html>\n","source":"_posts/从头到尾彻底理解KMP.md","raw":"---\ntitle: 从头到尾彻底理解KMP\ntags:\n  - KMP\ncategories:\n  - 信息学\n  - 转载\ncomments: false\n---\n<a href=\"http://blog.csdn.net/v_july_v/article/details/7041827\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://blog.csdn.net/v_july_v/article/details/7041827\"><title></title></head><body></body></html>\n","slug":"从头到尾彻底理解KMP","published":1,"date":"2016-01-26T13:55:37.069Z","updated":"2016-01-26T13:55:37.069Z","layout":"post","photos":[],"link":"","_id":"cijvhas64001fdcoqmmjpub9z","sticky":0},{"title":"五校联考7 总结","date":"2015-10-27T14:18:00.000Z","_content":"Day1\n==\nT1：上三角行列式 \n--\n简单的模拟判断题，但是考试时没注意一点元素的大小是|绝对值|≤10000,当累乘的值是个负数时是不可以取模的。而我并没有判断这种情况，但因为数据太水，还是过了。\n\nT2：n染色\n--\n这道题是一道数学题，考试时并没有推出公式，在隔壁LB的提示下得出了递推公式。然后在运用高中数列知识，将它化为通项公式，再用快速幂等算法的出答案。当然，此题还有很多种解法，也并不需要什么递推公式。考试时是过了的。\n\nT3：游戏 \n--\n这题考试时没有仔细研究，所以拿了60分的部分分。60分是一个O(N^2)的简单dp。后面需要仔细研究一道题。100分有一个巧妙的算法，可以严格O(N)线性解决这道题。\n\nDay2\n==\nT1：QYQ的字符串\n--\n初看此题觉得很难，只会暴力，结果后面发现暴力是可以过的......\n\nT2：QYQ的图\n--\n这道题想不到特别好的算法，想着打了一个搜索 ，枚举哪些点不选。最后题解就是这个方法。我应该是搜索判断选点的时候处理不好，判断方法错了。\n\nT3：QYQ的图\n--\n没有想到特别好的方法，题解是dp。因为dp一直是我的弱项，况且有时候还不知道题目能否dp。所以需要恶补一下才行。","source":"_posts/五校联考7-总结.md","raw":"---\ntitle: 五校联考7 总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-27 22:18:00\n---\nDay1\n==\nT1：上三角行列式 \n--\n简单的模拟判断题，但是考试时没注意一点元素的大小是|绝对值|≤10000,当累乘的值是个负数时是不可以取模的。而我并没有判断这种情况，但因为数据太水，还是过了。\n\nT2：n染色\n--\n这道题是一道数学题，考试时并没有推出公式，在隔壁LB的提示下得出了递推公式。然后在运用高中数列知识，将它化为通项公式，再用快速幂等算法的出答案。当然，此题还有很多种解法，也并不需要什么递推公式。考试时是过了的。\n\nT3：游戏 \n--\n这题考试时没有仔细研究，所以拿了60分的部分分。60分是一个O(N^2)的简单dp。后面需要仔细研究一道题。100分有一个巧妙的算法，可以严格O(N)线性解决这道题。\n\nDay2\n==\nT1：QYQ的字符串\n--\n初看此题觉得很难，只会暴力，结果后面发现暴力是可以过的......\n\nT2：QYQ的图\n--\n这道题想不到特别好的算法，想着打了一个搜索 ，枚举哪些点不选。最后题解就是这个方法。我应该是搜索判断选点的时候处理不好，判断方法错了。\n\nT3：QYQ的图\n--\n没有想到特别好的方法，题解是dp。因为dp一直是我的弱项，况且有时候还不知道题目能否dp。所以需要恶补一下才行。","slug":"五校联考7-总结","published":1,"updated":"2016-01-26T13:55:37.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas69001ldcoq4z2wepy6","sticky":0},{"title":"【转载】表达式求值问题","date":"2015-11-06T02:55:00.000Z","_content":"\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","source":"_posts/【转载】表达式求值问题.md","raw":"title: 【转载】表达式求值问题\ntags: \ncategories: [信息学,转载]\ndate: 2015-11-06 10:55\n---\n\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","slug":"【转载】表达式求值问题","published":1,"updated":"2016-01-26T13:55:37.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas6g001pdcoq7fgo74jv","sticky":0},{"title":"【转载】有向图强连通分量的Tarjan算法","date":"2015-10-29T09:15:00.000Z","_content":"<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","source":"_posts/【转载】有向图强连通分量的Tarjan算法.md","raw":"title: 【转载】有向图强连通分量的Tarjan算法\ntags: \ncategories: [信息学,转载]\ndate: 2015-10-29 17:15\n---\n<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","slug":"【转载】有向图强连通分量的Tarjan算法","published":1,"updated":"2016-01-26T13:55:37.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas6j001sdcoqg1i1h3mt","sticky":0},{"date":"2015-08-16T12:54:00.000Z","title":"【NOIP】独立集(bubble)","_content":"Tips\n--\n题目来源：http://www.luo.hustoj.com/problem.php?id=1287\n\nAnalysis\n--\n从这个顺(dou)旺(bi)基同学的代码中，我们发现他的算法实际上是给逆序对连边，而独立集所在的集合中，任意两个都不存在连边(即不是逆序对)，那就是顺序的。并且题目要求我们要找出一个最大的独立集，求出他的长度，那就是要我们求最长不下降子序列，而因为给出的n个数是全排列。所以就是求最长上升子序列。这个可以用(nlogn)的二分查找求出。最关键的就是怎么求第二问最长上升子序列中那些点是必选的。\n\n首先我们从左往右做一遍最长上升子序列，并得到他的数组f。f[i]表示以i结尾在[1..i]中的最长下上升子序列的长度\n同样我们从右往左最一遍最长下降子序列，并得到他的数组g。g[i]表示以i为结尾的在[i..n]中的最长下降子序列。\n\nans1表示第一个答案（即最长上升子序列）的值\n当f[i]+g[i]-1=ans1时，就说明这个点在其中一个最长上升子序列中（但不是第二题的合法位置）。所以我们要从这些点中找出唯一的点。如果在ans2的数组中发现一个位置有两个人已经使用过了，那么这个位置的答案就是不合法的。\n\n我们来看一下下面这个例子：\n\n\n**i      1  2  3  4  5**\n**a[i]  5  1  3  2  4**\n**f[i]   1  1  2  2  3**\n**g[i]  1  3  2  2  1**\n\nans1=3\n其中，2 3 4 5都是任意最长上升子序列中的一部分，但是因为2 与 3 的f值重复了，所以这两个点就不是答案了。\n\n现在还有一个问题就是如何快速的得到f和g数组。然而网上的O(N log N)只支持求长度而不能得到每一个f或g的值。而O(N^2)的算法又太慢了。因为这道题有一个关键的条件那就是：\n\t输入的数据是全排列\n所以我们可以从左往右求f值，将每一个f值塞入到线段数的叶子[a[i],a[i]]中然后维护线段树的最大值，当计算下一个f[i]的值时，就询问线段书[1,a[i]]的区间中的最大值,将得到的最大值+1就是当前的f[i]值，重复这样的操作就的合法的f序列。正确性显然。\n当你从左往右添加时，由于在右边的f[i]值并没有塞入线段数中，所以询问[1,a[i]]时并不会得到那些f值，只有已经在i前面的f值才能得到，并且这些f值所对应的a[j]都要比a[i]小。就与O(n^2)的算法转移类似。具体实现可看代码。\nCode\n--\n然而此题并不需要如此复杂的线段树，只要支持单点修改和区间查询最大值即可。当然如果你有能力完全可以写树状数组。\n```\nuses\tmath;\nconst\tmaxn=100000;\nvar\ti,n,maxx:longint;\n\th:array[1..4*maxn,1..2] of longint;\n\ta,g,f,ans:array[1..maxn] of longint;\nprocedure change(x,l,r,st,en,val:longint);\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\tinc(h[x,1],val);inc(h[x,2],val);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then change(x+x,l,mid,st,en,val)\n\t\telse if st>mid then change(x+x+1,mid+1,r,st,en,val)\n\t\telse begin\n\t\t\tchange(x+x,l,mid,st,mid,val);\n\t\t\tchange(x+x+1,mid+1,r,mid+1,en,val);\n\t\tend;\n\t\th[x,1]:=max(h[x+x,1],h[x+x+1,1]);\n\tend;\nend;\nfunction quary(x,l,r,st,en:longint):longint;\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\texit(h[x,1]);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then exit(quary(x+x,l,mid,st,en))\n\t\telse if st>mid then exit(quary(x+x+1,mid+1,r,st,en))\n\t\telse\n\t\texit(max(quary(x+x,l,mid,st,mid),quary(x+x+1,mid+1,r,mid+1,en)));\n\tend;\nend;\nbegin\n\t//assign(input,'3485.in');reset(input);\n\n\treadln(n);\n\tfor i:=1 to n do read(a[i]);\n\n\tmaxx:=0;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=1 to n do begin\n\t\tf[i]:=quary(1,1,n,1,a[i])+1;\n\t\tchange(1,1,n,a[i],a[i],f[i]);\n\t\tmaxx:=max(maxx,f[i]);\n\tend;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=n downto 1 do begin\n\t\tg[i]:=quary(1,1,n,a[i],n)+1;\n\t\tchange(1,1,n,a[i],a[i],g[i]);\n\tend;\n\tfor i:=1 to n do begin\n\t\tif (f[i]+g[i]-1=maxx) then begin\n\t\t\tif (ans[f[i]]>0) or (ans[f[i]]=-1) then \n\t\t\t\tans[f[i]]:=-1 \n\t\t\telse ans[f[i]]:=i;\n\t\tend;\n\tend;\n\twriteln(maxx);\n\tfor i:=1 to maxx do \n\t\tif ans[i]>0 then write(ans[i],' ');\n\twriteln;\nend.\n\n```","source":"_posts/【NOIP】独立集-bubble.md","raw":"---\ndate: 2015-08-16 20:54:00\ntitle: 【NOIP】独立集(bubble)\ntags:\n  - 题解\n  - 线段树\ncategories:\n  - 信息学\n  - 原创\n---\nTips\n--\n题目来源：http://www.luo.hustoj.com/problem.php?id=1287\n\nAnalysis\n--\n从这个顺(dou)旺(bi)基同学的代码中，我们发现他的算法实际上是给逆序对连边，而独立集所在的集合中，任意两个都不存在连边(即不是逆序对)，那就是顺序的。并且题目要求我们要找出一个最大的独立集，求出他的长度，那就是要我们求最长不下降子序列，而因为给出的n个数是全排列。所以就是求最长上升子序列。这个可以用(nlogn)的二分查找求出。最关键的就是怎么求第二问最长上升子序列中那些点是必选的。\n\n首先我们从左往右做一遍最长上升子序列，并得到他的数组f。f[i]表示以i结尾在[1..i]中的最长下上升子序列的长度\n同样我们从右往左最一遍最长下降子序列，并得到他的数组g。g[i]表示以i为结尾的在[i..n]中的最长下降子序列。\n\nans1表示第一个答案（即最长上升子序列）的值\n当f[i]+g[i]-1=ans1时，就说明这个点在其中一个最长上升子序列中（但不是第二题的合法位置）。所以我们要从这些点中找出唯一的点。如果在ans2的数组中发现一个位置有两个人已经使用过了，那么这个位置的答案就是不合法的。\n\n我们来看一下下面这个例子：\n\n\n**i      1  2  3  4  5**\n**a[i]  5  1  3  2  4**\n**f[i]   1  1  2  2  3**\n**g[i]  1  3  2  2  1**\n\nans1=3\n其中，2 3 4 5都是任意最长上升子序列中的一部分，但是因为2 与 3 的f值重复了，所以这两个点就不是答案了。\n\n现在还有一个问题就是如何快速的得到f和g数组。然而网上的O(N log N)只支持求长度而不能得到每一个f或g的值。而O(N^2)的算法又太慢了。因为这道题有一个关键的条件那就是：\n\t输入的数据是全排列\n所以我们可以从左往右求f值，将每一个f值塞入到线段数的叶子[a[i],a[i]]中然后维护线段树的最大值，当计算下一个f[i]的值时，就询问线段书[1,a[i]]的区间中的最大值,将得到的最大值+1就是当前的f[i]值，重复这样的操作就的合法的f序列。正确性显然。\n当你从左往右添加时，由于在右边的f[i]值并没有塞入线段数中，所以询问[1,a[i]]时并不会得到那些f值，只有已经在i前面的f值才能得到，并且这些f值所对应的a[j]都要比a[i]小。就与O(n^2)的算法转移类似。具体实现可看代码。\nCode\n--\n然而此题并不需要如此复杂的线段树，只要支持单点修改和区间查询最大值即可。当然如果你有能力完全可以写树状数组。\n```\nuses\tmath;\nconst\tmaxn=100000;\nvar\ti,n,maxx:longint;\n\th:array[1..4*maxn,1..2] of longint;\n\ta,g,f,ans:array[1..maxn] of longint;\nprocedure change(x,l,r,st,en,val:longint);\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\tinc(h[x,1],val);inc(h[x,2],val);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then change(x+x,l,mid,st,en,val)\n\t\telse if st>mid then change(x+x+1,mid+1,r,st,en,val)\n\t\telse begin\n\t\t\tchange(x+x,l,mid,st,mid,val);\n\t\t\tchange(x+x+1,mid+1,r,mid+1,en,val);\n\t\tend;\n\t\th[x,1]:=max(h[x+x,1],h[x+x+1,1]);\n\tend;\nend;\nfunction quary(x,l,r,st,en:longint):longint;\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\texit(h[x,1]);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then exit(quary(x+x,l,mid,st,en))\n\t\telse if st>mid then exit(quary(x+x+1,mid+1,r,st,en))\n\t\telse\n\t\texit(max(quary(x+x,l,mid,st,mid),quary(x+x+1,mid+1,r,mid+1,en)));\n\tend;\nend;\nbegin\n\t//assign(input,'3485.in');reset(input);\n\n\treadln(n);\n\tfor i:=1 to n do read(a[i]);\n\n\tmaxx:=0;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=1 to n do begin\n\t\tf[i]:=quary(1,1,n,1,a[i])+1;\n\t\tchange(1,1,n,a[i],a[i],f[i]);\n\t\tmaxx:=max(maxx,f[i]);\n\tend;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=n downto 1 do begin\n\t\tg[i]:=quary(1,1,n,a[i],n)+1;\n\t\tchange(1,1,n,a[i],a[i],g[i]);\n\tend;\n\tfor i:=1 to n do begin\n\t\tif (f[i]+g[i]-1=maxx) then begin\n\t\t\tif (ans[f[i]]>0) or (ans[f[i]]=-1) then \n\t\t\t\tans[f[i]]:=-1 \n\t\t\telse ans[f[i]]:=i;\n\t\tend;\n\tend;\n\twriteln(maxx);\n\tfor i:=1 to maxx do \n\t\tif ans[i]>0 then write(ans[i],' ');\n\twriteln;\nend.\n\n```","slug":"【NOIP】独立集-bubble","published":1,"updated":"2016-01-26T13:55:37.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas6r001vdcoqdec341w9","sticky":0},{"title":"【NOIP】总结 10.30晚-11.5","date":"2015-11-06T01:05:00.000Z","_content":"**10.30晚**\n--\n**概述**\n一定要用心想算法，在没想清楚之前，不要轻易打程序，不然后面耗的时间会更多\n\n**第一题**：没有细想，直接上暴力。发现暴力跑的挺快的，只有在某些特殊数据下跑的比较慢。要是细想不难发现规律，但还是有很多小细节需要注意。\n\n**第二题**：打了一个非常恶心的暴力，没有细致计算时间复杂度，最后发现好像连30%的数据都过不去。于是看了看数据范围，反过来想考察算法的时间复杂度。最后想到正解了。本来正解是对的，但因为题目描述和自己理解的一点偏差，将正解改成和暴力一样是错的了。\n下次一定要认真细致的看题！！！\n\n**第三题**：斜率优化，比较难想，也比较难打。因为时间原因，直接打了暴力。\n\n**11.2**\n--\n**概述**\n这套题做的很差，都不知道自己考试时在想什么。花了2.5小时打完了所有题的暴力，就陷入了无尽的思考，最后卡在了第二题中不靠谱的位运算优化，直到考试结束依旧没有调出来。时间分配不够合理。\n\n**T1：复制&粘贴2** \n这题其实很简单要有分离的思想，单个字符单个字符想。当看到特殊的数据范围是要注意。考试时只想到将整体的字符串移动，没有想到可以拆开，从后往前做。\n俗话说得好：正难则反，多角度思考。\n\n**T2:愉快的logo设计**\n题目有很好的匹配性质，然而我并没有注意到这一点，反而像另一个方向想（位运算），以致于大部分时间耗在了这道题上。\n\n**T3:有趣的有趣的家庭菜园**\n没有想到正解，就打了个纯暴力，但不知道为何只有9分，判断方式可能有问题。\n\n**11.2晚**\n--\n**概述**\n对自己的算法不要过度自信，一定想到一种在最坏情况下都可过的算法。\n\n**T1:Lala买面包** \n一开始看题目感觉挺简单，就往质因数分解的方向想了。最后面算了一下最坏的时间复杂度，觉得应该比较难构造这样的数据卡我的程序，在随机数测试下表现良好。实际上我想错了。其实我也有朝其他方面想，但是因为不想放弃这种方法，其他想法想的不多。其实真正的YES情况是很少的完全可以预处理出来，然后O(1)判断。\n\n**T2：我的天** \n想了很长一段时间，觉得这题应该用线段树，但是想不到模型转换。\n\n**T3:舳舻牌** \n最怕这种博弈论的题了，当时随便想了一下部分最优解，就打了，骗了5分。\n\n\n**11.3**\n--\n**概述**\n整套题都没什么感觉。觉得整个试题难度挺大的。\n\n**T1：装饰大楼**\n这题首先要观察规律，然后直接计算就好了，我模拟操作太慢了（因为怕错）。\n\n**T2:备用钥匙** \n把题目映射到时间轴后，就想不到其他得了，只能暴力\n\n**T3：IOIOI卡片占卜** \n没什么特别好的想法，那就暴力咯！\n\n\n**11.3晚**\n--\n**概述：**\n这套题基本上能拿的分都拿了。\n\n**T1:次芝麻** \n一开始发现数据有循环节，认为应该从第一位开始循环。后来发现错了。\n其实这题要大胆猜想，他就是不断乘2 mod (n+m)的结果，证明一下发现是可行的。\n这题因为在循环节上耗了太多的时间所以不划算。\n\n**T2：喝喝喝** \n这题想的时间最长，我因为将问题分成了两个自问题来单独考虑，而没有思考这两个子问题的相通性。考试时想到了50%做法，但是程序实现起来太繁琐，再加上时间也不是很够就没打。\n\n**T3:长寿花** \n这题的第一个限制很好做，但是加上了第二个限制就难了。本来我就不擅长推公式，打20%暴力就完了。\n\n\n**11.4**\n--\n**概述：**\n不要不屑于打暴力，有时候暴力也是可以过的。\n\n**T1：格点统计** \n观察一下就可以了O（$sqrt(n)$），注意一下细节。\n\n**T2:电话线铺设** \n考试时想到了正解，但已经没有时间打了。从数据范围推算法复杂度，很好想到正解。\n\n**T3：老司机**\n这题没有考虑到暴力可以过，而我打的暴力，太暴力。所以过的不多。\n\n**11.5**\n--\nNOIP模拟考的最后一试...\n**概述：**\n多思考，认真审题，当题目有些比较特殊的描述时，要细想性质。\n\n**T1：俄罗斯套娃** \n看一下就知道之前做过跟它类似的，还比这难的题。回忆一下，不难写出dp方程。\n\n**T2：Lucas的数列** \n一看就知道是线段树的题目，但是想来想去没仔细往离线方向想，其实这种有两种限制的题目（边做边加）以前做的多了，但考试时就是没有想到\n\n**T3：旅行**\n这题被我想复杂了，用了比较常用的求LCA的方法来做。但是因为没有开long long 爆类型了。其实这道题并没有那么复杂，只要用心观察题目给的特殊性质。就可以发现规律，发现规律后就非常的简单了。\n\n**T4：Xor** \n首先暴力就有30%，随便乱搞就有50%，数据非常的良心，100%的数据也不难，关键是要发现xor的实质，两个数对应的二进制位不同才可以的到更大的xor值，朝这个方向建一颗tri树就好了。","source":"_posts/【NOIP】总结-10-30晚-11-5.md","raw":"---\ntitle: 【NOIP】总结 10.30晚-11.5\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-06 09:05:00\n---\n**10.30晚**\n--\n**概述**\n一定要用心想算法，在没想清楚之前，不要轻易打程序，不然后面耗的时间会更多\n\n**第一题**：没有细想，直接上暴力。发现暴力跑的挺快的，只有在某些特殊数据下跑的比较慢。要是细想不难发现规律，但还是有很多小细节需要注意。\n\n**第二题**：打了一个非常恶心的暴力，没有细致计算时间复杂度，最后发现好像连30%的数据都过不去。于是看了看数据范围，反过来想考察算法的时间复杂度。最后想到正解了。本来正解是对的，但因为题目描述和自己理解的一点偏差，将正解改成和暴力一样是错的了。\n下次一定要认真细致的看题！！！\n\n**第三题**：斜率优化，比较难想，也比较难打。因为时间原因，直接打了暴力。\n\n**11.2**\n--\n**概述**\n这套题做的很差，都不知道自己考试时在想什么。花了2.5小时打完了所有题的暴力，就陷入了无尽的思考，最后卡在了第二题中不靠谱的位运算优化，直到考试结束依旧没有调出来。时间分配不够合理。\n\n**T1：复制&粘贴2** \n这题其实很简单要有分离的思想，单个字符单个字符想。当看到特殊的数据范围是要注意。考试时只想到将整体的字符串移动，没有想到可以拆开，从后往前做。\n俗话说得好：正难则反，多角度思考。\n\n**T2:愉快的logo设计**\n题目有很好的匹配性质，然而我并没有注意到这一点，反而像另一个方向想（位运算），以致于大部分时间耗在了这道题上。\n\n**T3:有趣的有趣的家庭菜园**\n没有想到正解，就打了个纯暴力，但不知道为何只有9分，判断方式可能有问题。\n\n**11.2晚**\n--\n**概述**\n对自己的算法不要过度自信，一定想到一种在最坏情况下都可过的算法。\n\n**T1:Lala买面包** \n一开始看题目感觉挺简单，就往质因数分解的方向想了。最后面算了一下最坏的时间复杂度，觉得应该比较难构造这样的数据卡我的程序，在随机数测试下表现良好。实际上我想错了。其实我也有朝其他方面想，但是因为不想放弃这种方法，其他想法想的不多。其实真正的YES情况是很少的完全可以预处理出来，然后O(1)判断。\n\n**T2：我的天** \n想了很长一段时间，觉得这题应该用线段树，但是想不到模型转换。\n\n**T3:舳舻牌** \n最怕这种博弈论的题了，当时随便想了一下部分最优解，就打了，骗了5分。\n\n\n**11.3**\n--\n**概述**\n整套题都没什么感觉。觉得整个试题难度挺大的。\n\n**T1：装饰大楼**\n这题首先要观察规律，然后直接计算就好了，我模拟操作太慢了（因为怕错）。\n\n**T2:备用钥匙** \n把题目映射到时间轴后，就想不到其他得了，只能暴力\n\n**T3：IOIOI卡片占卜** \n没什么特别好的想法，那就暴力咯！\n\n\n**11.3晚**\n--\n**概述：**\n这套题基本上能拿的分都拿了。\n\n**T1:次芝麻** \n一开始发现数据有循环节，认为应该从第一位开始循环。后来发现错了。\n其实这题要大胆猜想，他就是不断乘2 mod (n+m)的结果，证明一下发现是可行的。\n这题因为在循环节上耗了太多的时间所以不划算。\n\n**T2：喝喝喝** \n这题想的时间最长，我因为将问题分成了两个自问题来单独考虑，而没有思考这两个子问题的相通性。考试时想到了50%做法，但是程序实现起来太繁琐，再加上时间也不是很够就没打。\n\n**T3:长寿花** \n这题的第一个限制很好做，但是加上了第二个限制就难了。本来我就不擅长推公式，打20%暴力就完了。\n\n\n**11.4**\n--\n**概述：**\n不要不屑于打暴力，有时候暴力也是可以过的。\n\n**T1：格点统计** \n观察一下就可以了O（$sqrt(n)$），注意一下细节。\n\n**T2:电话线铺设** \n考试时想到了正解，但已经没有时间打了。从数据范围推算法复杂度，很好想到正解。\n\n**T3：老司机**\n这题没有考虑到暴力可以过，而我打的暴力，太暴力。所以过的不多。\n\n**11.5**\n--\nNOIP模拟考的最后一试...\n**概述：**\n多思考，认真审题，当题目有些比较特殊的描述时，要细想性质。\n\n**T1：俄罗斯套娃** \n看一下就知道之前做过跟它类似的，还比这难的题。回忆一下，不难写出dp方程。\n\n**T2：Lucas的数列** \n一看就知道是线段树的题目，但是想来想去没仔细往离线方向想，其实这种有两种限制的题目（边做边加）以前做的多了，但考试时就是没有想到\n\n**T3：旅行**\n这题被我想复杂了，用了比较常用的求LCA的方法来做。但是因为没有开long long 爆类型了。其实这道题并没有那么复杂，只要用心观察题目给的特殊性质。就可以发现规律，发现规律后就非常的简单了。\n\n**T4：Xor** \n首先暴力就有30%，随便乱搞就有50%，数据非常的良心，100%的数据也不难，关键是要发现xor的实质，两个数对应的二进制位不同才可以的到更大的xor值，朝这个方向建一颗tri树就好了。","slug":"【NOIP】总结-10-30晚-11-5","published":1,"updated":"2016-01-26T13:55:37.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas6v0020dcoqhhcrtohx","sticky":0},{"title":"【NOIP】剑与魔法(dragons)","date":"2015-08-16T11:56:00.000Z","_content":"\nDescription\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```pascal\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","source":"_posts/【NOIP】剑与魔法(dragons).md","raw":"---\ntitle: 【NOIP】剑与魔法(dragons)\ntags: [题解]\ncategories: [信息学,原创]\ndate: 2015-08-16 19:56\n---\n\nDescription\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```pascal\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","slug":"【NOIP】剑与魔法(dragons)","published":1,"updated":"2016-01-26T13:55:37.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas700024dcoqmb79c901","sticky":0},{"title":"【NOIP】11.13-11.14总结","date":"2015-10-29T09:25:00.000Z","_content":"<strong>DAY1\n--\n这次考试时间的分配和程序调试方面都有待加强\n\nT1:题目比较简单，很容易理解。写了个六重循环暴力，没有想到特别好的方法。本来可以加区间累加优化，怕写错就没加。还是拿了60。\n这题用二分答案很好打，只不过要注意判断。一开始我将所有蛋糕块的巧克力都求出来最后判大小，超时！！直接判可以减少不少时间。\n\nT2:一看没有什么思路，在纸上画了下草稿，发现有一条必经之路，每个节点都可以转到这条路的任意一个节点，求它到其他个点的最短距离。想法还是可以的。但是，在调程序时，因为太复杂始终没调处来就放弃了。\n\nT3:根据样例解释和数据范围，结合题目意思，很容易就知道对于每个牛棚，要使其的噪音总和最小，只需将每个牛棚平均分配一下，这样得到的噪音总是最小的。我就只考虑m=1的情况处理了一下，但还是错了。在余数的处理方面有问题。\n\n\n今天的题目理解上比较容易，但是程序实现上还是有难度。\n\n<strong>DAY2\n--\n\nT1：刚开始想的时候就像枚举每一个点是否改变，打了一个dfs，最后面发现忘记考虑M的值，dfs也有些小问题。用dp的做法没想到。不是很会dp，对状态的转移，和组合数的有关知识，有些欠缺。\n\nT2：看到这题本想着用字符串去做，发现会有负数且不宜分割，打了一个类似链表的数组，可能在删除节点的时候，前驱和后继出现了问题。标准答案跟程序的答案。自己试了一些小数据都没有大的问题。看完题解后，发现这道题很简单，用两个栈然后维护前缀的最大值。初赛的时候就曾见过类似的程序。很快就改出来了。\n\nT3：这题刚开始并没有什么好的想法，看了一下数据范围，发现一种变换和两种变换比较好判定。但思考的方向想错了，想着将两种变换解出来，最后没写成。这题还是可以骗些分的。\n\n<strong>Sources\n--\nJZOJ：3918-3920\nJZOJ：3921-3923","source":"_posts/【NOIP】11-13-11-14总结.md","raw":"---\ntitle: 【NOIP】11.13-11.14总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-29 17:25:00\n---\n<strong>DAY1\n--\n这次考试时间的分配和程序调试方面都有待加强\n\nT1:题目比较简单，很容易理解。写了个六重循环暴力，没有想到特别好的方法。本来可以加区间累加优化，怕写错就没加。还是拿了60。\n这题用二分答案很好打，只不过要注意判断。一开始我将所有蛋糕块的巧克力都求出来最后判大小，超时！！直接判可以减少不少时间。\n\nT2:一看没有什么思路，在纸上画了下草稿，发现有一条必经之路，每个节点都可以转到这条路的任意一个节点，求它到其他个点的最短距离。想法还是可以的。但是，在调程序时，因为太复杂始终没调处来就放弃了。\n\nT3:根据样例解释和数据范围，结合题目意思，很容易就知道对于每个牛棚，要使其的噪音总和最小，只需将每个牛棚平均分配一下，这样得到的噪音总是最小的。我就只考虑m=1的情况处理了一下，但还是错了。在余数的处理方面有问题。\n\n\n今天的题目理解上比较容易，但是程序实现上还是有难度。\n\n<strong>DAY2\n--\n\nT1：刚开始想的时候就像枚举每一个点是否改变，打了一个dfs，最后面发现忘记考虑M的值，dfs也有些小问题。用dp的做法没想到。不是很会dp，对状态的转移，和组合数的有关知识，有些欠缺。\n\nT2：看到这题本想着用字符串去做，发现会有负数且不宜分割，打了一个类似链表的数组，可能在删除节点的时候，前驱和后继出现了问题。标准答案跟程序的答案。自己试了一些小数据都没有大的问题。看完题解后，发现这道题很简单，用两个栈然后维护前缀的最大值。初赛的时候就曾见过类似的程序。很快就改出来了。\n\nT3：这题刚开始并没有什么好的想法，看了一下数据范围，发现一种变换和两种变换比较好判定。但思考的方向想错了，想着将两种变换解出来，最后没写成。这题还是可以骗些分的。\n\n<strong>Sources\n--\nJZOJ：3918-3920\nJZOJ：3921-3923","slug":"【NOIP】11-13-11-14总结","published":1,"updated":"2016-01-26T13:55:37.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas740028dcoqnxcn7c5a","sticky":0},{"title":"【NOIP】10.31总结","date":"2015-11-05T09:12:00.000Z","_content":"<strong>概述\n--\n今天这套题做的还好，只是一开始题目意思比较难以理解。\n****\n<strong>T1:Ocd \n--\n第一题看了半天都没看明白。最后通过样例数据和猜测，明白了题目的意思。\n并没有什么太好的方法，打了个暴力本来想着应该过40%的数据，最后过了70%。正解也不是特别难想。\n****\n<strong>T2:Mancity \n--\n没有特别好的方法，一步一步走暴力\n****\n<strong>T3:Captcha \n--\n****\n这题比较好玩，虽然代码复杂度比较高，但仔细想一下，发现其中的规律，还是很好做的","source":"_posts/【NOIP】10-31总结.md","raw":"---\ntitle: 【NOIP】10.31总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-05 17:12:00\n---\n<strong>概述\n--\n今天这套题做的还好，只是一开始题目意思比较难以理解。\n****\n<strong>T1:Ocd \n--\n第一题看了半天都没看明白。最后通过样例数据和猜测，明白了题目的意思。\n并没有什么太好的方法，打了个暴力本来想着应该过40%的数据，最后过了70%。正解也不是特别难想。\n****\n<strong>T2:Mancity \n--\n没有特别好的方法，一步一步走暴力\n****\n<strong>T3:Captcha \n--\n****\n这题比较好玩，虽然代码复杂度比较高，但仔细想一下，发现其中的规律，还是很好做的","slug":"【NOIP】10-31总结","published":1,"updated":"2016-01-26T13:55:36.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas79002cdcoq500rh27n","sticky":0},{"title":"【NOIP】10.29总结 B组","date":"2015-10-29T09:05:00.000Z","_content":"<strong>概述\n--\n今天这套题并不太难，时间分配还算比较合理。第一题花费的时间有点多。\n第四题，一开始想的太复杂了。打程序前一定要确定算法的可行性，及算法的复杂度。想好再打，不然会白白浪费很多调试时间。\n<strong>T1:质数 \n--\n第一题比较简单，先筛选处理出$\\sqrt{n}$的素数，然后枚举素数。注意一下边界，记得测试小数据，和大数据就行了。\n\n<strong>T2:平方数游戏 \n--\n这题打完40分暴力后就去做后面的题，因为过多的专注于第二问的回答。没仔细观察第一问的回答，是有循环节的。当我昨晚后面的题时，回过头已经没时间了，当时也不知道有这样的规律。下次对于额外数据还是多关注一下。\n<strong>T3:树上路径\n--\n先画一副复杂一点的树，观察一下发现每个节点只需要维护三个值就好了。\n考试时不大确定其正确性。\n<strong>T3:抓知了 \n--\n首先给定一个序列，就是要我们求最长不下降子序列。dfs动态维护F数组即可。\n考试时以为既要满足最长不下降子序列,还要求它们的和。\n理解错题意，下次要注意。","source":"_posts/【NOIP】10-29总结-B组.md","raw":"---\ntitle: 【NOIP】10.29总结 B组\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-29 17:05:00\n---\n<strong>概述\n--\n今天这套题并不太难，时间分配还算比较合理。第一题花费的时间有点多。\n第四题，一开始想的太复杂了。打程序前一定要确定算法的可行性，及算法的复杂度。想好再打，不然会白白浪费很多调试时间。\n<strong>T1:质数 \n--\n第一题比较简单，先筛选处理出$\\sqrt{n}$的素数，然后枚举素数。注意一下边界，记得测试小数据，和大数据就行了。\n\n<strong>T2:平方数游戏 \n--\n这题打完40分暴力后就去做后面的题，因为过多的专注于第二问的回答。没仔细观察第一问的回答，是有循环节的。当我昨晚后面的题时，回过头已经没时间了，当时也不知道有这样的规律。下次对于额外数据还是多关注一下。\n<strong>T3:树上路径\n--\n先画一副复杂一点的树，观察一下发现每个节点只需要维护三个值就好了。\n考试时不大确定其正确性。\n<strong>T3:抓知了 \n--\n首先给定一个序列，就是要我们求最长不下降子序列。dfs动态维护F数组即可。\n考试时以为既要满足最长不下降子序列,还要求它们的和。\n理解错题意，下次要注意。","slug":"【NOIP】10-29总结-B组","published":1,"updated":"2016-01-26T13:55:36.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas7e002gdcoqsrludg9l","sticky":0},{"title":"【NOIP】10.28总结 A组","date":"2015-10-28T03:28:00.000Z","_content":"概述：\n--\n看完题目整个人都是晕的，感觉上第二题较简单一点。\n这次考试时间分配上不好，因为总想把第二题调出来，花费了大量时间。最后还是不要太依赖调试工具和对拍，多读读代码！！\nT1：0(0)，T2：0(50)，T3：30(30)\nT1：同余 \n--\n考试时看到这题一点想法都没有，只想到暴力，感觉暴力效率太低了，就暂且跳过了。\n有关数论、乘法逆元等相关知识。\n\nT2:数列\n--\n又犯了和昨天类似的问题，没有看到输出格式中的解释。一开始以为题目出错了。题目要求的是最优方案对应的序号。\n先看数据：暴力乱搞就有30分了......\n再看额外数据。打表搞出几种情况，发现他们之间的规律，然后就照着想法打了。\n其实想法没错，但是考试时花了很多时间在调试身上，对拍的时候发现一个又一个bug，还有一个bug是暴力程序错了。耗费了我大量时间。\n这题满分做法就是贪心，要是当时想的在深入一点，可能就能想到正解了！\n\nT3:递推\n--\n看完题目先想了一下暴力，可以过前30%的数据。再看那20%的数据，发觉是一个斐波那契数列，但是要打一个矩阵乘法太麻烦，时间也已经不容许我打了。这题的关键在于将题目的意思转变成一个矩阵对矩阵进行加法乘法，再配上数学上的优化，就好了。","source":"_posts/【NOIP】10-28总结-A组.md","raw":"---\ntitle: 【NOIP】10.28总结 A组\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-28 11:28:00\n---\n概述：\n--\n看完题目整个人都是晕的，感觉上第二题较简单一点。\n这次考试时间分配上不好，因为总想把第二题调出来，花费了大量时间。最后还是不要太依赖调试工具和对拍，多读读代码！！\nT1：0(0)，T2：0(50)，T3：30(30)\nT1：同余 \n--\n考试时看到这题一点想法都没有，只想到暴力，感觉暴力效率太低了，就暂且跳过了。\n有关数论、乘法逆元等相关知识。\n\nT2:数列\n--\n又犯了和昨天类似的问题，没有看到输出格式中的解释。一开始以为题目出错了。题目要求的是最优方案对应的序号。\n先看数据：暴力乱搞就有30分了......\n再看额外数据。打表搞出几种情况，发现他们之间的规律，然后就照着想法打了。\n其实想法没错，但是考试时花了很多时间在调试身上，对拍的时候发现一个又一个bug，还有一个bug是暴力程序错了。耗费了我大量时间。\n这题满分做法就是贪心，要是当时想的在深入一点，可能就能想到正解了！\n\nT3:递推\n--\n看完题目先想了一下暴力，可以过前30%的数据。再看那20%的数据，发觉是一个斐波那契数列，但是要打一个矩阵乘法太麻烦，时间也已经不容许我打了。这题的关键在于将题目的意思转变成一个矩阵对矩阵进行加法乘法，再配上数学上的优化，就好了。","slug":"【NOIP】10-28总结-A组","published":1,"updated":"2016-01-26T13:55:36.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas7k002kdcoqdwm8ofu9","sticky":0},{"title":"【NOIP2015】10.30总结","date":"2015-10-30T08:04:00.000Z","_content":"<strong>概述\n--\n这套题题目难度还是比较大的。但不管题目有多难，都不能弃疗！！能拿的暴力分都要拿。\n\n<strong>T1:Family \n--\n第一题其实还是比较简单的，然而我陷入了一个思维中，没有从其他角度想。应该有种全局的眼光，不要只盯着少了几个点对看。以致于前1个小时的时间都在想这道题，拖慢了后面的题。从其他角度想更容易想到正解，而且也很好理解。目前已知至少有3种方法能解决问题。\n所以最后只拿了50%的数据。\n\n<strong>T2:Flower\n--\n看完题目很快就明白这题的题目意思，让我们在n个数中选任意的k个数的乘积的和。很快想到一个O(n^2)的dp。100%的做法，也是从这个dp中推来的。后面的计算方法就比较复杂，考试的时候也没时间细想。\n\n<strong>T3:Forget \n--\n这题题目内容比较繁琐，要将题目意思转化为数学模型。但是被题目绕的稀里糊涂。如果充分理解题目意思（在n个标号中选连续k个标号，让这些标号在树中都有边能够联通），还是很好打暴力的！","source":"_posts/【NOIP2015】10-30总结.md","raw":"---\ntitle: 【NOIP2015】10.30总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-30 16:04:00\n---\n<strong>概述\n--\n这套题题目难度还是比较大的。但不管题目有多难，都不能弃疗！！能拿的暴力分都要拿。\n\n<strong>T1:Family \n--\n第一题其实还是比较简单的，然而我陷入了一个思维中，没有从其他角度想。应该有种全局的眼光，不要只盯着少了几个点对看。以致于前1个小时的时间都在想这道题，拖慢了后面的题。从其他角度想更容易想到正解，而且也很好理解。目前已知至少有3种方法能解决问题。\n所以最后只拿了50%的数据。\n\n<strong>T2:Flower\n--\n看完题目很快就明白这题的题目意思，让我们在n个数中选任意的k个数的乘积的和。很快想到一个O(n^2)的dp。100%的做法，也是从这个dp中推来的。后面的计算方法就比较复杂，考试的时候也没时间细想。\n\n<strong>T3:Forget \n--\n这题题目内容比较繁琐，要将题目意思转化为数学模型。但是被题目绕的稀里糊涂。如果充分理解题目意思（在n个标号中选连续k个标号，让这些标号在树中都有边能够联通），还是很好打暴力的！","slug":"【NOIP2015】10-30总结","published":1,"updated":"2016-01-26T13:55:36.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas7p002odcoqxvn8nw4g","sticky":0},{"title":"【NOIP2013模拟联考9】阿Q的停车场","date":"2015-08-11T00:24:00.000Z","_content":"Description\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","source":"_posts/【NOIP2013模拟联考9】阿Q的停车场.md","raw":"title:  【NOIP2013模拟联考9】阿Q的停车场\ntags: [题解]\ncategories: [信息学,原创]\ndate: 2015-08-11 08:24\n---\nDescription\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","slug":"【NOIP2013模拟联考9】阿Q的停车场","published":1,"updated":"2016-01-26T13:55:36.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas7s002sdcoq0tpufamn","sticky":0},{"title":"Hello World","date":"2015-12-17T11:00:00.000Z","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\ndate: 2015-12-17 19:00:00\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-01-26T13:55:36.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas80002wdcoq4yrky3qw","sticky":0},{"title":"cc软件集","date":"2012-03-24T12:56:48.000Z","_content":"cc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","source":"_posts/cc软件集.md","raw":"title: cc软件集\ndate: 2012-3-24 20:56:48\ntags: [软件]\ncategories: [易语言,原创]\n---\ncc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","slug":"cc软件集","published":1,"updated":"2016-01-26T13:55:36.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas83002xdcoqc5jth5jt","sticky":0},{"title":"bzoj3732 Network","date":"2015-08-11T13:13:00.000Z","_content":"Description\n==\n题目来源\nbzoj[3732]\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=3732\n\n\nAnalysis\n==\n这题给的输入是一个无向连通图，说明图中会有环和一些树枝。对于一个询问在环上的两个点，有两条可以联通的道路。\n一条中的边权最大值是整个环的最大值（舍弃），\n另一条的边权最大值是整个环的次大值（需要）。\n所以只有次大值才是我们想要的！因此，我们想到了最小生成树，将这些环中的最大边权值所属的边删掉。\n最小生成树的求法就是，先让边权从小到大排序，然后依次添加并用并查集维护即可。（Kruskal算法）\n\n所以，现在问题就转化成在一棵树中，求任意两点A，B路径上边权的最大值。\n\n此时我们就需要求LCA了，并维护两点到LCA边权的最大值，在做LCA的时候使用倍增算法，再配上RMQ问题中的st算法即可解决问题。\n\ncode\n==\n\n```C++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=30000+100,M=30000+100;\n\nstruct node{int x,y,d;}c[N];\nstruct node1{int y,v,next;}h[2*M];\nint n,m,k,u,v,tot,e[N],fw[N][16],fv[N][16],fa[N],dep[N];\n\nbool cmp(node a, node b) {return a.d<b.d;}\n\nint gf(int x)\n{\n\tif (fa[x] == x) return x;\n\treturn fa[x] = gf(fa[x]);\n}\n\nvoid add(int x,int y,int z)\n{\n\ttot ++;\n\th[tot].y = y;\n\th[tot].v = z;\n\th[tot].next=e[x];\n\te[x] = tot;\n}\n\nvoid dfs(int x ,int fat)\n{\n\tfor (int i = e[x];i;i = h[i].next)\n\t\tif (h[i].y!=fat)\n\t\t{\n\t\t\tdep[h[i].y] = dep[x]+1;\n\t\t\tdfs(h[i].y,x);\n\t\t\tfv[h[i].y][0] = h[i].v;\n\t\t\tfw[h[i].y][0] = x;\n\t\t}\n}\n\nint move(int &x,int d)\n{\n\tint i,t=0;\n\twhile (dep[fw[x][0]]!=d)\n\t{\n\t\tfor (i = 0;dep[fw[x][i]]>d;i++);\n\t\tt = max(t,fv[x][i-1]);\n\t\tx = fw[x][i-1];\n\t}\n\tt = max(t,fv[x][0]);\n\tx = fw[x][0];\n\treturn t;\n}\n\nint lca(int u,int v)\n{\n\tint i,t = 0;\n\tif (dep[u]>dep[v]) t = move(u,dep[v]);\n\telse if (dep[u]<dep[v]) t = move(v,dep[u]);\n\twhile (fw[u][0]!=fw[v][0])\n\t{\n\t\tfor (i = 0;fw[u][i] != fw[v][i];i ++);\n\t\tt = max(t,max(fv[u][i-1],fv[v][i-1]));\n\t\tu = fw[u][i-1];\n\t\tv = fw[v][i-1];\n\t}\n\tif (u!=v)\n\tt = max(max(fv[u][0],fv[v][0]),t);\n\treturn t;\n}\n\nint main()\n{\n\t//freopen(\"1738.in\",\"r\",stdin);\n\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor (int i=1;i <= m ; i ++)\n\tscanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].d);\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1 ; i <= n ; i ++) fa[i]=i;\n\tfor (int i=1 ; i <= m ; i ++)\n\t{\n\t\tif (gf(c[i].x)!=gf(c[i].y))\n\t\t{\n\t\t\tadd(c[i].x,c[i].y,c[i].d);\n\t\t\tadd(c[i].y,c[i].x,c[i].d);\n\t\t\tfa[fa[c[i].x]] = fa[fa[c[i].y]];\n\t\t}\n\t}\n\tdep[1] = 1;\n\tdfs(1,0);\n\tfor (int j=1 ; j <= 14; j ++)\n\tfor (int i=1 ;i<=n;i ++)\n\tif (fw[fw[i][j-1]][j-1] != 0)//limit excepeted\n\t{\n\t\tfw[i][j] = fw[fw[i][j-1]][j-1];\n\t\tfv[i][j] = max(fv[i][j-1],fv[fw[i][j-1]][j-1]);\n\t}\n\tfor (int i = 1 ; i <= k ; i ++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tprintf(\"%d\\n\",lca(u,v));\n\t}\n\n\treturn 0;\n}\n```\n\nTips\n==\nKruskal算法：http://baike.baidu.com/link?url=0x-xezmCp5Fud_PyEPvp6gBHGzdU2tnG-6zEg42g5f6jL7QCCOygSbY8CwqnDalzqb9Ol-36JJJVrw2UBaN5x_#4_1\nLCA 倍增算法：http://www.tuicool.com/articles/N7jQV32\nRMQ st算法http://www.cnblogs.com/Missa/archive/2012/10/01/2709686.html\n\n","source":"_posts/bzoj3732-Network.md","raw":"---\ntitle: bzoj3732 Network\ndate: 2015-08-11 21:13\ntags:\n  - 题解\n  - LCA\n  - RMQ\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n==\n题目来源\nbzoj[3732]\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=3732\n\n\nAnalysis\n==\n这题给的输入是一个无向连通图，说明图中会有环和一些树枝。对于一个询问在环上的两个点，有两条可以联通的道路。\n一条中的边权最大值是整个环的最大值（舍弃），\n另一条的边权最大值是整个环的次大值（需要）。\n所以只有次大值才是我们想要的！因此，我们想到了最小生成树，将这些环中的最大边权值所属的边删掉。\n最小生成树的求法就是，先让边权从小到大排序，然后依次添加并用并查集维护即可。（Kruskal算法）\n\n所以，现在问题就转化成在一棵树中，求任意两点A，B路径上边权的最大值。\n\n此时我们就需要求LCA了，并维护两点到LCA边权的最大值，在做LCA的时候使用倍增算法，再配上RMQ问题中的st算法即可解决问题。\n\ncode\n==\n\n```C++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=30000+100,M=30000+100;\n\nstruct node{int x,y,d;}c[N];\nstruct node1{int y,v,next;}h[2*M];\nint n,m,k,u,v,tot,e[N],fw[N][16],fv[N][16],fa[N],dep[N];\n\nbool cmp(node a, node b) {return a.d<b.d;}\n\nint gf(int x)\n{\n\tif (fa[x] == x) return x;\n\treturn fa[x] = gf(fa[x]);\n}\n\nvoid add(int x,int y,int z)\n{\n\ttot ++;\n\th[tot].y = y;\n\th[tot].v = z;\n\th[tot].next=e[x];\n\te[x] = tot;\n}\n\nvoid dfs(int x ,int fat)\n{\n\tfor (int i = e[x];i;i = h[i].next)\n\t\tif (h[i].y!=fat)\n\t\t{\n\t\t\tdep[h[i].y] = dep[x]+1;\n\t\t\tdfs(h[i].y,x);\n\t\t\tfv[h[i].y][0] = h[i].v;\n\t\t\tfw[h[i].y][0] = x;\n\t\t}\n}\n\nint move(int &x,int d)\n{\n\tint i,t=0;\n\twhile (dep[fw[x][0]]!=d)\n\t{\n\t\tfor (i = 0;dep[fw[x][i]]>d;i++);\n\t\tt = max(t,fv[x][i-1]);\n\t\tx = fw[x][i-1];\n\t}\n\tt = max(t,fv[x][0]);\n\tx = fw[x][0];\n\treturn t;\n}\n\nint lca(int u,int v)\n{\n\tint i,t = 0;\n\tif (dep[u]>dep[v]) t = move(u,dep[v]);\n\telse if (dep[u]<dep[v]) t = move(v,dep[u]);\n\twhile (fw[u][0]!=fw[v][0])\n\t{\n\t\tfor (i = 0;fw[u][i] != fw[v][i];i ++);\n\t\tt = max(t,max(fv[u][i-1],fv[v][i-1]));\n\t\tu = fw[u][i-1];\n\t\tv = fw[v][i-1];\n\t}\n\tif (u!=v)\n\tt = max(max(fv[u][0],fv[v][0]),t);\n\treturn t;\n}\n\nint main()\n{\n\t//freopen(\"1738.in\",\"r\",stdin);\n\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor (int i=1;i <= m ; i ++)\n\tscanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].d);\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1 ; i <= n ; i ++) fa[i]=i;\n\tfor (int i=1 ; i <= m ; i ++)\n\t{\n\t\tif (gf(c[i].x)!=gf(c[i].y))\n\t\t{\n\t\t\tadd(c[i].x,c[i].y,c[i].d);\n\t\t\tadd(c[i].y,c[i].x,c[i].d);\n\t\t\tfa[fa[c[i].x]] = fa[fa[c[i].y]];\n\t\t}\n\t}\n\tdep[1] = 1;\n\tdfs(1,0);\n\tfor (int j=1 ; j <= 14; j ++)\n\tfor (int i=1 ;i<=n;i ++)\n\tif (fw[fw[i][j-1]][j-1] != 0)//limit excepeted\n\t{\n\t\tfw[i][j] = fw[fw[i][j-1]][j-1];\n\t\tfv[i][j] = max(fv[i][j-1],fv[fw[i][j-1]][j-1]);\n\t}\n\tfor (int i = 1 ; i <= k ; i ++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tprintf(\"%d\\n\",lca(u,v));\n\t}\n\n\treturn 0;\n}\n```\n\nTips\n==\nKruskal算法：http://baike.baidu.com/link?url=0x-xezmCp5Fud_PyEPvp6gBHGzdU2tnG-6zEg42g5f6jL7QCCOygSbY8CwqnDalzqb9Ol-36JJJVrw2UBaN5x_#4_1\nLCA 倍增算法：http://www.tuicool.com/articles/N7jQV32\nRMQ st算法http://www.cnblogs.com/Missa/archive/2012/10/01/2709686.html\n\n","slug":"bzoj3732-Network","published":1,"updated":"2016-01-26T13:55:36.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas860031dcoqmb1v4v4r","sticky":0},{"title":"Road","date":"2015-12-20T10:07:30.000Z","_content":"\n**Description**\n--\n给你一棵有N个结点的数。这N个结点都有一个权值为$C[i]$。\n询问你两个结点u、v，在这两个结点的最短路径上，选取两个点i、j，且i靠近结点u，j靠近结点v。让你计算$Max(c[j]-c[i],0)$\n\n**Input**\n--\n输入第一行有一个整数N(1≤n≤50000)\n接下来有N 行，每行一个整数Ci(1≤Ci≤50000)\n再接下来有N-1 行，每行两个整数x,y(1≤x,y≤50000)，表示x 和y 之间有一条边。\n接下来有一个整数M，表示有M 个询问。\n然后M 行，每行两个整数，x,y(1≤x,y≤50000)询问$Max(c[j]-c[i],0)$\n**Output**\n--\n对于每次询问,输出对应最大值结果\n\n**Sample Input**\n--\n\n```\n4 \n1 \n2 \n3\n4\n1 2\n1 4\n2 3\n3\n1 3\n3 1\n1 4\n```\n\n**Sample Output**\n--\n\n```\n2\n0\n3\n```\n\n**Data Constraint**\n--\n对于30%的数据, 1≤N,M≤100\n对于60%的数据，1≤N,M≤1000\n对于100%的数据，1≤N,M≤50000\n\n**Analysis**\n--\n因为是一棵树，所以任意两点的最短路径是唯一的。\n**1°30%　＆＆　60％的数据**\n\n - 对于每一个询问我们可以O(N)的扫一遍整副图，直到找到终点v。并记录下此时经过路径的结点。然后在O(3*N)的扫一遍得到从结点u到结点i的最小值$(\\sum\\_{i=u}^v A[i] = Min(C[i]))$，以及从结点i到结点v的最大值$(\\sum\\_{i=v}^u B[i] = Max(C[i]))$，最后只需要每一个结点对应扫一遍就行了计算最大值即可。$(\\sum\\_{i=u}^v Ans = Max(B[i]-A[i]))$。这样做的时间复杂度就是$O（MN）$。\n\n - 还有一种是这种算法的改进。\n就是充分利用树的特点，先dfs预处理一遍所有结点到根节点的深度，在一步步向上跳。直到调到他们的LCA。后续的答案计算和前面一样。时间复杂度虽然也是$O（MN）$，可是当数据是随机生成的时候很有可能会优化到$O(2*M*log(N))$。\n\n详情请见代码1......\n\n****\n**2°100％的数据**\n这种涉及到路径的问题肯定会与LCA有关，LCA最快的在线做法就是倍增。\n但是倍增在计算是需要合并两个块，所以我们可以考虑一下，怎样合并两个块。\n对于一个块就是一个有顺序的结点集合，它需要存放四个值，即：\n1. 块中所有结点的最小值 (buy)\n2. 块中所有结点的最大值 (sell)\n3. 先最小值后最大值的差的绝对值的最大值(Max(bs))\n4. 先最大值后最小值的差的绝对值的最大值(Min(sb))\n****\n我们发现当维护了这四个值后我们就可以进行块合并操作了。\n假设要合并的块分别为A和B，合并后的块为C。\n1. $C.buy = Min(A.buy,B.buy)$\n2. $C.sell = Max(A.sell,B.sell)$\n3. $C.bs = Max(A.bs,B.bs,B.sell-A.buy)$\n4. $C.sb = Max(A.sb,B.sb,A.sell-B.buy)$\n\n然后倍增的到LCA后我们只需要知道$\\sum\\_{i=u}^{LCA}$的块与$\\sum\\_{i=v}^{LCA}$的块合并后即可知道答案。\n同理我们也可以用tarjan离线LCA的方法来解决这个问题，这样时间复杂度就是$O（N）$。\n详情请见代码2......\n****\n**下面说一下具体的程序实现的小问题**\n对于离线的tarjan算法，因为用到了并查集，所以我们可以对每一个节点，维护它向上的块，维护的大小取决于当前并查集的大小，这样就能完成从$\\sum\\_{i=u}^{LCA}$的块维护，对于另一边我们可以在(u,v)的LCA上打一个标记，当tarjan遍历回到了LCA后。在进行合并。\n可以对照这篇博客中的图看一看：http://blog.csdn.net/hnust_xiehonghao/article/details/9109295\n****\n**Code**\n--\n代码1：\n\n```\nuses\tmath;\nconst\tmaxn=50002;\ntype\tnode=record\n\t\ty,next:longint;\n\tend;\nvar\ti,j,k,m,n,tot,x,y,ans:longint;\n\tv,e,dep,fa:array[1..maxn] of longint;\n\th:array[1..2*maxn] of node;\n\ta,a1,a2,b,c:array[0..maxn] of longint;\n\tflag:array[1..maxn] of boolean;\nprocedure add(x,y:longint);\nbegin\n\tinc(tot);\n\th[tot].y:=y;\n\th[tot].next:=e[x];\n\te[x]:=tot;\nend;\nprocedure dfs(x:longint);\nvar\ti:longint;\nbegin\n\tif flag[x] then exit;\n\tflag[x]:=true;\n\ti:=e[x];\n\twhile i<>0 do begin\n\t\tif flag[h[i].y] then begin\n\t\t\ti:=h[i].next;\n\t\t\tcontinue;\n\t\tend;\n\t\tdep[h[i].y]:=dep[x]+1;\n\t\tfa[h[i].y]:=x;\n\t\tdfs(h[i].y);\n\t\ti:=h[i].next;\n\tend;\nend;\nprocedure up(var x:longint;y:longint);\nbegin\n\tif odd(y) then begin\n\t\tinc(a1[0]);\n\t\ta1[a1[0]]:=x;\n\tend else begin\n\t\tinc(a2[0]);\n\t\ta2[a2[0]]:=x;\n\tend;\n\tx:=fa[x];\nend;\nprocedure link;\nvar\ti:longint;\nbegin\n\tfor i:=1 to a1[0] do a[i]:=a1[i];\n\ta[0]:=a1[0];\n\tfor i:=a2[0] downto 1 do begin\n\t\tinc(a[0]);\n\t\ta[a[0]]:=a2[i];\n\tend;\nend;\nprocedure work(x,y:longint);\nvar\ti:longint;\nbegin\n\ta1[0]:=0;a2[0]:=0;ans:=0;\n\twhile dep[x]>dep[y] do up(x,1);\n\twhile dep[x]<dep[y] do up(y,2);\n\twhile x<>y do begin\n\t\tup(x,1);up(y,2);\n\tend;\n\tinc(a1[0]);\n\ta1[a1[0]]:=x;\n\tlink;\n\tb[0]:=1000000007;c[a[0]+1]:=0;\n\tfor i:=1 to a[0] do b[i]:=min(b[i-1],v[a[i]]);\n\tfor i:=a[0] downto 1 do c[i]:=max(c[i+1],v[a[i]]);\n\tfor i:=1 to a[0] do ans:=max(ans,c[i]-b[i]);\n\t{\n\tfor i:=1 to a[0] do begin\n\t\tfor j:=i+1 to a[0] do begin\n\t\t\tans:=max(ans,v[a[j]]-v[a[i]]);\n\t\tend;\n\tend;\n\t}\nend;\nbegin\n\t//assign(input,'1230.in');reset(input);\n\t//assign(output,'1230.out');rewrite(output);\n\n\treadln(n);\n\tfor i:=1 to n do read(v[i]);\n\tfor i:=1 to n-1 do begin\n\t\treadln(x,y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\tend;\n\tdep[1]:=1;fa[1]:=0;\n\tdfs(1);\n\treadln(m);\n\tfor i:=1 to m do begin\n\t\treadln(x,y);\n\t\twork(x,y);\n\t\twriteln(ans);\n\tend;\nend.\n```\n\n****\n代码2：\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int N = 50000+5,M = N*3;\n\nstruct node\n{\n\tint fa,buy,sell,bs,sb;\n\tnode (int A=0,int B=0,int C=0,int D=0,int E=0)\n\t{\n\t\tfa = A,buy = B,sell = C,bs = D,sb = E;\n\t}\n} f[N];\n\nstruct Edge\n{\n\tint y,next;\n} h[3][M];\n\nint e[3][N],tot[3],b[N][2],ans[N],a[N];\nint n,m;\nbool vis[N];\n\nvoid add(int x,int y,int kind)\n{\n\th[kind][++ tot[kind]].y = y;\n\th[kind][tot[kind]].next = e[kind][x];\n\te[kind][x] = tot[kind];\n}\n\nnode gf(int x)\n{\n\tnode t;\n\tif (f[x].fa != x)\n\t{\n\t\tt = gf(f[x].fa);\n\t\tf[x] = node(t.fa,min(f[x].buy,t.buy),max(f[x].sell,t.sell),max(t.sell-f[x].buy,max(f[x].bs,t.bs)),max(f[x].sell-t.buy,max(f[x].sb,t.sb)));\n\t}\n\treturn f[x];\n}\n\nvoid tarjan(int x,int fa)\n{\n\tvis[x] = 1;\n\tfor (int i=e[0][x];i;i=h[0][i].next)\n\t{\n\t\tint y = h[0][i].y;\n\t\tif (y==fa) continue; \n\t\ttarjan(y,x);\n\t\tf[y].fa = x;\n\t}\n\tfor (int i=e[1][x];i;i=h[1][i].next)\n\t{\n\t\tint j = h[1][i].y,y = b[j][b[j][0] == x];//Υµ½Αν»µγ\n\t\tif (!vis[y]) continue;\n\t\tif (gf(y).fa != x) \n\t\t\tadd(f[y].fa,j,2);\n\t}\n\tfor (int i=e[2][x];i;i = h[2][i].next)\n\t{\n\t\tint j=h[2][i].y,x=b[j][0],y=b[j][1];\n\t\tgf(x),gf(y);\n\t\tans[j] = max(ans[j],f[x].bs);\n\t\tans[j] = max(ans[j],f[y].sb);\n\t\tans[j] = max(ans[j],f[y].sell-f[x].buy);\n\t}\n}\n\n\nint main()\n{\n\t//freopen(\"1230.in\",\"r\",stdin);\n\t//freopen(\"1230.out\",\"w\",stdout);\n\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i ++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i] = node(i,a[i],a[i],0,0);\n\t}\n\tfor (int i=1;i<n;i ++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y,0),add(y,x,0);\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%d%d\",&b[i][0],&b[i][1]);\n\t\tadd(b[i][0],i,1);add(b[i][1],i,1);\n\t}\n\ttarjan(1,0);\n\tfor (int i=1;i<=m;i ++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```","source":"_posts/Road.md","raw":"---\ntitle: Road\ntags:\n  - 题解\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-12-20 18:07:30\n---\n\n**Description**\n--\n给你一棵有N个结点的数。这N个结点都有一个权值为$C[i]$。\n询问你两个结点u、v，在这两个结点的最短路径上，选取两个点i、j，且i靠近结点u，j靠近结点v。让你计算$Max(c[j]-c[i],0)$\n\n**Input**\n--\n输入第一行有一个整数N(1≤n≤50000)\n接下来有N 行，每行一个整数Ci(1≤Ci≤50000)\n再接下来有N-1 行，每行两个整数x,y(1≤x,y≤50000)，表示x 和y 之间有一条边。\n接下来有一个整数M，表示有M 个询问。\n然后M 行，每行两个整数，x,y(1≤x,y≤50000)询问$Max(c[j]-c[i],0)$\n**Output**\n--\n对于每次询问,输出对应最大值结果\n\n**Sample Input**\n--\n\n```\n4 \n1 \n2 \n3\n4\n1 2\n1 4\n2 3\n3\n1 3\n3 1\n1 4\n```\n\n**Sample Output**\n--\n\n```\n2\n0\n3\n```\n\n**Data Constraint**\n--\n对于30%的数据, 1≤N,M≤100\n对于60%的数据，1≤N,M≤1000\n对于100%的数据，1≤N,M≤50000\n\n**Analysis**\n--\n因为是一棵树，所以任意两点的最短路径是唯一的。\n**1°30%　＆＆　60％的数据**\n\n - 对于每一个询问我们可以O(N)的扫一遍整副图，直到找到终点v。并记录下此时经过路径的结点。然后在O(3*N)的扫一遍得到从结点u到结点i的最小值$(\\sum\\_{i=u}^v A[i] = Min(C[i]))$，以及从结点i到结点v的最大值$(\\sum\\_{i=v}^u B[i] = Max(C[i]))$，最后只需要每一个结点对应扫一遍就行了计算最大值即可。$(\\sum\\_{i=u}^v Ans = Max(B[i]-A[i]))$。这样做的时间复杂度就是$O（MN）$。\n\n - 还有一种是这种算法的改进。\n就是充分利用树的特点，先dfs预处理一遍所有结点到根节点的深度，在一步步向上跳。直到调到他们的LCA。后续的答案计算和前面一样。时间复杂度虽然也是$O（MN）$，可是当数据是随机生成的时候很有可能会优化到$O(2*M*log(N))$。\n\n详情请见代码1......\n\n****\n**2°100％的数据**\n这种涉及到路径的问题肯定会与LCA有关，LCA最快的在线做法就是倍增。\n但是倍增在计算是需要合并两个块，所以我们可以考虑一下，怎样合并两个块。\n对于一个块就是一个有顺序的结点集合，它需要存放四个值，即：\n1. 块中所有结点的最小值 (buy)\n2. 块中所有结点的最大值 (sell)\n3. 先最小值后最大值的差的绝对值的最大值(Max(bs))\n4. 先最大值后最小值的差的绝对值的最大值(Min(sb))\n****\n我们发现当维护了这四个值后我们就可以进行块合并操作了。\n假设要合并的块分别为A和B，合并后的块为C。\n1. $C.buy = Min(A.buy,B.buy)$\n2. $C.sell = Max(A.sell,B.sell)$\n3. $C.bs = Max(A.bs,B.bs,B.sell-A.buy)$\n4. $C.sb = Max(A.sb,B.sb,A.sell-B.buy)$\n\n然后倍增的到LCA后我们只需要知道$\\sum\\_{i=u}^{LCA}$的块与$\\sum\\_{i=v}^{LCA}$的块合并后即可知道答案。\n同理我们也可以用tarjan离线LCA的方法来解决这个问题，这样时间复杂度就是$O（N）$。\n详情请见代码2......\n****\n**下面说一下具体的程序实现的小问题**\n对于离线的tarjan算法，因为用到了并查集，所以我们可以对每一个节点，维护它向上的块，维护的大小取决于当前并查集的大小，这样就能完成从$\\sum\\_{i=u}^{LCA}$的块维护，对于另一边我们可以在(u,v)的LCA上打一个标记，当tarjan遍历回到了LCA后。在进行合并。\n可以对照这篇博客中的图看一看：http://blog.csdn.net/hnust_xiehonghao/article/details/9109295\n****\n**Code**\n--\n代码1：\n\n```\nuses\tmath;\nconst\tmaxn=50002;\ntype\tnode=record\n\t\ty,next:longint;\n\tend;\nvar\ti,j,k,m,n,tot,x,y,ans:longint;\n\tv,e,dep,fa:array[1..maxn] of longint;\n\th:array[1..2*maxn] of node;\n\ta,a1,a2,b,c:array[0..maxn] of longint;\n\tflag:array[1..maxn] of boolean;\nprocedure add(x,y:longint);\nbegin\n\tinc(tot);\n\th[tot].y:=y;\n\th[tot].next:=e[x];\n\te[x]:=tot;\nend;\nprocedure dfs(x:longint);\nvar\ti:longint;\nbegin\n\tif flag[x] then exit;\n\tflag[x]:=true;\n\ti:=e[x];\n\twhile i<>0 do begin\n\t\tif flag[h[i].y] then begin\n\t\t\ti:=h[i].next;\n\t\t\tcontinue;\n\t\tend;\n\t\tdep[h[i].y]:=dep[x]+1;\n\t\tfa[h[i].y]:=x;\n\t\tdfs(h[i].y);\n\t\ti:=h[i].next;\n\tend;\nend;\nprocedure up(var x:longint;y:longint);\nbegin\n\tif odd(y) then begin\n\t\tinc(a1[0]);\n\t\ta1[a1[0]]:=x;\n\tend else begin\n\t\tinc(a2[0]);\n\t\ta2[a2[0]]:=x;\n\tend;\n\tx:=fa[x];\nend;\nprocedure link;\nvar\ti:longint;\nbegin\n\tfor i:=1 to a1[0] do a[i]:=a1[i];\n\ta[0]:=a1[0];\n\tfor i:=a2[0] downto 1 do begin\n\t\tinc(a[0]);\n\t\ta[a[0]]:=a2[i];\n\tend;\nend;\nprocedure work(x,y:longint);\nvar\ti:longint;\nbegin\n\ta1[0]:=0;a2[0]:=0;ans:=0;\n\twhile dep[x]>dep[y] do up(x,1);\n\twhile dep[x]<dep[y] do up(y,2);\n\twhile x<>y do begin\n\t\tup(x,1);up(y,2);\n\tend;\n\tinc(a1[0]);\n\ta1[a1[0]]:=x;\n\tlink;\n\tb[0]:=1000000007;c[a[0]+1]:=0;\n\tfor i:=1 to a[0] do b[i]:=min(b[i-1],v[a[i]]);\n\tfor i:=a[0] downto 1 do c[i]:=max(c[i+1],v[a[i]]);\n\tfor i:=1 to a[0] do ans:=max(ans,c[i]-b[i]);\n\t{\n\tfor i:=1 to a[0] do begin\n\t\tfor j:=i+1 to a[0] do begin\n\t\t\tans:=max(ans,v[a[j]]-v[a[i]]);\n\t\tend;\n\tend;\n\t}\nend;\nbegin\n\t//assign(input,'1230.in');reset(input);\n\t//assign(output,'1230.out');rewrite(output);\n\n\treadln(n);\n\tfor i:=1 to n do read(v[i]);\n\tfor i:=1 to n-1 do begin\n\t\treadln(x,y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\tend;\n\tdep[1]:=1;fa[1]:=0;\n\tdfs(1);\n\treadln(m);\n\tfor i:=1 to m do begin\n\t\treadln(x,y);\n\t\twork(x,y);\n\t\twriteln(ans);\n\tend;\nend.\n```\n\n****\n代码2：\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int N = 50000+5,M = N*3;\n\nstruct node\n{\n\tint fa,buy,sell,bs,sb;\n\tnode (int A=0,int B=0,int C=0,int D=0,int E=0)\n\t{\n\t\tfa = A,buy = B,sell = C,bs = D,sb = E;\n\t}\n} f[N];\n\nstruct Edge\n{\n\tint y,next;\n} h[3][M];\n\nint e[3][N],tot[3],b[N][2],ans[N],a[N];\nint n,m;\nbool vis[N];\n\nvoid add(int x,int y,int kind)\n{\n\th[kind][++ tot[kind]].y = y;\n\th[kind][tot[kind]].next = e[kind][x];\n\te[kind][x] = tot[kind];\n}\n\nnode gf(int x)\n{\n\tnode t;\n\tif (f[x].fa != x)\n\t{\n\t\tt = gf(f[x].fa);\n\t\tf[x] = node(t.fa,min(f[x].buy,t.buy),max(f[x].sell,t.sell),max(t.sell-f[x].buy,max(f[x].bs,t.bs)),max(f[x].sell-t.buy,max(f[x].sb,t.sb)));\n\t}\n\treturn f[x];\n}\n\nvoid tarjan(int x,int fa)\n{\n\tvis[x] = 1;\n\tfor (int i=e[0][x];i;i=h[0][i].next)\n\t{\n\t\tint y = h[0][i].y;\n\t\tif (y==fa) continue; \n\t\ttarjan(y,x);\n\t\tf[y].fa = x;\n\t}\n\tfor (int i=e[1][x];i;i=h[1][i].next)\n\t{\n\t\tint j = h[1][i].y,y = b[j][b[j][0] == x];//Υµ½Αν»µγ\n\t\tif (!vis[y]) continue;\n\t\tif (gf(y).fa != x) \n\t\t\tadd(f[y].fa,j,2);\n\t}\n\tfor (int i=e[2][x];i;i = h[2][i].next)\n\t{\n\t\tint j=h[2][i].y,x=b[j][0],y=b[j][1];\n\t\tgf(x),gf(y);\n\t\tans[j] = max(ans[j],f[x].bs);\n\t\tans[j] = max(ans[j],f[y].sb);\n\t\tans[j] = max(ans[j],f[y].sell-f[x].buy);\n\t}\n}\n\n\nint main()\n{\n\t//freopen(\"1230.in\",\"r\",stdin);\n\t//freopen(\"1230.out\",\"w\",stdout);\n\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i ++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i] = node(i,a[i],a[i],0,0);\n\t}\n\tfor (int i=1;i<n;i ++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y,0),add(y,x,0);\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%d%d\",&b[i][0],&b[i][1]);\n\t\tadd(b[i][0],i,1);add(b[i][1],i,1);\n\t}\n\ttarjan(1,0);\n\tfor (int i=1;i<=m;i ++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```","slug":"Road","published":1,"updated":"2016-01-26T13:55:36.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas8e0039dcoqnhctjysp","sticky":0},{"title":"[NOIP2015提高组复赛]总结","date":"2015-11-17T09:16:00.000Z","_content":"**概述**\n--\n考试时太浮躁！不要心急打程序，一定要静下心来仔细思考算法。是否可行（时限能否过）。保证思考算法的时间。对于自己熟练地算法，要相信能想得出来就一定能最快的调出来。根据数据范围，大胆猜测考得是什么算法。有时候直接想暴力是不科学的，暴力有时非常的复杂，还会带乱对整道题的思绪。\n对一些普通算法的应用还不够了解，看不出一道题考察的是什么算法。平时训练要多一些对算法的思考，能不看题解就不看题解，花多点时间在思考上。\n**DAY1**\n--\n开考时有点小紧张，看到T1题目很长，就更紧张了！！！\nT1:仔细读题，纯暴力。打完用了半个小时，又打了一个判断正确性的程序拍了一下，花了1个多小时，耗时较大，拖慢了后面的解题时间。\n\nT2:紧张依旧挥之不去，随手画了个图，发现是找一个最小的环，然后就想到了tarjan缩点。就开打了。到了最后才发现，tarjan会爆栈，然而为时已晚。\n考试时要及时测试小数据和大数据，不要嫌麻烦而只出随机数据。尽管大部分时候程序可以在随机数据下面表现良好。\n考试时要冷静下来，仔细思考算法是否存在漏洞。\n\nT3:题目复杂，加之从小到大不会打牌，所以看了很多遍题目。大概了解了出牌方法。发现了花色是没有用的。\n于是打dfs，但是没有将牌统计到一块打了半天又长又有诸多bug。所以直接被我推倒重来了。感觉dfs特别难打，所以打了一个错误的贪心。\n\n**DAY2**\n--\nT1:这道题怎么想都没有想到可以用二分答案的方法去算，一开始想把每一块最短的石头都拿出来，但是部分最优解并不能推出全局最有解。所以打了一个错误的贪心，在贪心的路上越走越远，依然没走到尽头。\n\nT2:想到搜索,算了一下搜索太慢。就冲着50%的数据去了，但是到最后面k==m的情况还是没有想到满足时限的做法。当时只要推一下，很快就能得到dp方程。\n\nT3:打了倍增最短路，计划过30%的数据，确实想不到特别好的算法，暴力非常复杂，打了很长时间，才打完。","source":"_posts/NOIP2015提高组复赛-总结.md","raw":"---\ntitle: '[NOIP2015提高组复赛]总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-17 17:16:00\n---\n**概述**\n--\n考试时太浮躁！不要心急打程序，一定要静下心来仔细思考算法。是否可行（时限能否过）。保证思考算法的时间。对于自己熟练地算法，要相信能想得出来就一定能最快的调出来。根据数据范围，大胆猜测考得是什么算法。有时候直接想暴力是不科学的，暴力有时非常的复杂，还会带乱对整道题的思绪。\n对一些普通算法的应用还不够了解，看不出一道题考察的是什么算法。平时训练要多一些对算法的思考，能不看题解就不看题解，花多点时间在思考上。\n**DAY1**\n--\n开考时有点小紧张，看到T1题目很长，就更紧张了！！！\nT1:仔细读题，纯暴力。打完用了半个小时，又打了一个判断正确性的程序拍了一下，花了1个多小时，耗时较大，拖慢了后面的解题时间。\n\nT2:紧张依旧挥之不去，随手画了个图，发现是找一个最小的环，然后就想到了tarjan缩点。就开打了。到了最后才发现，tarjan会爆栈，然而为时已晚。\n考试时要及时测试小数据和大数据，不要嫌麻烦而只出随机数据。尽管大部分时候程序可以在随机数据下面表现良好。\n考试时要冷静下来，仔细思考算法是否存在漏洞。\n\nT3:题目复杂，加之从小到大不会打牌，所以看了很多遍题目。大概了解了出牌方法。发现了花色是没有用的。\n于是打dfs，但是没有将牌统计到一块打了半天又长又有诸多bug。所以直接被我推倒重来了。感觉dfs特别难打，所以打了一个错误的贪心。\n\n**DAY2**\n--\nT1:这道题怎么想都没有想到可以用二分答案的方法去算，一开始想把每一块最短的石头都拿出来，但是部分最优解并不能推出全局最有解。所以打了一个错误的贪心，在贪心的路上越走越远，依然没走到尽头。\n\nT2:想到搜索,算了一下搜索太慢。就冲着50%的数据去了，但是到最后面k==m的情况还是没有想到满足时限的做法。当时只要推一下，很快就能得到dp方程。\n\nT3:打了倍增最短路，计划过30%的数据，确实想不到特别好的算法，暴力非常复杂，打了很长时间，才打完。","slug":"NOIP2015提高组复赛-总结","published":1,"updated":"2016-01-26T13:55:36.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas8j003ddcoqi78wy4vj","sticky":0},{"title":"[NOIP]考前必备","date":"2015-11-03T09:26:00.000Z","_content":"考试前首先要调整好自己的心态，忘却之前发生的任何事情。\n\n<strong>考试前(调试机子)\n==\n首先做好所有文件名后缀的关联，将.in，.out的文件关联至Notepad ++。\n将.cpp，.pas关联至gvim。\n在_vimrc中敲入下面配置信息\n****\n```\nsyntax on\nset nu!\ncolorscheme darkblue\n\nimap <F2> <esc>:w<cr>i\nimap <F9> <F2><esc>:!fpc -g %<cr>i\nimap <F10> <F2><esc>:!g++ -Wall -g % -o %:r<cr>i\nimap <F11> assign(input,'.in');reset(input);\nimap <F12> freopen(\".in\",\"r\",stdin);\n```\n****\n在notepad ++中设置\n****\n 1. 将窗口界面调小\n 2. 配色方案选择blackboard\n 3. 在首选项中设置自动更新文件\n****\n打好对拍程序\n****\n对拍\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t2.exe<data.in>1.out\n\t22.exe<data.in>11.out\nfc \"1.out\" \"11.out\"\nif not errorlevel 1 goto loop\npause\ngoto loop\n```\n单测\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t1.exe<data.in\n\techo .............\n\techo.\ngoto loop\n```\n****\n打好文件输入输出\n****\ncpp版本\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\treturn 0;\n}\n```\npascal版本\n\n```\nvar\ti,j,k,m,n:longint;\nbegin\n\tassign(input,'.in');reset(input);\n\tassign(output,'.out');rewrite(output);\n\t\n\tclose(input);close(output);\nend.\n```\n\n****\n测试一下g++,fpc,gdb是否可用，若不可用，将环境变量设置一下。\n\n<strong>考试中\n==\n考试时间3.5小时，有三道题目，注意分配好时间。\n1. 先浏览三道题目，确保充分理解题目意思，并且能够模拟出样例数据。自己在心中评出试题的难度等级(一般题目顺序就是难度顺序)。最好能够在15分钟完成这部分内容。\n2. 对每一道题目重新理解后，对照着数据范围想一个暴力可过好打的程序。(作为对拍的标程)，然后尽自己所能想一个最好的算法。\n\t\n - 在样例数据可以过的情况下，手动出一些小数据和一些一般性数据。然后用data生成大数据测试。\n - 在暴力确保正确性，且不超过暴力程序的数据范围的情况下，对拍“标程”。\n\n3.在完成并测试过第一题的时间最好在比赛开始后的1个小时内(方便准备后面的题目)\n4.第二三题尽量在1个小时之内完成。\n5.在考试后的最后10分钟内，停止正在做的题目，将所有的程序文件输入输出改对，去掉调试代码。还有时间在争取能否做完其他题目。\n\n<strong>考试后\n==\n1. 跟同学讨论一下试题，调整好心态，忘掉当天发生的任何事。\n2. 如果心理素质较好写个总结也是可以的\n\n<strong>NOIP知识点\n==\nhttp://blog.sina.com.cn/s/blog_6b249a4f0100uvu1.html\nhttp://www.zybang.com/question/924e718b7ff691252820f49ddec9e792.html\n","source":"_posts/NOIP-考前必备.md","raw":"---\ntitle: '[NOIP]考前必备'\ndate: 2015-11-03 17:26:00\ntags:\ncategories:\n  - 信息学\n  - 原创\n---\n考试前首先要调整好自己的心态，忘却之前发生的任何事情。\n\n<strong>考试前(调试机子)\n==\n首先做好所有文件名后缀的关联，将.in，.out的文件关联至Notepad ++。\n将.cpp，.pas关联至gvim。\n在_vimrc中敲入下面配置信息\n****\n```\nsyntax on\nset nu!\ncolorscheme darkblue\n\nimap <F2> <esc>:w<cr>i\nimap <F9> <F2><esc>:!fpc -g %<cr>i\nimap <F10> <F2><esc>:!g++ -Wall -g % -o %:r<cr>i\nimap <F11> assign(input,'.in');reset(input);\nimap <F12> freopen(\".in\",\"r\",stdin);\n```\n****\n在notepad ++中设置\n****\n 1. 将窗口界面调小\n 2. 配色方案选择blackboard\n 3. 在首选项中设置自动更新文件\n****\n打好对拍程序\n****\n对拍\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t2.exe<data.in>1.out\n\t22.exe<data.in>11.out\nfc \"1.out\" \"11.out\"\nif not errorlevel 1 goto loop\npause\ngoto loop\n```\n单测\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t1.exe<data.in\n\techo .............\n\techo.\ngoto loop\n```\n****\n打好文件输入输出\n****\ncpp版本\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\treturn 0;\n}\n```\npascal版本\n\n```\nvar\ti,j,k,m,n:longint;\nbegin\n\tassign(input,'.in');reset(input);\n\tassign(output,'.out');rewrite(output);\n\t\n\tclose(input);close(output);\nend.\n```\n\n****\n测试一下g++,fpc,gdb是否可用，若不可用，将环境变量设置一下。\n\n<strong>考试中\n==\n考试时间3.5小时，有三道题目，注意分配好时间。\n1. 先浏览三道题目，确保充分理解题目意思，并且能够模拟出样例数据。自己在心中评出试题的难度等级(一般题目顺序就是难度顺序)。最好能够在15分钟完成这部分内容。\n2. 对每一道题目重新理解后，对照着数据范围想一个暴力可过好打的程序。(作为对拍的标程)，然后尽自己所能想一个最好的算法。\n\t\n - 在样例数据可以过的情况下，手动出一些小数据和一些一般性数据。然后用data生成大数据测试。\n - 在暴力确保正确性，且不超过暴力程序的数据范围的情况下，对拍“标程”。\n\n3.在完成并测试过第一题的时间最好在比赛开始后的1个小时内(方便准备后面的题目)\n4.第二三题尽量在1个小时之内完成。\n5.在考试后的最后10分钟内，停止正在做的题目，将所有的程序文件输入输出改对，去掉调试代码。还有时间在争取能否做完其他题目。\n\n<strong>考试后\n==\n1. 跟同学讨论一下试题，调整好心态，忘掉当天发生的任何事。\n2. 如果心理素质较好写个总结也是可以的\n\n<strong>NOIP知识点\n==\nhttp://blog.sina.com.cn/s/blog_6b249a4f0100uvu1.html\nhttp://www.zybang.com/question/924e718b7ff691252820f49ddec9e792.html\n","slug":"NOIP-考前必备","published":1,"updated":"2016-01-26T13:55:36.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas8n003hdcoqh8767jnp","sticky":0},{"title":"[NOIP]11.21总结","date":"2015-11-21T07:49:00.000Z","_content":"T1:粉刷匠\n刚一开始看错题目啦!我认为竖着也可以粉刷,然而并不是,这只是每行粉刷。\n因为每一行都是独立的，所以可以分开一行一行染色，随后染色的数目等于T，对于每一行，只需要看这一行用j次粉刷能粉刷的最大数目是多少就可以了。\n\nT2:迷路\n在不知道是矩阵乘法时，我是没思路的，当知道是矩阵乘法时只知道边权为1时怎么做。当边权为1时，矩阵乘法一次邻接矩阵，就相当于都走了一步。\n因为边权很小在$[1,9]$之间,所以可以将一个点拆成9个点,将他们连接起来。做T次矩阵乘法，就能得到答案。\n\nT3:游戏\n将对应关系建成一幅图，发现整个图是有若干个环组成。答案就是求若干个环的大小相加为N时的$\\Sigma(LCM)$。到了这一步就不知道怎么做了。因为这里有一个性质\n\n> 考虑最小公倍数不为1的情况，这它为m。\n则m=p1^a1*p2^a2...，而对于一个m，存在一个序列的最小公倍数为m的充要条件是：\np1^a1+p2^a2+....<=n。\n\n按照上述条件做一下背包就可以了。$F[i][j]$表示做到第i个质数$\\Sigma$为j时$(j<=n)$\n\n","source":"_posts/NOIP-11-21总结.md","raw":"---\ntitle: '[NOIP]11.21总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-21 15:49:00\n---\nT1:粉刷匠\n刚一开始看错题目啦!我认为竖着也可以粉刷,然而并不是,这只是每行粉刷。\n因为每一行都是独立的，所以可以分开一行一行染色，随后染色的数目等于T，对于每一行，只需要看这一行用j次粉刷能粉刷的最大数目是多少就可以了。\n\nT2:迷路\n在不知道是矩阵乘法时，我是没思路的，当知道是矩阵乘法时只知道边权为1时怎么做。当边权为1时，矩阵乘法一次邻接矩阵，就相当于都走了一步。\n因为边权很小在$[1,9]$之间,所以可以将一个点拆成9个点,将他们连接起来。做T次矩阵乘法，就能得到答案。\n\nT3:游戏\n将对应关系建成一幅图，发现整个图是有若干个环组成。答案就是求若干个环的大小相加为N时的$\\Sigma(LCM)$。到了这一步就不知道怎么做了。因为这里有一个性质\n\n> 考虑最小公倍数不为1的情况，这它为m。\n则m=p1^a1*p2^a2...，而对于一个m，存在一个序列的最小公倍数为m的充要条件是：\np1^a1+p2^a2+....<=n。\n\n按照上述条件做一下背包就可以了。$F[i][j]$表示做到第i个质数$\\Sigma$为j时$(j<=n)$\n\n","slug":"NOIP-11-21总结","published":1,"updated":"2016-01-26T13:55:36.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas8w003kdcoq3e0km6wb","sticky":0},{"title":"[NOIP]10.27总结","date":"2015-10-27T14:08:00.000Z","_content":"概述\n--\n这场比赛主要是第二题题意理解上出了问题，以及第三题的推导公式还有待加强。\nT1:挑竹签\n--\n看完题目后，想着画了一下与之对应的图。发现此题就是每次取走入度为0的节点（竹签），询问最多能取多少。那就是一个拓扑排序，知道最后只剩下环。（环是无法挑的）\n\nT2：魔道研究\n--\n这题我连题目意思都理解错了，还理解错了两次。直到考试结束后经与其他人的讨论，才彻底理解了题目的意思。一开始想的题目意思太简单了。认为只是纯模拟给出的操作，最后输出结果。后面理解了题目意思，想了很久都没想到什么特别好的数据结构，最后提示用线段树，想想很快就懂了。用map存一下就好了。复杂度是O（NlogN）的。测试了些大数据级小数据后就去看第三题了。\n\nT3：魔法阵\n==\n看着这题复杂，所以直奔部分分去了，对于k=1的情况还是很好想的。每个相邻矩形中差的三角形数是定制4*6，所以等差数列求第n项就好了。对于k=2的情况想了很久，本来想放弃的，但是考试时间还多，就拿起来退了一下。可能是推错了。最后没得部分分。\n\n","source":"_posts/NOIP-10-27总结.md","raw":"---\ntitle: '[NOIP]10.27总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-27 22:08:00\n---\n概述\n--\n这场比赛主要是第二题题意理解上出了问题，以及第三题的推导公式还有待加强。\nT1:挑竹签\n--\n看完题目后，想着画了一下与之对应的图。发现此题就是每次取走入度为0的节点（竹签），询问最多能取多少。那就是一个拓扑排序，知道最后只剩下环。（环是无法挑的）\n\nT2：魔道研究\n--\n这题我连题目意思都理解错了，还理解错了两次。直到考试结束后经与其他人的讨论，才彻底理解了题目的意思。一开始想的题目意思太简单了。认为只是纯模拟给出的操作，最后输出结果。后面理解了题目意思，想了很久都没想到什么特别好的数据结构，最后提示用线段树，想想很快就懂了。用map存一下就好了。复杂度是O（NlogN）的。测试了些大数据级小数据后就去看第三题了。\n\nT3：魔法阵\n==\n看着这题复杂，所以直奔部分分去了，对于k=1的情况还是很好想的。每个相邻矩形中差的三角形数是定制4*6，所以等差数列求第n项就好了。对于k=2的情况想了很久，本来想放弃的，但是考试时间还多，就拿起来退了一下。可能是推错了。最后没得部分分。\n\n","slug":"NOIP-10-27总结","published":1,"updated":"2016-01-26T13:55:36.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas95003odcoqtx3dqbw1","sticky":0},{"title":"Git教程","date":"2015-12-12T05:13:00.000Z","_content":"#关于本教程\n![Git-Logo](http://img.blog.csdn.net/20151212130120447)\n\n##史上最浅显易懂的Git教程！\n\n为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。\n\n既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？\n\n首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度；\n\n其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。\n\n##文字+图片还看不明白？有视频！！！\n\n本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。\n\n如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！\n\n##关于作者\n\n<a href=\"http://weibo.com/liaoxuefeng\">廖雪峰</a>，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在[GitHub](https://github.com/michaelliao)，欢迎微博交流：\n\n<a href=\"http://weibo.com/u/1658384301?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/1658384301/078cedea/2.png\"/></a>\n\n\n#Git简介\n\nGit是什么？\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。\n\nGit有什么特点？简单来说就是：高端大气上档次！\n\n那什么是版本控制系统？\n\n如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：\n\n想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130221073)\n\n过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。\n\n看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。\n\n更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。\n\n于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？\n\n这个软件用起来就应该像这个样子，能记录每次文件的改动：\n\n<table class=\"table table-bordered\">\n<tr><th>版本</th><th>用户</th><th>说明</th><th>日期</th></tr>\n<tr><td>1</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr>\n<tr><td>2</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr>\n<tr><td>3</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr>\n<tr><td>4</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr>\n</table>\n\n这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。\n\n##Git的诞生\n\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\n\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\n\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\n\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\n\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n\n##集中式vs分布式\n\nLinus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？\n\n先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130245660)\n\n集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。\n\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130259965)\n\n当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。\n\nCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n\n\n#安装Git\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n\n要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：\n\n## 在Linux上安装Git\n\n首先，你可以试着输入git，看看系统有没有安装Git：\n\n    $ git\n    The program 'git' is currently not installed. You can install it by typing:\n    sudo apt-get install git\n\n像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。\n\n如果你碰巧用Debian或Ubuntu Linux，通过一条“sudo apt-get install git”就可以直接完成Git的安装，非常简单。\n\n<video width=\"638\" height=\"478\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.webm\" /></video>\n\n老一点的Debian或Ubuntu Linux，要把命令改为“sudo apt-get install git-core”，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。\n\n如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。\n\n## 在Mac OS X上安装Git\n\n如果你正在使用Mac做开发，有两种安装Git的方法。\n\n一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：[http://brew.sh/](http://brew.sh/)。\n\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130320870)\n\nXcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！\n\n## 在Windows上安装Git\n\n实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。\n\nWindows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。\n\nmsysgit是Windows版的Git，从[http://msysgit.github.io/](http://msysgit.github.io/)下载，然后按默认选项安装即可。\n\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130331785)\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n    $ git config --global user.name \"Your Name\"\n    $ git config --global user.email \"email@example.com\"\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意*git config*命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n\n#创建版本库\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n    $ mkdir learngit\n    $ cd learngit\n    $ pwd\n    /Users/michael/learngit\n\npwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。\n\n<i class=\"icon-warning-sign\"></i> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\n\n    $ git init\n    Initialized empty Git repository in /Users/michael/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.webm\" /></video>\n\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n\n## 把文件添加到版本库\n\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n<i class=\"icon-warning-sign\"></i> 使用Windows的童鞋要特别注意，千万不要使用Windows自带的**记事本**编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载[Notepad++](http://notepad-plus-plus.org/)代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130355971)\n\n言归正传，现在我们编写一个readme.txt文件，内容如下：\n\n    Git is a version control system.\n    Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n第一步，用命令*git add*告诉Git，把文件添加到仓库：\n\n    $ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n\n第二步，用命令*git commit*告诉Git，把文件提交到仓库：\n\n    $ git commit -m \"wrote a readme file\"\n    [master (root-commit) cb926e7] wrote a readme file\n     1 file changed, 2 insertions(+)\n     create mode 100644 readme.txt\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.webm\" /></video>\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\n嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。\n\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。\n\n为什么Git添加文件需要*add*，*commit*一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n    $ git add file1.txt\n    $ git add file2.txt\n    $ git add file3.txt\n    $ git commit -m \"add 3 files.\"\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n* 第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；\n\n* 第二步，使用命令git commit，完成。\n\n\n#时光机穿梭\n\n我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：\n\n    Git is a distributed version control system.\n    Git is free software.\n\n现在，运行*git status*命令看看结果：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #\tmodified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n*git status*命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用*git diff*这个命令看看：\n\n    $ git diff readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 46d49bf..9247db6 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,2 +1,2 @@\n    -Git is a version control system.\n    +Git is a distributed version control system.\n     Git is free software.\n\n*git diff*顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。\n\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\n\n    $ git add readme.txt\n\n同样没有任何输出。在执行第二步git commit之前，我们再运行*git status*看看当前仓库的状态：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n*git status*告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\n\n    $ git commit -m \"add distributed\"\n    [master ea34578] add distributed\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n提交后，我们再用*git status*命令看看仓库的当前状态：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.webm\" /></video>\n\n**小结**\n\n* 要随时掌握工作区的状态，使用git status命令。\n\n* 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n##版本回退\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n然后尝试提交：\n\n    $ git add readme.txt\n    $ git commit -m \"append GPL\"\n    [master 3628164] append GPL\n    1 file changed, 1 insertion(+), 1 deletion(-)\n\n像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n\n版本1：wrote a readme file\n\n    Git is a version control system.\n    Git is free software.\n\n版本2：add distributed\n\n    Git is a distributed version control system.\n    Git is free software.\n\n版本3：append GPL\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n\n    $ git log\n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n        append GPL\n\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    add distributed\n\n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n        wrote a readme file\n\n*git log*命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\n\n    $ git log --pretty=oneline\n    3628164fb26d48395383f8f31179f24e0882e1e0 append GPL\n    ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed\n    cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file\n\n需要友情提示的是，你看到的一大串类似“ 3628164...882e1e0”的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130518407)\n\n好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164...882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：\n\n    $ git reset --hard HEAD^\n    HEAD is now at ea34578 add distributed\n\n--hard参数有啥意义？这个后面再讲，现在你先放心使用。\n\n看看readme.txt的内容是不是版本“add distributed”：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software.\n\n果然。\n\n还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用*git log*再看看现在版本库的状态：\n\n    $ git log\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    \n        add distributed\n    \n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n    \n        wrote a readme file\n\n最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“3628164...”，于是就可以指定回到未来的某个版本：\n\n    $ git reset --hard 3628164\n    HEAD is now at 3628164 append GPL\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n再小心翼翼地看看readme.txt的内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n果然，我胡汉山又回来了。\n\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130538635)\n\n改为指向“add distributed”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130611271)\n\n然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.webm\" /></video>\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用*$ git reset --hard HEAD^*回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令*git reflog*用来记录你的每一次命令：\n\n    $ git reflog\n    ea34578 HEAD@{0}: reset: moving to HEAD^\n    3628164 HEAD@{1}: commit: append GPL\n    ea34578 HEAD@{2}: commit: add distributed\n    cb926e7 HEAD@{3}: commit (initial): wrote a readme file\n\n终于舒了口气，第二行显示“append GPL”的commit id是3628164，现在，你又可以乘坐时光机回到未来了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.webm\" /></video>\n\n**小结**\n\n现在总结一下：\n\n* HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令*git reset --hard commit\\_id*。\n\n* 穿梭前，用*git log*可以查看提交历史，以便确定要回退到哪个版本。\n\n* 要重返未来，用*git reflog*查看命令历史，以便确定要回到未来的哪个版本。\n\n##工作区和暂存区\n\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n先来看名词解释。\n\n**工作区**（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130631844)\n\n**版本库**（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130639967)\n\n分支和HEAD的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，commit就是往master分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n\n然后，在工作区新增一个LICENSE文本文件（内容随便写）。\n\n先用git status查看一下状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    # Untracked files:\n    #   (use \"git add <file>...\" to include in what will be committed)\n    #\n    #       LICENSE\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nGit非常清楚地告诉我们，*readme.txt*被修改了，而*LICENSE*还从来没有被添加过，所以它的状态是Untracked。\n\n现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   LICENSE\n    #       modified:   readme.txt\n    #\n\n现在，暂存区的状态就变成这样了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130652035)\n\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n\n    $ git commit -m \"understand how stage works\"\n    [master 27c9860] understand how stage works\n     2 files changed, 675 insertions(+)\n     create mode 100644 LICENSE\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130702566)\n\n**小结**\n\n暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n\n没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。\n\n##管理修改\n\n现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes.\n\n然后，添加：\n\n    $ git add readme.txt\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n然后，再修改readme.txt：\n\n    $ cat readme.txt \n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n提交：\n\n    $ git commit -m \"git tracks changes\"\n    [master d4f25b6] git tracks changes\n     1 file changed, 1 insertion(+)\n\n提交后，再看看状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n咦，怎么第二次的修改没有被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> git add -> 第二次修改 -> git commit\n\n你看，我们前面讲了，Git管理的是修改，当你用“git add”命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，“git commit”只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n提交后，用“git diff HEAD -- readme.txt”命令可以查看工作区和版本库里面最新版本的区别：\n\n    $ git diff HEAD -- readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 76d770f..a9c5755 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,4 +1,4 @@\n     Git is a distributed version control system.\n     Git is free software distributed under the GPL.\n     Git has a mutable index called stage.\n    -Git tracks changes.\n    +Git tracks changes of files.\n\n可见，第二次修改确实没有被提交。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.webm\" /></video>\n\n那怎么提交第二次修改呢？你可以继续add再commit，也可以别着急提交第一次修改，先add第二次修改，再commit，就相当于把两次修改合并后一块提交了：\n\n第一次修改 -> add -> 第二次修改 -> add -> commit\n\n好，现在，把第二次修改提交了，然后开始小结。\n\n**小结**\n\n现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。\n\n##撤销修改\n\n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n\n在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！\n\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用*git status*查看一下：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n你可以发现，Git会告诉你，*git checkout -- file*可以丢弃工作区的修改：\n\n    $ git checkout -- readme.txt\n\n命令*git checkout -- readme.txt*意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n现在，看看readme.txt的文件内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n文件内容果然复原了。\n\n*git checkout -- file*命令中的“--”很重要，没有“--”，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到*git checkout*命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.webm\" /></video>\n\n现在假定是凌晨3点，你不但写了一些胡话，还*git add*到暂存区了：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n    \n    $ git add readme.txt\n\n庆幸的是，在commit之前，你发现了这个问题。用*git status*查看一下，修改只是添加到了暂存区，还没有提交：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\nGit同样告诉我们，用命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n    $ git reset HEAD readme.txt\n    Unstaged changes after reset:\n    M       readme.txt\n\n*git reset*命令既可以回退版本，也可以把工作区的某些文件替换为版本库中的文件。当我们用HEAD时，表示最新的版本。\n\n再用*git status*查看一下，现在暂存区是干净的，工作区有修改：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n还记得如何丢弃工作区的修改吗？\n\n    $ git checkout -- readme.txt\n    \n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n整个世界终于清静了！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.webm\" /></video>\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退](file/时光机穿梭.md#anchor_1)一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……\n\n**小结**\n\n又到了小结时间。\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令*git checkout -- file*。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令*git reset HEAD file*，就回到了场景1，第二步按场景1操作。\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](file/时光机穿梭.md#anchor_1)一节，不过前提是没有推送到远程库。\n\n##删除文件\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n\n    $ git add test.txt\n    $ git commit -m \"add test.txt\"\n    [master 94cdc44] add test.txt\n     1 file changed, 1 insertion(+)\n     create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n\n    $ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，*git status*命令会立刻告诉你哪些文件被删除了：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add/rm <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       deleted:    test.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令*git rm*删掉，并且commit：\n\n    $ git rm test.txt\n    rm 'test.txt'\n    $ git commit -m \"remove test.txt\"\n    [master d17efd8] remove test.txt\n     1 file changed, 1 deletion(-)\n     delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.webm\" /></video>\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n    $ git checkout -- test.txt\n\n*git checkout*其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**小结**\n\n命令*git rm*用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n\n#远程仓库\n\n到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。\n\n可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。\n\n没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。\n\nGit是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。\n\n你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？\n\n其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。\n\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\n\n完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫[GitHub](https://github.com/)的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n\n在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id\\_rsa和id\\_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n    $ ssh-keygen -t rsa -C \"your\\_email@example.com\"\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.webm\" /></video>\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id\\_rsa和id\\_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id\\_rsa是私钥，不能泄露出去，id\\_rsa.pub是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id\\_rsa.pub文件的内容：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130738501)\n\n点“Add Key”，你就应该看到已经添加的Key：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130748040)\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n\n**小结**\n\n“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机\n\n##添加远程库\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130803583)\n\n在Repository name填入*learngit*，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130812619)\n\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n\n    $ git remote add origin git@github.com:michaelliao/learngit.git\n\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n\n添加后，远程库的名字就是*origin*，这是Git默认的叫法，也可以改成别的，但是*origin*这个名字一看就知道是远程库。\n\n下一步，就可以把本地库的所有内容推送到远程库上：\n\n    $ git push -u origin master\n    Counting objects: 19, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (19/19), done.\n    Writing objects: 100% (19/19), 13.73 KiB, done.\n    Total 23 (delta 6), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new branch]      master -> master\n    Branch master set up to track remote branch master from origin.\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.webm\" /></video>\n\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130830387)\n\n从现在起，只要本地作了提交，就可以通过命令：\n\n    $ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n**小结**\n\n要关联一个远程库，使用命令*git remote add origin git@server-name:path/repo-name.git*；\n\n关联后，使用命令*git push -u origin master*第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令*git push origin master*推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##从远程库克隆\n\n上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130842191)\n\n我们勾选*Initialize this repository with a README*，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130850414)\n\n现在，远程库已经准备好了，下一步是用命令*git clone*克隆一个本地库：\n\n    $ git clone git@github.com:michaelliao/gitskills.git\n    Cloning into 'gitskills'...\n    remote: Counting objects: 3, done.\n    remote: Total 3 (delta 0), reused 0 (delta 0)\n    Receiving objects: 100% (3/3), done.\n\n    $ cd gitskills\n    $ ls\n    README.md\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.webm\" /></video>\n\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用*https://github.com/michaelliao/gitskills.git*这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n**小结**\n\n要克隆一个仓库，首先必须知道仓库的地址，然后使用*git clone*命令克隆。\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n\n#分支管理\n\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\n\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。问题是，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130904432)\n\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。\n\n但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n##创建与合并分支\n\n在[版本回退](file/时光机穿梭.md#anchor_1)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130949931)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.webm\" /></video>\n\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130958401)\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131005897)\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131013034)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131034735)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.webm\" /></video>\n\n下面开始实战。\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n*git checkout*命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n    $ git branch dev\n    $ git checkout dev\n    Switched to branch 'dev'\n\n然后，用*git branch*命令查看当前分支：\n\n    $ git branch\n    * dev\n      master\n\n*git branch*命令会列出所有分支，当前分支前面会标一个\\*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\n\n    Creating a new branch is quick.\n\n然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"branch test\"\n    [dev fec145a] branch test\n     1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131104567)\n\n现在，我们把dev分支的工作成果合并到master分支上：\n\n    $ git merge dev\n    Updating d17efd8..fec145a\n    Fast-forward\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n*git merge*命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能*Fast-forward*，我们后面会将其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n\n    $ git branch -d dev\n    Deleted branch dev (was fec145a).\n\n删除后，查看branch，就只剩下master分支了：\n\n    $ git branch\n    * master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.webm\" /></video>\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：git branch\n\n创建分支：git branch *name*\n\n切换分支：git checkout *name*\n\n创建+切换分支：git checkout -b *name*\n\n合并某分支到当前分支：git merge *name*\n\n删除分支：git branch -d *name*\n\n##解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的feature1分支，继续我们的新分支开发：\n\n    $ git checkout -b feature1\n    Switched to a new branch 'feature1'\n\n修改readme.txt最后一行，改为：\n\n    Creating a new branch is quick AND simple.\n\n在feature1分支上提交：\n\n    $ git add readme.txt \n    $ git commit -m \"AND simple\"\n    [feature1 75a857c] AND simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n切换到master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 1 commit.\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n\n在master分支上把readme.txt文件的最后一行改为：\n\n    Creating a new branch is quick & simple.\n\n提交：\n\n    $ git add readme.txt \n    $ git commit -m \"& simple\"\n    [master 400b400] & simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131125396)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n    $ git merge feature1\n    Auto-merging readme.txt\n    CONFLICT (content): Merge conflict in readme.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。*git status*也可以告诉我们冲突的文件：\n\n    $ git status\n    # On branch master\n    # Your branch is ahead of 'origin/master' by 2 commits.\n    #\n    # Unmerged paths:\n    #   (use \"git add/rm <file>...\" as appropriate to mark resolution)\n    #\n    #       both modified:      readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n我们可以直接查看readme.txt的内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    <<<<<<< HEAD\n    Creating a new branch is quick & simple.\n    =======\n    Creating a new branch is quick AND simple.\n    >>>>>>> feature1\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：\n\n    Creating a new branch is quick and simple.\n\n再提交：\n\n    $ git add readme.txt \n    $ git commit -m \"conflict fixed\"\n    [master 59bc1cb] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131136505)\n\n用带参数的*git log*也可以看到分支的合并情况：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   59bc1cb conflict fixed\n    |\\\n    | * 75a857c AND simple\n    * | 400b400 & simple\n    |/\n    * fec145a branch test\n    ...\n\n现在，删除feature1分支：\n\n    $ git branch -d feature1\n    Deleted branch feature1 (was 75a857c).\n\n工作完成。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.webm\" /></video>\n\n**小结**\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n用*git log --graph*命令可以看到分支合并图。\n\n##分支管理策略\n\n通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下*--no-ff*方式的merge：\n\n首先，仍然创建并切换dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n修改readme.txt文件，并提交一个新的commit：\n\n    $ git add readme.txt \n    $ git commit -m \"add merge\"\n    [dev 6224937] add merge\n     1 file changed, 1 insertion(+)\n\n现在，我们切换会master：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n准备合并dev分支，请注意*--no-ff*参数，表示禁用“Fast forward”：\n\n    $ git merge --no-ff -m \"merge with no-ff\" dev\n    Merge made by the 'recursive' strategy.\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n因为本次合并要创建一个新的commit，所以加上*-m*参数，把commit描述写进去。\n\n合并后，我们用*git log*看看分支历史：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   7825a50 merge with no-ff\n    |\\\n    | * 6224937 add merge\n    |/\n    *   59bc1cb conflict fixed\n    ...\n\n可以看到，不使用“Fast forward”模式，merge后就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131151608)\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.webm\" /></video>\n\n### 分支策略\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131159864)\n\n**小结**\n\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上*--no-ff*参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而*fast forward*合并就看不出来曾经做过合并。\n\n##Bug分支\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n    $ git status\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n    $ git stash\n    Saved working directory and index state WIP on dev: 6224937 add merge\n    HEAD is now at 6224937 add merge\n\n现在，用*git status*查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 6 commits.\n    $ git checkout -b issue-101\n    Switched to a new branch 'issue-101'\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"fix bug 101\"\n    [issue-101 cc17032] fix bug 101\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 2 commits.\n    $ git merge --no-ff -m \"merged bug fix 101\" issue-101\n    Merge made by the 'recursive' strategy.\n     readme.txt |    2 +-\n     1 file changed, 1 insertion(+), 1 deletion(-)\n    $ git branch -d issue-101\n    Deleted branch issue-101 (was cc17032).\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n    $ git checkout dev\n    Switched to branch 'dev'\n    $ git status\n    # On branch dev\n    nothing to commit (working directory clean)\n\n工作区是干净的，刚才的工作现场存到哪去了？用*git stash list*命令看看：\n\n    $ git stash list\n    stash@{0}: WIP on dev: 6224937 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用*git stash apply*恢复，但是恢复后，stash内容并不删除，你需要用*git stash drop*来删除；\n\n另一种方式是用*git stash pop*，恢复的同时把stash内容也删了：\n\n    $ git stash pop\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)\n\n再用*git stash list*查看，就看不到任何stash内容了：\n\n    $ git stash list\n\n你可以多次stash，恢复的时候，先用*git stash list*查看，然后恢复指定的stash，用命令：\n\n    $ git stash apply stash@{0}\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.webm\" /></video>\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场*git stash*一下，然后去修复bug，修复后，再*git stash pop*，回到工作现场。\n\n##Feature分支\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n    $ git checkout -b feature-vulcan\n    Switched to a new branch 'feature-vulcan'\n\n5分钟后，开发完毕：\n\n    $ git status\n    # On branch feature-vulcan\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   vulcan.py\n    #\n    $ git commit -m \"add feature vulcan\"\n    [feature-vulcan 756d4af] add feature vulcan\n     1 file changed, 2 insertions(+)\n     create mode 100644 vulcan.py\n\n切回dev，准备合并：\n\n    $ git checkout dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是，\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个分支还是必须就地销毁：\n\n    $ git branch -d feature-vulcan\n    error: The branch 'feature-vulcan' is not fully merged.\n    If you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令*git branch -D feature-vulcan*。\n\n现在我们强行删除：\n\n    $ git branch -D feature-vulcan\n    Deleted branch feature-vulcan (was 756d4af).\n\n终于删除成功！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.webm\" /></video>\n\n**小结**\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过*git branch -D name*强行删除。\n\n##多人协作\n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用*git remote*：\n\n    $ git remote\n    origin\n\n或者，用*git remote -v*显示更详细的信息：\n\n    $ git remote -v\n    origin  git@github.com:michaelliao/learngit.git (fetch)\n    origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n    $ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n\n    $ git push origin dev\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n* master分支是主分支，因此要时刻与远程同步；\n\n* dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n* bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n* feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.webm\" /></video>\n\n### 抓取分支\n\n多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n    $ git clone git@github.com:michaelliao/learngit.git\n    Cloning into 'learngit'...\n    remote: Counting objects: 46, done.\n    remote: Compressing objects: 100% (26/26), done.\n    remote: Total 46 (delta 16), reused 45 (delta 15)\n    Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.\n    Resolving deltas: 100% (16/16), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用*git branch*命令看看：\n\n    $ git branch\n    * master\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n    $ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n    $ git commit -m \"add /usr/bin/env\"\n    [dev 291bea8] add /usr/bin/env\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    Counting objects: 5, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (2/2), done.\n    Writing objects: 100% (3/3), 349 bytes, done.\n    Total 3 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       fc38031..291bea8  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.webm\" /></video>\n\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n    $ git add hello.py \n    $ git commit -m \"add coding: utf-8\"\n    [dev bd6ae48] add coding: utf-8\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    To git@github.com:michaelliao/learngit.git\n     ! [rejected]        dev -> dev (non-fast-forward)\n    error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\n    hint: Updates were rejected because the tip of your current branch is behind\n    hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')\n    hint: before pushing again.\n    hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用*git pull*把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n    $ git pull\n    remote: Counting objects: 5, done.\n    remote: Compressing objects: 100% (2/2), done.\n    remote: Total 3 (delta 0), reused 3 (delta 0)\n    Unpacking objects: 100% (3/3), done.\n    From github.com:michaelliao/learngit\n       fc38031..291bea8  dev        -> origin/dev\n    There is no tracking information for the current branch.\n    Please specify which branch you want to merge with.\n    See git-pull(1) for details\n    \n        git pull <remote> <branch>\n    \n    If you wish to set tracking information for this branch you can do so with:\n    \n        git branch --set-upstream dev origin/<branch>\n\n*git pull*也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n    $ git branch --set-upstream dev origin/dev\n    Branch dev set up to track remote branch dev from origin.\n\n再pull：\n\n    $ git pull\n    Auto-merging hello.py\n    CONFLICT (content): Merge conflict in hello.py\n    Automatic merge failed; fix conflicts and then commit the result.\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000)完全一样。解决后，提交，再push：\n\n    $ git commit -m \"merge & fix hello.py\"\n    [dev adca45d] merge & fix hello.py\n    $ git push origin dev\n    Counting objects: 10, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (5/5), done.\n    Writing objects: 100% (6/6), 747 bytes, done.\n    Total 6 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       291bea8..adca45d  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.webm\" /></video>\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用*git push origin branch-name*推送自己的修改；\n\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用*git pull*试图合并；\n\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n\n4. 没有冲突或者解决掉冲突后，再用*git push origin branch-name*推送就能成功！\n\n如果*git pull*提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令*git branch --set-upstream branch-name origin/branch-name*。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n* 查看远程库信息，使用*git remote -v*；\n\n* 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n* 从本地推送分支，使用*git push origin branch-name*，如果推送失败，先用*git pull*抓取远程的新提交；\n\n* 在本地创建和远程分支对应的分支，使用*git checkout -b branch-name origin/branch-name*，本地和远程分支的名称最好一致；\n\n* 建立本地分支和远程分支的关联，使用*git branch --set-upstream branch-name origin/branch-name*；\n\n* 从远程抓取分支，使用*git pull*，如果有冲突，要先处理冲突。\n\n\n#标签管理\n\n发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\n\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\n\n##创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n\n    $ git branch\n    * dev\n      master\n    $ git checkout master\n    Switched to branch 'master'\n\n然后，敲命令*git tag name*就可以打一个新标签：\n\n    $ git tag v1.0\n\n可以用命令*git tag*查看所有标签：\n\n    $ git tag\n    v1.0\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n\n方法是找到历史提交的commit id，然后打上就可以了：\n\n    $ git log --pretty=oneline --abbrev-commit\n    6a5819e merged bug fix 101\n    cc17032 fix bug 101\n    7825a50 merge with no-ff\n    6224937 add merge\n    59bc1cb conflict fixed\n    400b400 & simple\n    75a857c AND simple\n    fec145a branch test\n    d17efd8 remove test.txt\n    ...\n\n比方说要对“add merge”这次提交打标签，它对应的commit id是“6224937”，敲入命令：\n\n    $ git tag v0.9 6224937\n\n再用命令*git tag*查看标签：\n\n    $ git tag\n    v0.9\n    v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用*git show tagname*查看标签信息：\n\n    $ git show v0.9\n    commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 11:22:08 2013 +0800\n    \n        add merge\n    ...\n\n可以看到，“v0.9”确实打在“add merge”这次提交上。\n\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n\n    $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n\n用命令*git show tagname*可以看到说明文字：\n\n    $ git show v0.1\n    tag v0.1\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:11 2013 +0800\n    \n    version 0.1 released\n    \n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n    \n        append GPL\n    ...\n\n还可以通过-s用私钥签名一个标签：\n\n    $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：\n\n    gpg: signing failed: secret key not available\n    error: gpg failed to sign the data\n    error: unable to sign the tag\n\n如果报错，请参考GnuPG帮助文档配置Key。\n\n用命令*git show tagname*可以看到PGP签名信息：\n\n    $ git show v0.2\n    tag v0.2\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:33 2013 +0800\n    \n    signed version 0.2 released\n    -----BEGIN PGP SIGNATURE-----\n    Version: GnuPG v1.4.12 (Darwin)\n    \n    iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...\n    -----END PGP SIGNATURE-----\n    \n    commit fec145accd63cdc9ed95a2f557ea0658a2a6537f\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 10:37:30 2013 +0800\n    \n        branch test\n    ...\n\n用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.webm\" /></video>\n\n**小结**\n\n* 命令*git tag name*用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n* -a tagname -m \"blablabla...\"可以指定标签信息；\n\n* -s tagname -m \"blablabla...\"可以用PGP签名标签；\n\n* 命令*git tag*可以查看所有标签；\n\n##操作标签\n\n如果标签打错了，也可以删除：\n\n    $ git tag -d v0.1\n    Deleted tag 'v0.1' (was e078af9)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n\n如果要推送某个标签到远程，使用命令git push origin tagname：\n\n    $ git push origin v1.0\n    Total 0 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v1.0 -> v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n    $ git push origin --tags\n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 554 bytes, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v0.2 -> v0.2\n     * [new tag]         v0.9 -> v0.9\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n    $ git tag -d v0.9\n    Deleted tag 'v0.9' (was 6224937)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n    $ git push origin :refs/tags/v0.9\n    To git@github.com:michaelliao/learngit.git\n     - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.webm\" /></video>\n\n**小结**\n\n* 命令*git push origin tagname*可以推送一个本地标签；\n\n* 命令*git push origin --tags*可以推送全部未推送过的本地标签；\n\n* 命令*git tag -d tagname*可以删除一个本地标签；\n\n* 命令*git push origin :refs/tags/tagname*可以删除一个远程标签。\n\n\n#自定义Git\n\n在[安装Git](file/git安装.md#anchor_0)一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。\n\n比如，让Git显示颜色，会让命令输出看起来更醒目：\n\n    $ git config --global color.ui true\n\n这样，Git会适当地显示不同的颜色，比如*git status*命令：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131228046)\n\n文件名就会标上颜色。\n\n我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。\n\n##忽略特殊文件\n\n有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次*git status*都会显示“Untracked files ...”，有强迫症的童鞋心里肯定不爽。\n\n好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的*.gitignore*文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n\n不需要从头写*.gitignore*文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：[https://github.com/github/gitignore](https://github.com/github/gitignore)\n\n忽略文件的原则是：\n\n1. 忽略操作系统自动生成的文件，比如缩略图等；\n2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的*.class*文件；\n3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n举个例子：\n\n假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有*Desktop.ini*文件，因此你需要忽略Windows自动生成的垃圾文件：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n\n然后，继续忽略Python编译产生的*.pyc*、*.pyo*、*dist*等文件或目录：\n\n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n\n加上你自己定义的文件，最终得到一个完整的*.gitignore*文件，内容如下：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n    \n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n    \n    # My configurations:\n    db.ini\n    deploy_key_rsa\n\n最后一步就是把*.gitignore*也提交到Git，就完成了！当然检验*.gitignore*的标准是*git status*命令是不是说“working directory clean”。\n\n**小结**\n\n1. 忽略某些文件时，需要编写*.gitignore*。\n2. *.gitignore*文件本身要放到版本库里，并且可以对*.gitignore*做版本管理！\n\n##配置别名\n\n有没有经常敲错命令？比如*git status*？*status*这个单词真心不好记。\n\n如果敲*git st*就表示*git status*那就简单多了，当然这种偷懒的办法我们是极力赞成的。\n\n我们只需要敲一行命令，告诉Git，以后*st*就表示*status*：\n\n    $ git config --global alias.st status\n\n好了，现在敲*git st*看看效果。\n\n当然还有别的命令可以简写，很多人都用*co*表示*checkout*，*ci*表示*commit*，*br*表示*branch*：\n\n    $ git config --global alias.co checkout\n    $ git config --global alias.ci commit\n    $ git config --global alias.br branch\n\n以后提交就可以简写成：\n\n    $ git ci -m \"bala bala bala...\"\n\n*--global*参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。\n\n在[撤销修改](file/时光机穿梭.md#anchor_4)一节中，我们知道，命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：\n\n    $ git config --global alias.unstage 'reset HEAD'\n\n当你敲入命令：\n\n    $ git unstage test.py\n\n实际上Git执行的是：\n\n    $ git reset HEAD test.py\n\n配置一个*git last*，让其显示最后一次提交信息：\n\n    $ git config --global alias.last 'log -1'\n\n这样，用*git last*就能显示最近一次的提交：\n\n    $ git last\n    commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2\n    Merge: bd6ae48 291bea8\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 22:49:22 2013 +0800\n    \n        merge & fix hello.py\n\n甚至还有人丧心病狂地把*lg*配置成了：\n\n    git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n\n来看看*git lg*的效果：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131238572)\n\n为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！\n\n**小结**\n\n给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。\n\n##搭建Git服务器\n\n在[远程仓库](file/远程仓库.md#anchor_0)一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。\n\nGitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。\n\n搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n\n假设你已经有sudo权限的用户账号，下面，正式开始安装。\n\n第一步，安装git：\n\n    $ sudo apt-get install git\n\n第二步，创建一个git用户，用来运行git服务：\n\n    $ sudo adduser git\n\n第三步，创建证书登录：\n\n收集所有需要登录的用户的公钥，就是他们自己的id\\_rsa.pub文件，把所有公钥导入到*/home/git/.ssh/authorized\\_keys*文件里，一行一个。\n\n第四步，初始化Git仓库：\n\n先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：\n\n    $ sudo git init --bare sample.git\n\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n\n    $ sudo chown -R git:git sample.git\n\n第五步，禁用shell登录：\n\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n\n    git:x:1001:1001:,,,:/home/git:/bin/bash\n\n改为：\n\n    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n\n第六步，克隆远程仓库：\n\n现在，可以通过*git clone*命令克隆远程仓库了，在各自的电脑上运行：\n\n    $ git clone git@server:/srv/sample.git\n    Cloning into 'sample'...\n    warning: You appear to have cloned an empty repository.\n\n剩下的推送就简单了。\n\n### 管理公钥\n\n如果团队很小，把每个人的公钥收集起来放到服务器的*/home/git/.ssh/authorized\\_keys*文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用[Gitosis](https://github.com/res0nat0r/gitosis)来管理公钥。\n\n这里我们不介绍怎么玩[Gitosis](https://github.com/res0nat0r/gitosis)了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。\n\n### 管理权限\n\n有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。[Gitolite](https://github.com/sitaramc/gitolite)就是这个工具。\n\n这里我们也不介绍[Gitolite](https://github.com/sitaramc/gitolite)了，不要把有限的生命浪费到权限斗争中。\n\n**小结**\n\n搭建Git服务器非常简单，通常10分钟即可完成；\n\n要方便管理公钥，用[Gitosis](https://github.com/sitaramc/gitolite)；\n\n要像SVN那样变态地控制权限，用[Gitolite](https://github.com/sitaramc/gitolite)。\n\n\n#期末总结\n\n终于到了期末总结的时刻了！\n\n经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。\n\nGit虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。\n\n友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：\n\n[Git Cheat Sheet](http://www.git-tower.com/blog/assets/2013-05-22-git-cheat-sheet/cheat-sheet-large01.png)\n\n现在告诉你Git的官方网站：[http://git-scm.com](http://git-scm.com)，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。\n\n如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。为了激励我写出更优秀的教程，你可以考虑赠送我一杯咖啡，至于是喝麦当劳还是星巴克就看你的心情了。有支付宝的童鞋请狠狠地点这里：\n\n<a href=\"https://me.alipay.com/askxuefeng\" target=\"_blank\" class=\"btn btn-success btn-large\" style=\"padding-left:60px;background-repeat:no-repeat;background-position:15px center;background-image:url(http://static.itranswarp.com/0013738742366844b31d0ceab84491682c4556f8daa5101000/attachment/2013/8/12/9d9043ba785d43ab8f4cffb04a4b1300.png)\">请我喝咖啡</a>\n\n谢谢观看！","source":"_posts/Git教程.md","raw":"---\ntitle: Git教程\ndate: 2015-12-12 13:13:00\ntags: [教程,版本控制]\ncategories: [互联网,转载]\n---\n#关于本教程\n![Git-Logo](http://img.blog.csdn.net/20151212130120447)\n\n##史上最浅显易懂的Git教程！\n\n为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。\n\n既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？\n\n首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度；\n\n其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。\n\n##文字+图片还看不明白？有视频！！！\n\n本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。\n\n如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！\n\n##关于作者\n\n<a href=\"http://weibo.com/liaoxuefeng\">廖雪峰</a>，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在[GitHub](https://github.com/michaelliao)，欢迎微博交流：\n\n<a href=\"http://weibo.com/u/1658384301?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/1658384301/078cedea/2.png\"/></a>\n\n\n#Git简介\n\nGit是什么？\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。\n\nGit有什么特点？简单来说就是：高端大气上档次！\n\n那什么是版本控制系统？\n\n如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：\n\n想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130221073)\n\n过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。\n\n看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。\n\n更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。\n\n于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？\n\n这个软件用起来就应该像这个样子，能记录每次文件的改动：\n\n<table class=\"table table-bordered\">\n<tr><th>版本</th><th>用户</th><th>说明</th><th>日期</th></tr>\n<tr><td>1</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr>\n<tr><td>2</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr>\n<tr><td>3</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr>\n<tr><td>4</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr>\n</table>\n\n这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。\n\n##Git的诞生\n\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\n\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\n\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\n\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\n\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n\n##集中式vs分布式\n\nLinus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？\n\n先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130245660)\n\n集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。\n\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130259965)\n\n当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。\n\nCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n\n\n#安装Git\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n\n要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：\n\n## 在Linux上安装Git\n\n首先，你可以试着输入git，看看系统有没有安装Git：\n\n    $ git\n    The program 'git' is currently not installed. You can install it by typing:\n    sudo apt-get install git\n\n像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。\n\n如果你碰巧用Debian或Ubuntu Linux，通过一条“sudo apt-get install git”就可以直接完成Git的安装，非常简单。\n\n<video width=\"638\" height=\"478\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.webm\" /></video>\n\n老一点的Debian或Ubuntu Linux，要把命令改为“sudo apt-get install git-core”，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。\n\n如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。\n\n## 在Mac OS X上安装Git\n\n如果你正在使用Mac做开发，有两种安装Git的方法。\n\n一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：[http://brew.sh/](http://brew.sh/)。\n\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130320870)\n\nXcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！\n\n## 在Windows上安装Git\n\n实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。\n\nWindows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。\n\nmsysgit是Windows版的Git，从[http://msysgit.github.io/](http://msysgit.github.io/)下载，然后按默认选项安装即可。\n\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130331785)\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n    $ git config --global user.name \"Your Name\"\n    $ git config --global user.email \"email@example.com\"\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意*git config*命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n\n#创建版本库\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n    $ mkdir learngit\n    $ cd learngit\n    $ pwd\n    /Users/michael/learngit\n\npwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。\n\n<i class=\"icon-warning-sign\"></i> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\n\n    $ git init\n    Initialized empty Git repository in /Users/michael/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.webm\" /></video>\n\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n\n## 把文件添加到版本库\n\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n<i class=\"icon-warning-sign\"></i> 使用Windows的童鞋要特别注意，千万不要使用Windows自带的**记事本**编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载[Notepad++](http://notepad-plus-plus.org/)代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130355971)\n\n言归正传，现在我们编写一个readme.txt文件，内容如下：\n\n    Git is a version control system.\n    Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n第一步，用命令*git add*告诉Git，把文件添加到仓库：\n\n    $ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n\n第二步，用命令*git commit*告诉Git，把文件提交到仓库：\n\n    $ git commit -m \"wrote a readme file\"\n    [master (root-commit) cb926e7] wrote a readme file\n     1 file changed, 2 insertions(+)\n     create mode 100644 readme.txt\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.webm\" /></video>\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\n嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。\n\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。\n\n为什么Git添加文件需要*add*，*commit*一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n    $ git add file1.txt\n    $ git add file2.txt\n    $ git add file3.txt\n    $ git commit -m \"add 3 files.\"\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n* 第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；\n\n* 第二步，使用命令git commit，完成。\n\n\n#时光机穿梭\n\n我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：\n\n    Git is a distributed version control system.\n    Git is free software.\n\n现在，运行*git status*命令看看结果：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #\tmodified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n*git status*命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用*git diff*这个命令看看：\n\n    $ git diff readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 46d49bf..9247db6 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,2 +1,2 @@\n    -Git is a version control system.\n    +Git is a distributed version control system.\n     Git is free software.\n\n*git diff*顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。\n\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\n\n    $ git add readme.txt\n\n同样没有任何输出。在执行第二步git commit之前，我们再运行*git status*看看当前仓库的状态：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n*git status*告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\n\n    $ git commit -m \"add distributed\"\n    [master ea34578] add distributed\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n提交后，我们再用*git status*命令看看仓库的当前状态：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.webm\" /></video>\n\n**小结**\n\n* 要随时掌握工作区的状态，使用git status命令。\n\n* 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n##版本回退\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n然后尝试提交：\n\n    $ git add readme.txt\n    $ git commit -m \"append GPL\"\n    [master 3628164] append GPL\n    1 file changed, 1 insertion(+), 1 deletion(-)\n\n像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n\n版本1：wrote a readme file\n\n    Git is a version control system.\n    Git is free software.\n\n版本2：add distributed\n\n    Git is a distributed version control system.\n    Git is free software.\n\n版本3：append GPL\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n\n    $ git log\n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n        append GPL\n\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    add distributed\n\n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n        wrote a readme file\n\n*git log*命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\n\n    $ git log --pretty=oneline\n    3628164fb26d48395383f8f31179f24e0882e1e0 append GPL\n    ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed\n    cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file\n\n需要友情提示的是，你看到的一大串类似“ 3628164...882e1e0”的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130518407)\n\n好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164...882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：\n\n    $ git reset --hard HEAD^\n    HEAD is now at ea34578 add distributed\n\n--hard参数有啥意义？这个后面再讲，现在你先放心使用。\n\n看看readme.txt的内容是不是版本“add distributed”：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software.\n\n果然。\n\n还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用*git log*再看看现在版本库的状态：\n\n    $ git log\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    \n        add distributed\n    \n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n    \n        wrote a readme file\n\n最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“3628164...”，于是就可以指定回到未来的某个版本：\n\n    $ git reset --hard 3628164\n    HEAD is now at 3628164 append GPL\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n再小心翼翼地看看readme.txt的内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n果然，我胡汉山又回来了。\n\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130538635)\n\n改为指向“add distributed”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130611271)\n\n然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.webm\" /></video>\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用*$ git reset --hard HEAD^*回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令*git reflog*用来记录你的每一次命令：\n\n    $ git reflog\n    ea34578 HEAD@{0}: reset: moving to HEAD^\n    3628164 HEAD@{1}: commit: append GPL\n    ea34578 HEAD@{2}: commit: add distributed\n    cb926e7 HEAD@{3}: commit (initial): wrote a readme file\n\n终于舒了口气，第二行显示“append GPL”的commit id是3628164，现在，你又可以乘坐时光机回到未来了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.webm\" /></video>\n\n**小结**\n\n现在总结一下：\n\n* HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令*git reset --hard commit\\_id*。\n\n* 穿梭前，用*git log*可以查看提交历史，以便确定要回退到哪个版本。\n\n* 要重返未来，用*git reflog*查看命令历史，以便确定要回到未来的哪个版本。\n\n##工作区和暂存区\n\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n先来看名词解释。\n\n**工作区**（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130631844)\n\n**版本库**（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130639967)\n\n分支和HEAD的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，commit就是往master分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n\n然后，在工作区新增一个LICENSE文本文件（内容随便写）。\n\n先用git status查看一下状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    # Untracked files:\n    #   (use \"git add <file>...\" to include in what will be committed)\n    #\n    #       LICENSE\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nGit非常清楚地告诉我们，*readme.txt*被修改了，而*LICENSE*还从来没有被添加过，所以它的状态是Untracked。\n\n现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   LICENSE\n    #       modified:   readme.txt\n    #\n\n现在，暂存区的状态就变成这样了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130652035)\n\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n\n    $ git commit -m \"understand how stage works\"\n    [master 27c9860] understand how stage works\n     2 files changed, 675 insertions(+)\n     create mode 100644 LICENSE\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130702566)\n\n**小结**\n\n暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n\n没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。\n\n##管理修改\n\n现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes.\n\n然后，添加：\n\n    $ git add readme.txt\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n然后，再修改readme.txt：\n\n    $ cat readme.txt \n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n提交：\n\n    $ git commit -m \"git tracks changes\"\n    [master d4f25b6] git tracks changes\n     1 file changed, 1 insertion(+)\n\n提交后，再看看状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n咦，怎么第二次的修改没有被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> git add -> 第二次修改 -> git commit\n\n你看，我们前面讲了，Git管理的是修改，当你用“git add”命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，“git commit”只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n提交后，用“git diff HEAD -- readme.txt”命令可以查看工作区和版本库里面最新版本的区别：\n\n    $ git diff HEAD -- readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 76d770f..a9c5755 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,4 +1,4 @@\n     Git is a distributed version control system.\n     Git is free software distributed under the GPL.\n     Git has a mutable index called stage.\n    -Git tracks changes.\n    +Git tracks changes of files.\n\n可见，第二次修改确实没有被提交。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.webm\" /></video>\n\n那怎么提交第二次修改呢？你可以继续add再commit，也可以别着急提交第一次修改，先add第二次修改，再commit，就相当于把两次修改合并后一块提交了：\n\n第一次修改 -> add -> 第二次修改 -> add -> commit\n\n好，现在，把第二次修改提交了，然后开始小结。\n\n**小结**\n\n现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。\n\n##撤销修改\n\n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n\n在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！\n\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用*git status*查看一下：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n你可以发现，Git会告诉你，*git checkout -- file*可以丢弃工作区的修改：\n\n    $ git checkout -- readme.txt\n\n命令*git checkout -- readme.txt*意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n现在，看看readme.txt的文件内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n文件内容果然复原了。\n\n*git checkout -- file*命令中的“--”很重要，没有“--”，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到*git checkout*命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.webm\" /></video>\n\n现在假定是凌晨3点，你不但写了一些胡话，还*git add*到暂存区了：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n    \n    $ git add readme.txt\n\n庆幸的是，在commit之前，你发现了这个问题。用*git status*查看一下，修改只是添加到了暂存区，还没有提交：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\nGit同样告诉我们，用命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n    $ git reset HEAD readme.txt\n    Unstaged changes after reset:\n    M       readme.txt\n\n*git reset*命令既可以回退版本，也可以把工作区的某些文件替换为版本库中的文件。当我们用HEAD时，表示最新的版本。\n\n再用*git status*查看一下，现在暂存区是干净的，工作区有修改：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n还记得如何丢弃工作区的修改吗？\n\n    $ git checkout -- readme.txt\n    \n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n整个世界终于清静了！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.webm\" /></video>\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退](file/时光机穿梭.md#anchor_1)一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……\n\n**小结**\n\n又到了小结时间。\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令*git checkout -- file*。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令*git reset HEAD file*，就回到了场景1，第二步按场景1操作。\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](file/时光机穿梭.md#anchor_1)一节，不过前提是没有推送到远程库。\n\n##删除文件\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n\n    $ git add test.txt\n    $ git commit -m \"add test.txt\"\n    [master 94cdc44] add test.txt\n     1 file changed, 1 insertion(+)\n     create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n\n    $ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，*git status*命令会立刻告诉你哪些文件被删除了：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add/rm <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       deleted:    test.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令*git rm*删掉，并且commit：\n\n    $ git rm test.txt\n    rm 'test.txt'\n    $ git commit -m \"remove test.txt\"\n    [master d17efd8] remove test.txt\n     1 file changed, 1 deletion(-)\n     delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.webm\" /></video>\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n    $ git checkout -- test.txt\n\n*git checkout*其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**小结**\n\n命令*git rm*用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n\n#远程仓库\n\n到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。\n\n可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。\n\n没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。\n\nGit是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。\n\n你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？\n\n其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。\n\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\n\n完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫[GitHub](https://github.com/)的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n\n在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id\\_rsa和id\\_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n    $ ssh-keygen -t rsa -C \"your\\_email@example.com\"\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.webm\" /></video>\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id\\_rsa和id\\_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id\\_rsa是私钥，不能泄露出去，id\\_rsa.pub是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id\\_rsa.pub文件的内容：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130738501)\n\n点“Add Key”，你就应该看到已经添加的Key：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130748040)\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n\n**小结**\n\n“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机\n\n##添加远程库\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130803583)\n\n在Repository name填入*learngit*，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130812619)\n\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n\n    $ git remote add origin git@github.com:michaelliao/learngit.git\n\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n\n添加后，远程库的名字就是*origin*，这是Git默认的叫法，也可以改成别的，但是*origin*这个名字一看就知道是远程库。\n\n下一步，就可以把本地库的所有内容推送到远程库上：\n\n    $ git push -u origin master\n    Counting objects: 19, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (19/19), done.\n    Writing objects: 100% (19/19), 13.73 KiB, done.\n    Total 23 (delta 6), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new branch]      master -> master\n    Branch master set up to track remote branch master from origin.\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.webm\" /></video>\n\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130830387)\n\n从现在起，只要本地作了提交，就可以通过命令：\n\n    $ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n**小结**\n\n要关联一个远程库，使用命令*git remote add origin git@server-name:path/repo-name.git*；\n\n关联后，使用命令*git push -u origin master*第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令*git push origin master*推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##从远程库克隆\n\n上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130842191)\n\n我们勾选*Initialize this repository with a README*，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130850414)\n\n现在，远程库已经准备好了，下一步是用命令*git clone*克隆一个本地库：\n\n    $ git clone git@github.com:michaelliao/gitskills.git\n    Cloning into 'gitskills'...\n    remote: Counting objects: 3, done.\n    remote: Total 3 (delta 0), reused 0 (delta 0)\n    Receiving objects: 100% (3/3), done.\n\n    $ cd gitskills\n    $ ls\n    README.md\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.webm\" /></video>\n\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用*https://github.com/michaelliao/gitskills.git*这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n**小结**\n\n要克隆一个仓库，首先必须知道仓库的地址，然后使用*git clone*命令克隆。\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n\n#分支管理\n\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\n\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。问题是，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130904432)\n\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。\n\n但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n##创建与合并分支\n\n在[版本回退](file/时光机穿梭.md#anchor_1)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130949931)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.webm\" /></video>\n\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130958401)\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131005897)\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131013034)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131034735)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.webm\" /></video>\n\n下面开始实战。\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n*git checkout*命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n    $ git branch dev\n    $ git checkout dev\n    Switched to branch 'dev'\n\n然后，用*git branch*命令查看当前分支：\n\n    $ git branch\n    * dev\n      master\n\n*git branch*命令会列出所有分支，当前分支前面会标一个\\*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\n\n    Creating a new branch is quick.\n\n然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"branch test\"\n    [dev fec145a] branch test\n     1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131104567)\n\n现在，我们把dev分支的工作成果合并到master分支上：\n\n    $ git merge dev\n    Updating d17efd8..fec145a\n    Fast-forward\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n*git merge*命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能*Fast-forward*，我们后面会将其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n\n    $ git branch -d dev\n    Deleted branch dev (was fec145a).\n\n删除后，查看branch，就只剩下master分支了：\n\n    $ git branch\n    * master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.webm\" /></video>\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：git branch\n\n创建分支：git branch *name*\n\n切换分支：git checkout *name*\n\n创建+切换分支：git checkout -b *name*\n\n合并某分支到当前分支：git merge *name*\n\n删除分支：git branch -d *name*\n\n##解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的feature1分支，继续我们的新分支开发：\n\n    $ git checkout -b feature1\n    Switched to a new branch 'feature1'\n\n修改readme.txt最后一行，改为：\n\n    Creating a new branch is quick AND simple.\n\n在feature1分支上提交：\n\n    $ git add readme.txt \n    $ git commit -m \"AND simple\"\n    [feature1 75a857c] AND simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n切换到master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 1 commit.\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n\n在master分支上把readme.txt文件的最后一行改为：\n\n    Creating a new branch is quick & simple.\n\n提交：\n\n    $ git add readme.txt \n    $ git commit -m \"& simple\"\n    [master 400b400] & simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131125396)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n    $ git merge feature1\n    Auto-merging readme.txt\n    CONFLICT (content): Merge conflict in readme.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。*git status*也可以告诉我们冲突的文件：\n\n    $ git status\n    # On branch master\n    # Your branch is ahead of 'origin/master' by 2 commits.\n    #\n    # Unmerged paths:\n    #   (use \"git add/rm <file>...\" as appropriate to mark resolution)\n    #\n    #       both modified:      readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n我们可以直接查看readme.txt的内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    <<<<<<< HEAD\n    Creating a new branch is quick & simple.\n    =======\n    Creating a new branch is quick AND simple.\n    >>>>>>> feature1\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：\n\n    Creating a new branch is quick and simple.\n\n再提交：\n\n    $ git add readme.txt \n    $ git commit -m \"conflict fixed\"\n    [master 59bc1cb] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131136505)\n\n用带参数的*git log*也可以看到分支的合并情况：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   59bc1cb conflict fixed\n    |\\\n    | * 75a857c AND simple\n    * | 400b400 & simple\n    |/\n    * fec145a branch test\n    ...\n\n现在，删除feature1分支：\n\n    $ git branch -d feature1\n    Deleted branch feature1 (was 75a857c).\n\n工作完成。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.webm\" /></video>\n\n**小结**\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n用*git log --graph*命令可以看到分支合并图。\n\n##分支管理策略\n\n通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下*--no-ff*方式的merge：\n\n首先，仍然创建并切换dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n修改readme.txt文件，并提交一个新的commit：\n\n    $ git add readme.txt \n    $ git commit -m \"add merge\"\n    [dev 6224937] add merge\n     1 file changed, 1 insertion(+)\n\n现在，我们切换会master：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n准备合并dev分支，请注意*--no-ff*参数，表示禁用“Fast forward”：\n\n    $ git merge --no-ff -m \"merge with no-ff\" dev\n    Merge made by the 'recursive' strategy.\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n因为本次合并要创建一个新的commit，所以加上*-m*参数，把commit描述写进去。\n\n合并后，我们用*git log*看看分支历史：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   7825a50 merge with no-ff\n    |\\\n    | * 6224937 add merge\n    |/\n    *   59bc1cb conflict fixed\n    ...\n\n可以看到，不使用“Fast forward”模式，merge后就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131151608)\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.webm\" /></video>\n\n### 分支策略\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131159864)\n\n**小结**\n\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上*--no-ff*参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而*fast forward*合并就看不出来曾经做过合并。\n\n##Bug分支\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n    $ git status\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n    $ git stash\n    Saved working directory and index state WIP on dev: 6224937 add merge\n    HEAD is now at 6224937 add merge\n\n现在，用*git status*查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 6 commits.\n    $ git checkout -b issue-101\n    Switched to a new branch 'issue-101'\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"fix bug 101\"\n    [issue-101 cc17032] fix bug 101\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 2 commits.\n    $ git merge --no-ff -m \"merged bug fix 101\" issue-101\n    Merge made by the 'recursive' strategy.\n     readme.txt |    2 +-\n     1 file changed, 1 insertion(+), 1 deletion(-)\n    $ git branch -d issue-101\n    Deleted branch issue-101 (was cc17032).\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n    $ git checkout dev\n    Switched to branch 'dev'\n    $ git status\n    # On branch dev\n    nothing to commit (working directory clean)\n\n工作区是干净的，刚才的工作现场存到哪去了？用*git stash list*命令看看：\n\n    $ git stash list\n    stash@{0}: WIP on dev: 6224937 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用*git stash apply*恢复，但是恢复后，stash内容并不删除，你需要用*git stash drop*来删除；\n\n另一种方式是用*git stash pop*，恢复的同时把stash内容也删了：\n\n    $ git stash pop\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)\n\n再用*git stash list*查看，就看不到任何stash内容了：\n\n    $ git stash list\n\n你可以多次stash，恢复的时候，先用*git stash list*查看，然后恢复指定的stash，用命令：\n\n    $ git stash apply stash@{0}\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.webm\" /></video>\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场*git stash*一下，然后去修复bug，修复后，再*git stash pop*，回到工作现场。\n\n##Feature分支\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n    $ git checkout -b feature-vulcan\n    Switched to a new branch 'feature-vulcan'\n\n5分钟后，开发完毕：\n\n    $ git status\n    # On branch feature-vulcan\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   vulcan.py\n    #\n    $ git commit -m \"add feature vulcan\"\n    [feature-vulcan 756d4af] add feature vulcan\n     1 file changed, 2 insertions(+)\n     create mode 100644 vulcan.py\n\n切回dev，准备合并：\n\n    $ git checkout dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是，\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个分支还是必须就地销毁：\n\n    $ git branch -d feature-vulcan\n    error: The branch 'feature-vulcan' is not fully merged.\n    If you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令*git branch -D feature-vulcan*。\n\n现在我们强行删除：\n\n    $ git branch -D feature-vulcan\n    Deleted branch feature-vulcan (was 756d4af).\n\n终于删除成功！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.webm\" /></video>\n\n**小结**\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过*git branch -D name*强行删除。\n\n##多人协作\n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用*git remote*：\n\n    $ git remote\n    origin\n\n或者，用*git remote -v*显示更详细的信息：\n\n    $ git remote -v\n    origin  git@github.com:michaelliao/learngit.git (fetch)\n    origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n    $ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n\n    $ git push origin dev\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n* master分支是主分支，因此要时刻与远程同步；\n\n* dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n* bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n* feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.webm\" /></video>\n\n### 抓取分支\n\n多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n    $ git clone git@github.com:michaelliao/learngit.git\n    Cloning into 'learngit'...\n    remote: Counting objects: 46, done.\n    remote: Compressing objects: 100% (26/26), done.\n    remote: Total 46 (delta 16), reused 45 (delta 15)\n    Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.\n    Resolving deltas: 100% (16/16), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用*git branch*命令看看：\n\n    $ git branch\n    * master\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n    $ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n    $ git commit -m \"add /usr/bin/env\"\n    [dev 291bea8] add /usr/bin/env\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    Counting objects: 5, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (2/2), done.\n    Writing objects: 100% (3/3), 349 bytes, done.\n    Total 3 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       fc38031..291bea8  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.webm\" /></video>\n\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n    $ git add hello.py \n    $ git commit -m \"add coding: utf-8\"\n    [dev bd6ae48] add coding: utf-8\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    To git@github.com:michaelliao/learngit.git\n     ! [rejected]        dev -> dev (non-fast-forward)\n    error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\n    hint: Updates were rejected because the tip of your current branch is behind\n    hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')\n    hint: before pushing again.\n    hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用*git pull*把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n    $ git pull\n    remote: Counting objects: 5, done.\n    remote: Compressing objects: 100% (2/2), done.\n    remote: Total 3 (delta 0), reused 3 (delta 0)\n    Unpacking objects: 100% (3/3), done.\n    From github.com:michaelliao/learngit\n       fc38031..291bea8  dev        -> origin/dev\n    There is no tracking information for the current branch.\n    Please specify which branch you want to merge with.\n    See git-pull(1) for details\n    \n        git pull <remote> <branch>\n    \n    If you wish to set tracking information for this branch you can do so with:\n    \n        git branch --set-upstream dev origin/<branch>\n\n*git pull*也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n    $ git branch --set-upstream dev origin/dev\n    Branch dev set up to track remote branch dev from origin.\n\n再pull：\n\n    $ git pull\n    Auto-merging hello.py\n    CONFLICT (content): Merge conflict in hello.py\n    Automatic merge failed; fix conflicts and then commit the result.\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000)完全一样。解决后，提交，再push：\n\n    $ git commit -m \"merge & fix hello.py\"\n    [dev adca45d] merge & fix hello.py\n    $ git push origin dev\n    Counting objects: 10, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (5/5), done.\n    Writing objects: 100% (6/6), 747 bytes, done.\n    Total 6 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       291bea8..adca45d  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.webm\" /></video>\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用*git push origin branch-name*推送自己的修改；\n\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用*git pull*试图合并；\n\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n\n4. 没有冲突或者解决掉冲突后，再用*git push origin branch-name*推送就能成功！\n\n如果*git pull*提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令*git branch --set-upstream branch-name origin/branch-name*。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n* 查看远程库信息，使用*git remote -v*；\n\n* 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n* 从本地推送分支，使用*git push origin branch-name*，如果推送失败，先用*git pull*抓取远程的新提交；\n\n* 在本地创建和远程分支对应的分支，使用*git checkout -b branch-name origin/branch-name*，本地和远程分支的名称最好一致；\n\n* 建立本地分支和远程分支的关联，使用*git branch --set-upstream branch-name origin/branch-name*；\n\n* 从远程抓取分支，使用*git pull*，如果有冲突，要先处理冲突。\n\n\n#标签管理\n\n发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\n\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\n\n##创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n\n    $ git branch\n    * dev\n      master\n    $ git checkout master\n    Switched to branch 'master'\n\n然后，敲命令*git tag name*就可以打一个新标签：\n\n    $ git tag v1.0\n\n可以用命令*git tag*查看所有标签：\n\n    $ git tag\n    v1.0\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n\n方法是找到历史提交的commit id，然后打上就可以了：\n\n    $ git log --pretty=oneline --abbrev-commit\n    6a5819e merged bug fix 101\n    cc17032 fix bug 101\n    7825a50 merge with no-ff\n    6224937 add merge\n    59bc1cb conflict fixed\n    400b400 & simple\n    75a857c AND simple\n    fec145a branch test\n    d17efd8 remove test.txt\n    ...\n\n比方说要对“add merge”这次提交打标签，它对应的commit id是“6224937”，敲入命令：\n\n    $ git tag v0.9 6224937\n\n再用命令*git tag*查看标签：\n\n    $ git tag\n    v0.9\n    v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用*git show tagname*查看标签信息：\n\n    $ git show v0.9\n    commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 11:22:08 2013 +0800\n    \n        add merge\n    ...\n\n可以看到，“v0.9”确实打在“add merge”这次提交上。\n\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n\n    $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n\n用命令*git show tagname*可以看到说明文字：\n\n    $ git show v0.1\n    tag v0.1\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:11 2013 +0800\n    \n    version 0.1 released\n    \n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n    \n        append GPL\n    ...\n\n还可以通过-s用私钥签名一个标签：\n\n    $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：\n\n    gpg: signing failed: secret key not available\n    error: gpg failed to sign the data\n    error: unable to sign the tag\n\n如果报错，请参考GnuPG帮助文档配置Key。\n\n用命令*git show tagname*可以看到PGP签名信息：\n\n    $ git show v0.2\n    tag v0.2\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:33 2013 +0800\n    \n    signed version 0.2 released\n    -----BEGIN PGP SIGNATURE-----\n    Version: GnuPG v1.4.12 (Darwin)\n    \n    iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...\n    -----END PGP SIGNATURE-----\n    \n    commit fec145accd63cdc9ed95a2f557ea0658a2a6537f\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 10:37:30 2013 +0800\n    \n        branch test\n    ...\n\n用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.webm\" /></video>\n\n**小结**\n\n* 命令*git tag name*用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n* -a tagname -m \"blablabla...\"可以指定标签信息；\n\n* -s tagname -m \"blablabla...\"可以用PGP签名标签；\n\n* 命令*git tag*可以查看所有标签；\n\n##操作标签\n\n如果标签打错了，也可以删除：\n\n    $ git tag -d v0.1\n    Deleted tag 'v0.1' (was e078af9)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n\n如果要推送某个标签到远程，使用命令git push origin tagname：\n\n    $ git push origin v1.0\n    Total 0 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v1.0 -> v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n    $ git push origin --tags\n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 554 bytes, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v0.2 -> v0.2\n     * [new tag]         v0.9 -> v0.9\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n    $ git tag -d v0.9\n    Deleted tag 'v0.9' (was 6224937)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n    $ git push origin :refs/tags/v0.9\n    To git@github.com:michaelliao/learngit.git\n     - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.webm\" /></video>\n\n**小结**\n\n* 命令*git push origin tagname*可以推送一个本地标签；\n\n* 命令*git push origin --tags*可以推送全部未推送过的本地标签；\n\n* 命令*git tag -d tagname*可以删除一个本地标签；\n\n* 命令*git push origin :refs/tags/tagname*可以删除一个远程标签。\n\n\n#自定义Git\n\n在[安装Git](file/git安装.md#anchor_0)一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。\n\n比如，让Git显示颜色，会让命令输出看起来更醒目：\n\n    $ git config --global color.ui true\n\n这样，Git会适当地显示不同的颜色，比如*git status*命令：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131228046)\n\n文件名就会标上颜色。\n\n我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。\n\n##忽略特殊文件\n\n有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次*git status*都会显示“Untracked files ...”，有强迫症的童鞋心里肯定不爽。\n\n好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的*.gitignore*文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n\n不需要从头写*.gitignore*文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：[https://github.com/github/gitignore](https://github.com/github/gitignore)\n\n忽略文件的原则是：\n\n1. 忽略操作系统自动生成的文件，比如缩略图等；\n2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的*.class*文件；\n3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n举个例子：\n\n假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有*Desktop.ini*文件，因此你需要忽略Windows自动生成的垃圾文件：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n\n然后，继续忽略Python编译产生的*.pyc*、*.pyo*、*dist*等文件或目录：\n\n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n\n加上你自己定义的文件，最终得到一个完整的*.gitignore*文件，内容如下：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n    \n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n    \n    # My configurations:\n    db.ini\n    deploy_key_rsa\n\n最后一步就是把*.gitignore*也提交到Git，就完成了！当然检验*.gitignore*的标准是*git status*命令是不是说“working directory clean”。\n\n**小结**\n\n1. 忽略某些文件时，需要编写*.gitignore*。\n2. *.gitignore*文件本身要放到版本库里，并且可以对*.gitignore*做版本管理！\n\n##配置别名\n\n有没有经常敲错命令？比如*git status*？*status*这个单词真心不好记。\n\n如果敲*git st*就表示*git status*那就简单多了，当然这种偷懒的办法我们是极力赞成的。\n\n我们只需要敲一行命令，告诉Git，以后*st*就表示*status*：\n\n    $ git config --global alias.st status\n\n好了，现在敲*git st*看看效果。\n\n当然还有别的命令可以简写，很多人都用*co*表示*checkout*，*ci*表示*commit*，*br*表示*branch*：\n\n    $ git config --global alias.co checkout\n    $ git config --global alias.ci commit\n    $ git config --global alias.br branch\n\n以后提交就可以简写成：\n\n    $ git ci -m \"bala bala bala...\"\n\n*--global*参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。\n\n在[撤销修改](file/时光机穿梭.md#anchor_4)一节中，我们知道，命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：\n\n    $ git config --global alias.unstage 'reset HEAD'\n\n当你敲入命令：\n\n    $ git unstage test.py\n\n实际上Git执行的是：\n\n    $ git reset HEAD test.py\n\n配置一个*git last*，让其显示最后一次提交信息：\n\n    $ git config --global alias.last 'log -1'\n\n这样，用*git last*就能显示最近一次的提交：\n\n    $ git last\n    commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2\n    Merge: bd6ae48 291bea8\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 22:49:22 2013 +0800\n    \n        merge & fix hello.py\n\n甚至还有人丧心病狂地把*lg*配置成了：\n\n    git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n\n来看看*git lg*的效果：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131238572)\n\n为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！\n\n**小结**\n\n给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。\n\n##搭建Git服务器\n\n在[远程仓库](file/远程仓库.md#anchor_0)一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。\n\nGitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。\n\n搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n\n假设你已经有sudo权限的用户账号，下面，正式开始安装。\n\n第一步，安装git：\n\n    $ sudo apt-get install git\n\n第二步，创建一个git用户，用来运行git服务：\n\n    $ sudo adduser git\n\n第三步，创建证书登录：\n\n收集所有需要登录的用户的公钥，就是他们自己的id\\_rsa.pub文件，把所有公钥导入到*/home/git/.ssh/authorized\\_keys*文件里，一行一个。\n\n第四步，初始化Git仓库：\n\n先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：\n\n    $ sudo git init --bare sample.git\n\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n\n    $ sudo chown -R git:git sample.git\n\n第五步，禁用shell登录：\n\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n\n    git:x:1001:1001:,,,:/home/git:/bin/bash\n\n改为：\n\n    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n\n第六步，克隆远程仓库：\n\n现在，可以通过*git clone*命令克隆远程仓库了，在各自的电脑上运行：\n\n    $ git clone git@server:/srv/sample.git\n    Cloning into 'sample'...\n    warning: You appear to have cloned an empty repository.\n\n剩下的推送就简单了。\n\n### 管理公钥\n\n如果团队很小，把每个人的公钥收集起来放到服务器的*/home/git/.ssh/authorized\\_keys*文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用[Gitosis](https://github.com/res0nat0r/gitosis)来管理公钥。\n\n这里我们不介绍怎么玩[Gitosis](https://github.com/res0nat0r/gitosis)了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。\n\n### 管理权限\n\n有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。[Gitolite](https://github.com/sitaramc/gitolite)就是这个工具。\n\n这里我们也不介绍[Gitolite](https://github.com/sitaramc/gitolite)了，不要把有限的生命浪费到权限斗争中。\n\n**小结**\n\n搭建Git服务器非常简单，通常10分钟即可完成；\n\n要方便管理公钥，用[Gitosis](https://github.com/sitaramc/gitolite)；\n\n要像SVN那样变态地控制权限，用[Gitolite](https://github.com/sitaramc/gitolite)。\n\n\n#期末总结\n\n终于到了期末总结的时刻了！\n\n经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。\n\nGit虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。\n\n友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：\n\n[Git Cheat Sheet](http://www.git-tower.com/blog/assets/2013-05-22-git-cheat-sheet/cheat-sheet-large01.png)\n\n现在告诉你Git的官方网站：[http://git-scm.com](http://git-scm.com)，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。\n\n如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。为了激励我写出更优秀的教程，你可以考虑赠送我一杯咖啡，至于是喝麦当劳还是星巴克就看你的心情了。有支付宝的童鞋请狠狠地点这里：\n\n<a href=\"https://me.alipay.com/askxuefeng\" target=\"_blank\" class=\"btn btn-success btn-large\" style=\"padding-left:60px;background-repeat:no-repeat;background-position:15px center;background-image:url(http://static.itranswarp.com/0013738742366844b31d0ceab84491682c4556f8daa5101000/attachment/2013/8/12/9d9043ba785d43ab8f4cffb04a4b1300.png)\">请我喝咖啡</a>\n\n谢谢观看！","slug":"Git教程","published":1,"updated":"2016-01-26T13:55:36.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhas9h003sdcoqzib3tf5w","sticky":0},{"title":"Github资源整理","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2015/02/24/Github%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/Github资源整理.md","raw":"---\ntitle: Github资源整理\ntags:\n  - 工具\ncategories:\n  - 互联网\n  - 转载\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2015/02/24/Github%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/\"><title></title></head><body></body></html>\n转载文章","slug":"Github资源整理","published":1,"date":"2016-01-26T13:55:36.877Z","updated":"2016-01-26T13:55:36.877Z","layout":"post","photos":[],"link":"","_id":"cijvhas9t003zdcoq3onsmu4h","sticky":0},{"title":"Git-简明指南","date":"2015-12-20T09:17:11.000Z","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://arccode.net/2015/02/28/Git-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/Git-简明指南.md","raw":"title: Git-简明指南\ntags:\n  - 教程\n  - 版本控制\ncategories:\n  - 互联网\n  - 转载\ndate: 2015-12-20 17:17:11\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://arccode.net/2015/02/28/Git-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/\"><title></title></head><body></body></html>\n转载文章","slug":"Git-简明指南","published":1,"updated":"2016-01-26T13:55:36.834Z","layout":"post","photos":[],"link":"","_id":"cijvhasa00043dcoqmopy0sdi","sticky":0},{"title":"Find the Path","date":"2015-08-17T01:41:00.000Z","_content":"Description\n--\nScofield刚从监狱里面跑出来，现在他要在进行大逃亡.\n\n你也知道, 逃亡是非常不容易的, 现在Scofield遇到了一些困难, 你可以帮助他吗?\n\nScofield面前的是一个美国的交通图, 图里面有一些城市, 有些城市之间有路连接. 路的长度scofield是知道的, 但是有些城市里面的警察很多, 所以scofield对这个问题很头疼. 他现在要安排一些逃亡路线, 所以他要对你做一些询问, 询问是这样的:某两个城市之间的最短路是什么? 但是这个最短路有个前提, 那就是路径上的每个城市里的警察不得超过k个. 起点和终点除外.\n\nInput\n--\n有多组测试数据, 数据第一行是一个整数T表示测试数据的个数。每组测试数据以二个整数N，M 开始。N是城市个数，M是道路数。\n下面一行有n个数, 表示每个城市里面的警察的个数Ci.\n再下面m行, 每行有三个数, u, v, w.\n再下面有一个整数Q\n下面有Q行, 每行三个整数u, v, k表示,查询的内容为从u到v的警察数不超过k的最短路.(u, v上的警察不用计算在内).\n\nTechnical Specification\n1. T <= 20\n2. 2 <= N <= 200, 0 <= M <= n * (n – 1) / 2\n3. 0 <= Ci <= 1000,000,000\n4. 0 <= u, v < N, 0 <= w <= 1000, 0 <= k <= 1000,000,000\n5. 0<= Q <= 100000\n6. 没有多重边和自环边\n7. 对于每一个询问，u！= v。\n8. 输入数据后面有一个空行。\n\nOutput\n--\n对于每一个询问，输出一行，表示最短路是什么，如果不存在的话就输出-1.\n每一个测试数据后面加一个空行。\n\nSample Input\n--\n```\n1\n4 4\n100 2 3 100\n0 1 1\n0 2 1\n1 3 2\n2 3 3\n2\n0 3 2\n0 3 1\n```\nSample Output \n--\n```\n3\n-1\n```\nAnalysis\n--\n这题是要我们求最短路，但是最短路有一定的要求，就是最短路上的警察要不超过k个。再看看数据范围，N非常的小，组数也不多。再求最短路的诸多算法中，floyd算法虽然慢，但是他在处理一些特殊问题(带条件)时却能发挥它的重要作用。\n我们都知道floyd算法，是通过枚举中间点，进而求出最短路。在枚举中间点的时候，未枚举到的中间点，并不在所求的最短路内。所以根据这个特性，我们就可以再求最短路的同时，进而保证警察数k在一个范围内，然后在回答每一个问题。\n实现起来可能略微复杂，首先我们将原先图上的点进行重编号。按照点的警察数从小到大排序，顺次编号。现在对于图上编号为i的点，在[1..i-1]中的点他们的警察数k都比i点的警察数k小。在对新图做一次floyd最短路。对于后面的每个询问，将询问的<u,v>转化为新图的<u,v>。再从满足警察数<=k个中选出一个最小的答案，作为此次询问的答案。整道题的算法复杂度为O((N^3+QN)*T)。其实复杂度还是蛮高的。\n\nCode\n--\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long LL;\nconst long long INF = 1042521604759584125;\nconst int N = 200+10;\nLL map[N][N][N];\nint pos[N];\n\nstruct node\n{\n\tint num,id;\n\tbool operator < (node a) const\n\t{\n\t\treturn num < a.num;\n\t}\n}cos[N];\n\nint main()\n{\n\t//freopen(\"1061.in\",\"r\",stdin);\n\t\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T --)\n\t{\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i = 0 ; i < n ; i ++)\n\t\t{\n\t\t\tscanf(\"%d\",&cos[i].num);\n\t\t\tcos[i].id = i;\n\t\t}\n\t\tsort(cos,cos + n);\n\t\tfor (int i = 0 ; i < n ; i ++)\\\n\t\t{\n\t\t\tpos[cos[i].id] = i+1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tmap[i][j][0]=INF;\n\t\tfor (int i = 1 ; i <= m ; i ++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tmap[pos[x]][pos[y]][0] = z;\n\t\t\tmap[pos[y]][pos[x]][0] = z;\n\t\t}\n\t\tfor (int k = 1;k <= n; k ++)\n\t\t{\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = map[i][j][k - 1];\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = min(map[i][j][k],map[i][k][k-1]+map[k][j][k-1]);\n\t\t\t\n\t\t}\n\t\tint Q;\n\t\tscanf(\"%d\",&Q);\n\t\twhile (Q --)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tLL ans = map[pos[x]][pos[y]][0];\n\t\t\tfor (int i = n-1 ; i >= 0; i --)\n\t\t\t{\n\t\t\t\tif (cos[i].num <= z) {\n\t\t\t\t\tans = map[pos[x]][pos[y]][i+1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == INF) puts(\"-1\"); else printf(\"%lld\\n\",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\t\t\n\treturn 0;\n}\n```","source":"_posts/Find-the-Path.md","raw":"---\ntitle: Find the Path\ndate: 2015-08-17 09:41:00\ntags:\n  - 题解\n  - floyd算法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\nScofield刚从监狱里面跑出来，现在他要在进行大逃亡.\n\n你也知道, 逃亡是非常不容易的, 现在Scofield遇到了一些困难, 你可以帮助他吗?\n\nScofield面前的是一个美国的交通图, 图里面有一些城市, 有些城市之间有路连接. 路的长度scofield是知道的, 但是有些城市里面的警察很多, 所以scofield对这个问题很头疼. 他现在要安排一些逃亡路线, 所以他要对你做一些询问, 询问是这样的:某两个城市之间的最短路是什么? 但是这个最短路有个前提, 那就是路径上的每个城市里的警察不得超过k个. 起点和终点除外.\n\nInput\n--\n有多组测试数据, 数据第一行是一个整数T表示测试数据的个数。每组测试数据以二个整数N，M 开始。N是城市个数，M是道路数。\n下面一行有n个数, 表示每个城市里面的警察的个数Ci.\n再下面m行, 每行有三个数, u, v, w.\n再下面有一个整数Q\n下面有Q行, 每行三个整数u, v, k表示,查询的内容为从u到v的警察数不超过k的最短路.(u, v上的警察不用计算在内).\n\nTechnical Specification\n1. T <= 20\n2. 2 <= N <= 200, 0 <= M <= n * (n – 1) / 2\n3. 0 <= Ci <= 1000,000,000\n4. 0 <= u, v < N, 0 <= w <= 1000, 0 <= k <= 1000,000,000\n5. 0<= Q <= 100000\n6. 没有多重边和自环边\n7. 对于每一个询问，u！= v。\n8. 输入数据后面有一个空行。\n\nOutput\n--\n对于每一个询问，输出一行，表示最短路是什么，如果不存在的话就输出-1.\n每一个测试数据后面加一个空行。\n\nSample Input\n--\n```\n1\n4 4\n100 2 3 100\n0 1 1\n0 2 1\n1 3 2\n2 3 3\n2\n0 3 2\n0 3 1\n```\nSample Output \n--\n```\n3\n-1\n```\nAnalysis\n--\n这题是要我们求最短路，但是最短路有一定的要求，就是最短路上的警察要不超过k个。再看看数据范围，N非常的小，组数也不多。再求最短路的诸多算法中，floyd算法虽然慢，但是他在处理一些特殊问题(带条件)时却能发挥它的重要作用。\n我们都知道floyd算法，是通过枚举中间点，进而求出最短路。在枚举中间点的时候，未枚举到的中间点，并不在所求的最短路内。所以根据这个特性，我们就可以再求最短路的同时，进而保证警察数k在一个范围内，然后在回答每一个问题。\n实现起来可能略微复杂，首先我们将原先图上的点进行重编号。按照点的警察数从小到大排序，顺次编号。现在对于图上编号为i的点，在[1..i-1]中的点他们的警察数k都比i点的警察数k小。在对新图做一次floyd最短路。对于后面的每个询问，将询问的<u,v>转化为新图的<u,v>。再从满足警察数<=k个中选出一个最小的答案，作为此次询问的答案。整道题的算法复杂度为O((N^3+QN)*T)。其实复杂度还是蛮高的。\n\nCode\n--\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long LL;\nconst long long INF = 1042521604759584125;\nconst int N = 200+10;\nLL map[N][N][N];\nint pos[N];\n\nstruct node\n{\n\tint num,id;\n\tbool operator < (node a) const\n\t{\n\t\treturn num < a.num;\n\t}\n}cos[N];\n\nint main()\n{\n\t//freopen(\"1061.in\",\"r\",stdin);\n\t\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T --)\n\t{\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i = 0 ; i < n ; i ++)\n\t\t{\n\t\t\tscanf(\"%d\",&cos[i].num);\n\t\t\tcos[i].id = i;\n\t\t}\n\t\tsort(cos,cos + n);\n\t\tfor (int i = 0 ; i < n ; i ++)\\\n\t\t{\n\t\t\tpos[cos[i].id] = i+1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tmap[i][j][0]=INF;\n\t\tfor (int i = 1 ; i <= m ; i ++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tmap[pos[x]][pos[y]][0] = z;\n\t\t\tmap[pos[y]][pos[x]][0] = z;\n\t\t}\n\t\tfor (int k = 1;k <= n; k ++)\n\t\t{\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = map[i][j][k - 1];\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = min(map[i][j][k],map[i][k][k-1]+map[k][j][k-1]);\n\t\t\t\n\t\t}\n\t\tint Q;\n\t\tscanf(\"%d\",&Q);\n\t\twhile (Q --)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tLL ans = map[pos[x]][pos[y]][0];\n\t\t\tfor (int i = n-1 ; i >= 0; i --)\n\t\t\t{\n\t\t\t\tif (cos[i].num <= z) {\n\t\t\t\t\tans = map[pos[x]][pos[y]][i+1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == INF) puts(\"-1\"); else printf(\"%lld\\n\",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\t\t\n\treturn 0;\n}\n```","slug":"Find-the-Path","published":1,"updated":"2016-01-26T13:55:36.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhasa50048dcoq5emmih0g","sticky":0},{"title":"Debian 7 安装教程","date":"2015-10-28T00:03:00.000Z","_content":"First you should download the file of Debian 7 64 bit\n\n\nset source\n--\n```\n#vim /etc/apt/sources.list\n```\nEnter the following information\n```\ndeb http://mirrors.163.com/debian wheezy main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy main non-free contrib\n\n\ndeb http://mirrors.163.com/debian wheezy-updates main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy-updates main non-free contrib\n\n\ndeb http://security.debian.org/ wheezy/updates main\ndeb-src http://security.debian.org/ wheezy/updates main\n\n#apt-get update\n```\n\ninstall some software\n--\nOpen Terminal\ninput order\n```\n$su root\n#apt-get install vim\n#apt-get install gcc\n#apt-get install g++\n#apt-get install sudo\n#apt-get install fpc\n```\n\nTo solve the Chinese garbled\n--\n```\n$su\n#apt-get install ttf-arphic-uming\n#apt-get install ttf-wqy-zenhei\n#aptitude install locales\n#dpkg-reconfigure locales\n```\nchoose something\n```\nen_US.UTF8\nzh_CN GB2312\nzh_CN GBK GBK\nzh_CN UTF-8 UTF-8\n```\nchoose zh_CN UTF-8  \n```\n#vi /etc/default/locale\nLANG=en_US.UTF-8\n```\n\n安装中文输入法\n--\n```\n# apt-get install fcitx\n```\n创建脚本以便X Window启动时自动载入fcitx: \n```\n# cd /etc/X11/Xsession.d  \n# vi 25xchinput_start\n```\n输入以下内容并保存： \n```\nexport XMODIFIERS=@im=fcitx        \nexport XIM=fcitx        \nexport XIM_PROGRAM=fcitx        \n/usr/bin/fcitx &\n```\n在配置中激活输入法\nfcitx翻页按钮=向下-向上\n\n安装vmware tools\n```\ntar zxvf ***.tar.gz\n#sudo apt-get install make\n#sudo apt-get install gcc\n#sudo aptitude install linux-headers-`uname -r`\n```\n在root下运行vmware-install.pl\n\n\n查看windows共享文件\n--\n```\n#apt-get install samba\n```\n首先，下载samba；\n接着，Alt+F2,\nsmb://windows的IP/共享目录\n假设windows的ip是10.2.11.2.100, 共享目录是share和本地磁盘(E)\n于是\nsmb://10.2.112.100/share\nsmb://10.2.112.100/本地磁盘(E)\n即可直接访问。\n\n\n解压deb包\n--\ndpkg命令常用格式如下：\ndpkg -I iptux.deb#查看iptux.deb软件包的详细信息，\ndpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构\ndpkg -i iptux.deb#安装iptux.deb软件包\ndpkg -l iptux#查看iptux软件包的信息\ndpkg -L iptux#查看iptux软件包安装的所有文件\ndpkg -s iptux#查看iptux软件包的详细信息\ndpkg -r iptux#卸载iptux软件包\n注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。\ndpkg -l | grep qq\n用这个命令组合着出来了，列出已经安装的软件，并且包含qq关键字的。。\n再用-r卸载\n\n\ntar.gz文件解压\n--","source":"_posts/Debian-7-安装教程.md","raw":"---\ntitle: Debian 7 安装教程\ndate: 2015-10-28 08:03:00\ntags:\n  - 教程\ncategories:\n  - 互联网\n  - 原创\n---\nFirst you should download the file of Debian 7 64 bit\n\n\nset source\n--\n```\n#vim /etc/apt/sources.list\n```\nEnter the following information\n```\ndeb http://mirrors.163.com/debian wheezy main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy main non-free contrib\n\n\ndeb http://mirrors.163.com/debian wheezy-updates main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy-updates main non-free contrib\n\n\ndeb http://security.debian.org/ wheezy/updates main\ndeb-src http://security.debian.org/ wheezy/updates main\n\n#apt-get update\n```\n\ninstall some software\n--\nOpen Terminal\ninput order\n```\n$su root\n#apt-get install vim\n#apt-get install gcc\n#apt-get install g++\n#apt-get install sudo\n#apt-get install fpc\n```\n\nTo solve the Chinese garbled\n--\n```\n$su\n#apt-get install ttf-arphic-uming\n#apt-get install ttf-wqy-zenhei\n#aptitude install locales\n#dpkg-reconfigure locales\n```\nchoose something\n```\nen_US.UTF8\nzh_CN GB2312\nzh_CN GBK GBK\nzh_CN UTF-8 UTF-8\n```\nchoose zh_CN UTF-8  \n```\n#vi /etc/default/locale\nLANG=en_US.UTF-8\n```\n\n安装中文输入法\n--\n```\n# apt-get install fcitx\n```\n创建脚本以便X Window启动时自动载入fcitx: \n```\n# cd /etc/X11/Xsession.d  \n# vi 25xchinput_start\n```\n输入以下内容并保存： \n```\nexport XMODIFIERS=@im=fcitx        \nexport XIM=fcitx        \nexport XIM_PROGRAM=fcitx        \n/usr/bin/fcitx &\n```\n在配置中激活输入法\nfcitx翻页按钮=向下-向上\n\n安装vmware tools\n```\ntar zxvf ***.tar.gz\n#sudo apt-get install make\n#sudo apt-get install gcc\n#sudo aptitude install linux-headers-`uname -r`\n```\n在root下运行vmware-install.pl\n\n\n查看windows共享文件\n--\n```\n#apt-get install samba\n```\n首先，下载samba；\n接着，Alt+F2,\nsmb://windows的IP/共享目录\n假设windows的ip是10.2.11.2.100, 共享目录是share和本地磁盘(E)\n于是\nsmb://10.2.112.100/share\nsmb://10.2.112.100/本地磁盘(E)\n即可直接访问。\n\n\n解压deb包\n--\ndpkg命令常用格式如下：\ndpkg -I iptux.deb#查看iptux.deb软件包的详细信息，\ndpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构\ndpkg -i iptux.deb#安装iptux.deb软件包\ndpkg -l iptux#查看iptux软件包的信息\ndpkg -L iptux#查看iptux软件包安装的所有文件\ndpkg -s iptux#查看iptux软件包的详细信息\ndpkg -r iptux#卸载iptux软件包\n注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。\ndpkg -l | grep qq\n用这个命令组合着出来了，列出已经安装的软件，并且包含qq关键字的。。\n再用-r卸载\n\n\ntar.gz文件解压\n--","slug":"Debian-7-安装教程","published":1,"updated":"2016-01-26T13:55:36.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvhasaa004edcoq7r7986r1","sticky":0},{"title":"AC自动机算法详解","comments":0,"_content":"<a href=\"http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\"><title></title></head><body></body></html>\n\n","source":"_posts/AC自动机算法详解.md","raw":"---\ntitle: AC自动机算法详解\ntags:\n  - AC自动机\ncategories:\n  - 信息学\n  - 转载\ncomments: false\n---\n<a href=\"http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\"><title></title></head><body></body></html>\n\n","slug":"AC自动机算法详解","published":1,"date":"2016-01-26T13:55:36.823Z","updated":"2016-01-26T13:55:36.823Z","layout":"post","photos":[],"link":"","_id":"cijvhasah004jdcoqjzn7nn5t","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cijvhas1v0000dcoqyr8b8low","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas2c0005dcoqbdjiezob"},{"post_id":"cijvhas1v0000dcoqyr8b8low","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas2c0006dcoq025y3ogr"},{"post_id":"cijvhas3n000adcoqhk03ioac","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas3p000bdcoqz5mnkbp2"},{"post_id":"cijvhas3n000adcoqhk03ioac","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas3q000ddcoqains4e0u"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas3x000idcoqznmbojg7"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas3y000kdcoqd8jalit6"},{"post_id":"cijvhas59000rdcoq1znvvh4n","category_id":"cijvhas5b000sdcoqvuy0ezme","_id":"cijvhas5d000wdcoqdacqv1fc"},{"post_id":"cijvhas59000rdcoq1znvvh4n","category_id":"cijvhas5c000udcoqdf7slen8","_id":"cijvhas5d000xdcoqj1whcxrt"},{"post_id":"cijvhas5f000ydcoqy9r317tc","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas5h000zdcoqn6bv5gwx"},{"post_id":"cijvhas5f000ydcoqy9r317tc","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas5h0011dcoqdh1awc1g"},{"post_id":"cijvhas5k0013dcoqztgq56fe","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas5m0014dcoqsid3u01u"},{"post_id":"cijvhas5k0013dcoqztgq56fe","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas5m0016dcoqe3user8v"},{"post_id":"cijvhas5t0018dcoq6edrw589","category_id":"cijvhas5v0019dcoqa9eketut","_id":"cijvhas61001ddcoq6c95efsi"},{"post_id":"cijvhas5t0018dcoq6edrw589","category_id":"cijvhas5x001bdcoqffuxyt0a","_id":"cijvhas61001edcoq72p0bu8c"},{"post_id":"cijvhas64001fdcoqmmjpub9z","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas67001jdcoqpbq1o6sj"},{"post_id":"cijvhas64001fdcoqmmjpub9z","category_id":"cijvhas66001gdcoqwawgfc7e","_id":"cijvhas68001kdcoqnef0ulhm"},{"post_id":"cijvhas69001ldcoq4z2wepy6","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas6b001mdcoqlg10d4of"},{"post_id":"cijvhas69001ldcoq4z2wepy6","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas6d001odcoq3dgsxawq"},{"post_id":"cijvhas6g001pdcoq7fgo74jv","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas6h001qdcoq4wj90j1v"},{"post_id":"cijvhas6g001pdcoq7fgo74jv","category_id":"cijvhas66001gdcoqwawgfc7e","_id":"cijvhas6h001rdcoqz2ijyh1g"},{"post_id":"cijvhas6j001sdcoqg1i1h3mt","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas6m001tdcoqra2ce0x8"},{"post_id":"cijvhas6j001sdcoqg1i1h3mt","category_id":"cijvhas66001gdcoqwawgfc7e","_id":"cijvhas6n001udcoqgw9e4gtq"},{"post_id":"cijvhas6r001vdcoqdec341w9","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas6s001wdcoqms7eqo2v"},{"post_id":"cijvhas6r001vdcoqdec341w9","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas6t001ydcoqff4z96i8"},{"post_id":"cijvhas6v0020dcoqhhcrtohx","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas6x0021dcoqxa0s0z93"},{"post_id":"cijvhas6v0020dcoqhhcrtohx","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas6y0023dcoq1h93u4an"},{"post_id":"cijvhas700024dcoqmb79c901","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas720025dcoq98idw5y4"},{"post_id":"cijvhas700024dcoqmb79c901","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas730027dcoqdzn8x2r3"},{"post_id":"cijvhas740028dcoqnxcn7c5a","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas750029dcoqwn8mx816"},{"post_id":"cijvhas740028dcoqnxcn7c5a","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas77002bdcoq84nbc7f0"},{"post_id":"cijvhas79002cdcoq500rh27n","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas7c002ddcoqv52sgd31"},{"post_id":"cijvhas79002cdcoq500rh27n","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas7c002fdcoqsdbbd6gl"},{"post_id":"cijvhas7e002gdcoqsrludg9l","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas7h002hdcoq9chr78gz"},{"post_id":"cijvhas7e002gdcoqsrludg9l","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas7i002jdcoq62w7fgqu"},{"post_id":"cijvhas7k002kdcoqdwm8ofu9","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas7m002ldcoqagt88vco"},{"post_id":"cijvhas7k002kdcoqdwm8ofu9","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas7o002ndcoqqmwul4zi"},{"post_id":"cijvhas7p002odcoqxvn8nw4g","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas7q002pdcoq5hyzd9mi"},{"post_id":"cijvhas7p002odcoqxvn8nw4g","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas7r002rdcoqdmk6q9dg"},{"post_id":"cijvhas7s002sdcoq0tpufamn","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas7u002tdcoqc2jk8n31"},{"post_id":"cijvhas7s002sdcoq0tpufamn","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas7v002vdcoqx5x0ms59"},{"post_id":"cijvhas83002xdcoqc5jth5jt","category_id":"cijvhas5b000sdcoqvuy0ezme","_id":"cijvhas84002ydcoqewx8sywi"},{"post_id":"cijvhas83002xdcoqc5jth5jt","category_id":"cijvhas5c000udcoqdf7slen8","_id":"cijvhas850030dcoqts81tkfq"},{"post_id":"cijvhas860031dcoqmb1v4v4r","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas880032dcoqlic5h7gc"},{"post_id":"cijvhas860031dcoqmb1v4v4r","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas890034dcoqxcyin2hh"},{"post_id":"cijvhas8e0039dcoqnhctjysp","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas8h003adcoq3emhvdky"},{"post_id":"cijvhas8e0039dcoqnhctjysp","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas8i003cdcoq8jq1xgtv"},{"post_id":"cijvhas8j003ddcoqi78wy4vj","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas8l003edcoq4c0gnfco"},{"post_id":"cijvhas8j003ddcoqi78wy4vj","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas8l003gdcoqgocl2ys7"},{"post_id":"cijvhas8n003hdcoqh8767jnp","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas8r003idcoqee0cg143"},{"post_id":"cijvhas8n003hdcoqh8767jnp","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas8t003jdcoqthpljqwe"},{"post_id":"cijvhas8w003kdcoq3e0km6wb","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas91003ldcoq5sb0ys0z"},{"post_id":"cijvhas8w003kdcoq3e0km6wb","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas92003ndcoquan3yp1l"},{"post_id":"cijvhas95003odcoqtx3dqbw1","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhas96003pdcoq34ytnw2i"},{"post_id":"cijvhas95003odcoqtx3dqbw1","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhas97003rdcoqvbau60xk"},{"post_id":"cijvhas9h003sdcoqzib3tf5w","category_id":"cijvhas5v0019dcoqa9eketut","_id":"cijvhas9i003tdcoq7gtgvjjh"},{"post_id":"cijvhas9h003sdcoqzib3tf5w","category_id":"cijvhas5x001bdcoqffuxyt0a","_id":"cijvhas9j003vdcoqoir2syuk"},{"post_id":"cijvhas9t003zdcoq3onsmu4h","category_id":"cijvhas5v0019dcoqa9eketut","_id":"cijvhas9v0040dcoqf9te81yy"},{"post_id":"cijvhas9t003zdcoq3onsmu4h","category_id":"cijvhas5x001bdcoqffuxyt0a","_id":"cijvhas9x0042dcoq5zzv0zp0"},{"post_id":"cijvhasa00043dcoqmopy0sdi","category_id":"cijvhas5v0019dcoqa9eketut","_id":"cijvhasa10044dcoqottnp3y2"},{"post_id":"cijvhasa00043dcoqmopy0sdi","category_id":"cijvhas5x001bdcoqffuxyt0a","_id":"cijvhasa20046dcoq4eks2b88"},{"post_id":"cijvhasa50048dcoq5emmih0g","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhasa60049dcoqn2si1daz"},{"post_id":"cijvhasa50048dcoq5emmih0g","category_id":"cijvhas290003dcoqnthzbcdc","_id":"cijvhasa7004bdcoqraeg3t8x"},{"post_id":"cijvhasaa004edcoq7r7986r1","category_id":"cijvhas5v0019dcoqa9eketut","_id":"cijvhasae004hdcoqgj5u19j4"},{"post_id":"cijvhasaa004edcoq7r7986r1","category_id":"cijvhasad004fdcoqdydo3wqh","_id":"cijvhasaf004idcoqfyitofmz"},{"post_id":"cijvhasah004jdcoqjzn7nn5t","category_id":"cijvhas250001dcoqkxtp7lt7","_id":"cijvhasak004kdcoqf3578nz5"},{"post_id":"cijvhasah004jdcoqjzn7nn5t","category_id":"cijvhas66001gdcoqwawgfc7e","_id":"cijvhasal004mdcoqhir95zre"}],"PostTag":[{"post_id":"cijvhas1v0000dcoqyr8b8low","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas2a0004dcoqbrgn57rv"},{"post_id":"cijvhas3n000adcoqhk03ioac","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas3q000fdcoq7tul82hl"},{"post_id":"cijvhas3n000adcoqhk03ioac","tag_id":"cijvhas3q000edcoq990zzieh","_id":"cijvhas3q000gdcoq8ksjzwqo"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas40000ndcoqtho41c3d"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","tag_id":"cijvhas3y000jdcoqswx3gstb","_id":"cijvhas4c000odcoq15uq5lo3"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","tag_id":"cijvhas3y000ldcoq57l5n0ox","_id":"cijvhas4c000pdcoqd6v54l3w"},{"post_id":"cijvhas3v000hdcoqo65lnh2y","tag_id":"cijvhas3z000mdcoqrvmpl3wc","_id":"cijvhas4c000qdcoq1l1ogwhh"},{"post_id":"cijvhas59000rdcoq1znvvh4n","tag_id":"cijvhas5b000tdcoqbzdxhsk7","_id":"cijvhas5d000vdcoq3hawaqof"},{"post_id":"cijvhas5f000ydcoqy9r317tc","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas5h0010dcoqi8tegv23"},{"post_id":"cijvhas5f000ydcoqy9r317tc","tag_id":"cijvhas3q000edcoq990zzieh","_id":"cijvhas5h0012dcoq95c4r49t"},{"post_id":"cijvhas5k0013dcoqztgq56fe","tag_id":"cijvhas5m0015dcoqocm5kij1","_id":"cijvhas5n0017dcoqtmsi8rpg"},{"post_id":"cijvhas5t0018dcoq6edrw589","tag_id":"cijvhas5w001adcoqu0su0y0m","_id":"cijvhas5x001cdcoqqo151n8p"},{"post_id":"cijvhas64001fdcoqmmjpub9z","tag_id":"cijvhas67001hdcoqb5rjdfof","_id":"cijvhas67001idcoqvdlg02cm"},{"post_id":"cijvhas69001ldcoq4z2wepy6","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas6c001ndcoqzhhqlayi"},{"post_id":"cijvhas6r001vdcoqdec341w9","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas6t001xdcoqs1tbq4a8"},{"post_id":"cijvhas6r001vdcoqdec341w9","tag_id":"cijvhas3y000jdcoqswx3gstb","_id":"cijvhas6t001zdcoq4ps4xv77"},{"post_id":"cijvhas6v0020dcoqhhcrtohx","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas6y0022dcoqie8itdcz"},{"post_id":"cijvhas700024dcoqmb79c901","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas720026dcoqhhv6ypyd"},{"post_id":"cijvhas740028dcoqnxcn7c5a","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas76002adcoq9h1cmmv3"},{"post_id":"cijvhas79002cdcoq500rh27n","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas7c002edcoqe4k209e7"},{"post_id":"cijvhas7e002gdcoqsrludg9l","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas7i002idcoqmghnmdab"},{"post_id":"cijvhas7k002kdcoqdwm8ofu9","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas7n002mdcoqnhsqrzvm"},{"post_id":"cijvhas7p002odcoqxvn8nw4g","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas7r002qdcoqn55cqj8h"},{"post_id":"cijvhas7s002sdcoq0tpufamn","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas7u002udcoqnznm7ej4"},{"post_id":"cijvhas83002xdcoqc5jth5jt","tag_id":"cijvhas5b000tdcoqbzdxhsk7","_id":"cijvhas84002zdcoqwkif4ebx"},{"post_id":"cijvhas860031dcoqmb1v4v4r","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas8a0036dcoqljkz09ch"},{"post_id":"cijvhas860031dcoqmb1v4v4r","tag_id":"cijvhas880033dcoqwaerg4mm","_id":"cijvhas8a0037dcoq0p45edgi"},{"post_id":"cijvhas860031dcoqmb1v4v4r","tag_id":"cijvhas890035dcoqqzy0umtk","_id":"cijvhas8a0038dcoqotvimk4y"},{"post_id":"cijvhas8e0039dcoqnhctjysp","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhas8i003bdcoqnegkgdsn"},{"post_id":"cijvhas8j003ddcoqi78wy4vj","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas8l003fdcoqmmpuemz5"},{"post_id":"cijvhas8w003kdcoq3e0km6wb","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas91003mdcoq6pg45mzj"},{"post_id":"cijvhas95003odcoqtx3dqbw1","tag_id":"cijvhas250002dcoqeyrc1iyr","_id":"cijvhas97003qdcoq3bvfnry4"},{"post_id":"cijvhas9h003sdcoqzib3tf5w","tag_id":"cijvhas9j003udcoqhobjnb6j","_id":"cijvhas9l003xdcoqbts0fn4t"},{"post_id":"cijvhas9h003sdcoqzib3tf5w","tag_id":"cijvhas9j003wdcoq5hzookfx","_id":"cijvhas9m003ydcoqaj9ykh00"},{"post_id":"cijvhas9t003zdcoq3onsmu4h","tag_id":"cijvhas5w001adcoqu0su0y0m","_id":"cijvhas9x0041dcoq547wrlrh"},{"post_id":"cijvhasa00043dcoqmopy0sdi","tag_id":"cijvhas9j003udcoqhobjnb6j","_id":"cijvhasa20045dcoqqnseo4lq"},{"post_id":"cijvhasa00043dcoqmopy0sdi","tag_id":"cijvhas9j003wdcoq5hzookfx","_id":"cijvhasa20047dcoqpz9xcofw"},{"post_id":"cijvhasa50048dcoq5emmih0g","tag_id":"cijvhas3p000cdcoqk511qcor","_id":"cijvhasa8004cdcoqihbcr79f"},{"post_id":"cijvhasa50048dcoq5emmih0g","tag_id":"cijvhasa7004adcoq1gg2m8yk","_id":"cijvhasa8004ddcoqlwzeicfv"},{"post_id":"cijvhasaa004edcoq7r7986r1","tag_id":"cijvhas9j003udcoqhobjnb6j","_id":"cijvhasad004gdcoqty3tiz12"},{"post_id":"cijvhasah004jdcoqjzn7nn5t","tag_id":"cijvhasak004ldcoq2iap8ugt","_id":"cijvhasal004ndcoqnd8f7c9c"}],"Tag":[{"name":"总结","_id":"cijvhas250002dcoqeyrc1iyr"},{"name":"题解","_id":"cijvhas3p000cdcoqk511qcor"},{"name":"矩阵乘法","_id":"cijvhas3q000edcoq990zzieh"},{"name":"线段树","_id":"cijvhas3y000jdcoqswx3gstb"},{"name":"hash","_id":"cijvhas3y000ldcoq57l5n0ox"},{"name":"快速幂","_id":"cijvhas3z000mdcoqrvmpl3wc"},{"name":"软件","_id":"cijvhas5b000tdcoqbzdxhsk7"},{"name":"模板","_id":"cijvhas5m0015dcoqocm5kij1"},{"name":"工具","_id":"cijvhas5w001adcoqu0su0y0m"},{"name":"KMP","_id":"cijvhas67001hdcoqb5rjdfof"},{"name":"LCA","_id":"cijvhas880033dcoqwaerg4mm"},{"name":"RMQ","_id":"cijvhas890035dcoqqzy0umtk"},{"name":"教程","_id":"cijvhas9j003udcoqhobjnb6j"},{"name":"版本控制","_id":"cijvhas9j003wdcoq5hzookfx"},{"name":"floyd算法","_id":"cijvhasa7004adcoq1gg2m8yk"},{"name":"AC自动机","_id":"cijvhasak004ldcoq2iap8ugt"}]}}
=======
{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1},{"_id":"themes/next/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1}],"Cache":[{"_id":"source/_posts/9-4总结.md","shasum":"2297e0d21268455d50c4bd9473238ab7fb5b6023","modified":1451040449618},{"_id":"source/_posts/AC自动机算法详解.md","shasum":"2a82a94d8aa9e95a5bb04913741d98463251959e","modified":1450778002948},{"_id":"source/_posts/Crystal-李馨巧.md","shasum":"c7b7058a7e9296d1431714360b1540bdeb7a57c3","modified":1453814566202},{"_id":"source/_posts/Debian-7-安装教程.md","shasum":"3dd078552c79202c11c0eecc42f6d5933ef33234","modified":1451102423286},{"_id":"source/_posts/Find-the-Path.md","shasum":"7f602b5153c6cf3064c3737643808a759767fb4c","modified":1451039881001},{"_id":"source/_posts/Git-简明指南.md","shasum":"2d060d5e9967beb62cf9f0a96b75e7494c9adf96","modified":1450695759389},{"_id":"source/_posts/Github资源整理.md","shasum":"e34478a617a63cf68f427e01ab43ce003fc74f6f","modified":1450695760700},{"_id":"source/_posts/NOIP-10-27总结.md","shasum":"d82ac14cbf325bf195645c1f1d442d6b1d05c47b","modified":1451040691515},{"_id":"source/_posts/NOIP-11-21总结.md","shasum":"268f18f739446a062f6c83264aa2dcef711c82dd","modified":1451041211998},{"_id":"source/_posts/NOIP-考前必备.md","shasum":"cb4215502ce5935afedc9db00a5c4c0d6a4f4d5e","modified":1451102407452},{"_id":"source/_posts/NOIP2015提高组复赛-总结.md","shasum":"84cf053e0ff9930ad9c64f668d4c1433a3cdddb7","modified":1451041214407},{"_id":"source/_posts/Road.md","shasum":"1bce918740e197463ab9ed6f02064cffed1a650c","modified":1450695231647},{"_id":"source/_posts/bzoj3732-Network.md","shasum":"74306cb195b4ee09bdc9f8a31735541f13d506a5","modified":1451039502577},{"_id":"source/_posts/cc软件集.md","shasum":"4f830a27e73352dc4d7c6bb9b2470f57074d3627","modified":1450506844084},{"_id":"source/_posts/hello-world.md","shasum":"9ef6a60a9b81000ec3e327167db36f73701d3553","modified":1450506778166},{"_id":"source/_posts/【NOIP2013模拟联考9】阿Q的停车场.md","shasum":"8d47c20d73b1133a7123132c26aa3f692cb07c94","modified":1450506522424},{"_id":"source/_posts/【NOIP2015】10-30总结.md","shasum":"27a81010cb16c5dc57b8f655b8d43afeadc9b169","modified":1451040982727},{"_id":"source/_posts/【NOIP】10-28总结-A组.md","shasum":"a7198618f8c62de74afa0e9d17752b76509581a2","modified":1451040811056},{"_id":"source/_posts/【NOIP】10-29总结-B组.md","shasum":"c7b2a4b13c3dc6d12e048f81b562efdb87043558","modified":1451040882394},{"_id":"source/_posts/【NOIP】10-31总结.md","shasum":"242b943be72b2eb739a71835535ef0ff1ade8393","modified":1451041219888},{"_id":"source/_posts/【NOIP】11-13-11-14总结.md","shasum":"0de88e116ca97c8ae52107c53aebb12394e98095","modified":1451040945686},{"_id":"source/_posts/【NOIP】剑与魔法(dragons).md","shasum":"4981282e272f546a0fef504d100d9c8456b70fe3","modified":1450506469849},{"_id":"source/_posts/【NOIP】总结-10-30晚-11-5.md","shasum":"f9a9f0771c4f2752cdc9a8667d74431f8f9cd46d","modified":1451041217451},{"_id":"source/_posts/【NOIP】独立集-bubble.md","shasum":"df5e7d21a66b1422b3cc1afcb7ff6be3e217a6da","modified":1451039487978},{"_id":"source/_posts/【转载】有向图强连通分量的Tarjan算法.md","shasum":"e683a01dededa3e52661e677bcf72f51e5555bd6","modified":1450506614488},{"_id":"source/_posts/【转载】表达式求值问题.md","shasum":"0cc717b9dbed724a6c772802b9a2b31a03eccb51","modified":1450506581111},{"_id":"source/_posts/五校联考7-总结.md","shasum":"7511c217791ba79df91db71340836bf934d2e67e","modified":1451041234156},{"_id":"source/_posts/从头到尾彻底理解KMP.md","shasum":"1c6587c256d7c2b24f7d19057a7ddf642b7146ff","modified":1450778094740},{"_id":"source/_posts/使用七牛云存储作个人博客图床.md","shasum":"c7d66c4b377c3e369488cd66a9b170fe5f472a44","modified":1450696073355},{"_id":"source/_posts/信息学程序模板.md","shasum":"4c6aa90cfb12ae78b282c99af0ebd81d4e0b0539","modified":1451984837423},{"_id":"source/_posts/图形变换-transform.md","shasum":"9d012725f75e498ec3c682768f6eeecc34544f4c","modified":1451040245308},{"_id":"source/_posts/抽签程序.md","shasum":"e639cd48f9fed86a7b6bfc00d56b37536bd2f6ee","modified":1450506853925},{"_id":"source/_posts/线段-segment.md","shasum":"fb0cdddb6f80f65df91255b1edd70c3e53368628","modified":1451040102496},{"_id":"source/_posts/铺砖问题.md","shasum":"f406331e45752875b73d88e43481005632e94005","modified":1451039529268},{"_id":"source/about/index.md","shasum":"cdfdda151747e2c3fe1b0137d98ba635c18ea80d","modified":1450506030955},{"_id":"source/categories/index.md","shasum":"725b598e4c04118279ed53013efa7d63e27b7b38","modified":1450350973425},{"_id":"source/tags/index.md","shasum":"d99b072725fcb3411592bc4c34f24d4f4b1fa876","modified":1450350973426},{"_id":"source/_posts/Git教程.md","shasum":"3f60cb1e44a6b09d8ecaaf8c24db1912a8226d88","modified":1450868353999},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976280},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976477},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976478},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976478},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976526},{"_id":"themes/next/README.en.md","shasum":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1450350976000},{"_id":"themes/next/README.md","shasum":"b2499c61ef9cf6ee31ed5606ed43ef247c73de63","modified":1450350976000},{"_id":"themes/next/_config.yml","shasum":"ad5724d168b24cc58ddd62f4fd78e01e08f43e45","modified":1451550893342},{"_id":"themes/next/bower.json","shasum":"d46717b4a025790cda33d78339780c8749aee7fd","modified":1450350976001},{"_id":"themes/next/languages/de.yml","shasum":"3af67eda28640a99e17d06eec0c664e54e95fb2d","modified":1450350976002},{"_id":"themes/next/languages/default.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1450350976002},{"_id":"themes/next/languages/en.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1450350976002},{"_id":"themes/next/languages/fr-FR.yml","shasum":"eb05b50f49a29d46e90e45fabb12a14be6d7631d","modified":1450350976003},{"_id":"themes/next/languages/pt.yml","shasum":"e32711ad646d05911b515cc30e14c57f534a0045","modified":1450350976003},{"_id":"themes/next/languages/ru.yml","shasum":"4d1c2d4f4040d447a3511da51dc9fea7b177a7a6","modified":1450350976005},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"ba22a703638a23fce2cc51fcdfb1ba4dd7bcd114","modified":1450350976006},{"_id":"themes/next/languages/zh-hk.yml","shasum":"f80a494ecf23166152011cb5f4e9174fefa9197c","modified":1450350976006},{"_id":"themes/next/languages/zh-tw.yml","shasum":"f60af901f90fab657a1d27f981ad3381069842d0","modified":1450350976007},{"_id":"themes/next/layout/_layout.swig","shasum":"43dc8e01ca4d2e508db830250f2dcba7ded94830","modified":1450350976008},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"60766ca0cf5ba834d445c3304695d1a7ce0e1a36","modified":1450350976008},{"_id":"themes/next/layout/_macro/post.swig","shasum":"affea948ef5ad04dd089350340af722bcb2e7892","modified":1450350976009},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"c0f68851e8835b41fb60e7a78f096235067f7754","modified":1450350976009},{"_id":"themes/next/layout/_partials/comments.swig","shasum":"93055fc8e034037321280c182997a2a726e10c41","modified":1450350976010},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","shasum":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1450350976010},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"779fc2ec44464d66cadcc85913c49b2d8aad3d22","modified":1450350976011},{"_id":"themes/next/layout/_partials/head.swig","shasum":"471e197800829e9704ba9bb8f2d8f342c3e65c44","modified":1450350976011},{"_id":"themes/next/layout/_partials/header.swig","shasum":"8c8ae71c41722815540950ccefac47d6876d0413","modified":1450350976012},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"3c4d930d34c234725065173780a23673e1c574f5","modified":1450350976012},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1450350976013},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"73e8294939bbbb46755798215c605ebe5af5918f","modified":1450350976014},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1450350976014},{"_id":"themes/next/layout/_partials/search.swig","shasum":"1b86eb85017599392071d1230171e900045f8e69","modified":1450350976013},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1450350976015},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"12684840de632eb16e53ffa863166306a756fd4f","modified":1450350976016},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1450350976017},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1450350976017},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1450350976018},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"5e1b2b547a8f07ea0e3ab2a97dac9cc7d1e13c9a","modified":1450350976016},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"640d4dda003f54a0dffa4508fba4d91ac0dcfa6e","modified":1450350976018},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"0aad8d447567b683108b274c841c536b2daa176d","modified":1450350976019},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1450350976020},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"b03b2f596b7b9795f63dc4174329bf14aee7a48c","modified":1450350976021},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"701dfc53d750635de2f08f08d072d6ceb83b636c","modified":1450350976068},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1450350976068},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"8eecd19c756df615afb3f5ec6a527cd7bd06d20c","modified":1450350976069},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"de1fc505acbe8dc84f7376fe6ae9871f22d5582e","modified":1450350976069},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"ac600616e83e23ee446a646c57500706936bb45e","modified":1450350976070},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1450350976070},{"_id":"themes/next/layout/archive.swig","shasum":"40e899e690172d8dd19317b17ec7be94406f114f","modified":1450350976102},{"_id":"themes/next/layout/category.swig","shasum":"c777432e1587826ccad5a4aa50309763a82df52b","modified":1450350976102},{"_id":"themes/next/layout/index.swig","shasum":"56a70d0cd51ce739787da3e07638969ccb6abd2f","modified":1450350976103},{"_id":"themes/next/layout/page.swig","shasum":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1450350976103},{"_id":"themes/next/layout/post.swig","shasum":"e67a6aabe4d71cbcf01a4cace652424bd49acc9b","modified":1450350976103},{"_id":"themes/next/layout/tag.swig","shasum":"06417b0b050c66d816323b6178c9376ba2e58dd9","modified":1450350976104},{"_id":"themes/next/scripts/filters/sticky.js","shasum":"4e4c9a837e186f94f256bd6eabb89b138cfc0db6","modified":1450350976105},{"_id":"themes/next/scripts/merge-configs.js","shasum":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1450350976105},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"99b66949f18398689b904907af23c013be1b978f","modified":1450350976106},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1450350976106},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1450350976106},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"dac21141c7893ab9de697a8183d3b3f4eb7f0a5a","modified":1450350976108},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1450350976108},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"0a1730773478d843e123404ab4dae24d7cb0f2b7","modified":1450350976171},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1450350976171},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"cd2ec04433d6c98a0994945475fb47155d1015c0","modified":1450350976172},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1450350976173},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"70d7c3b5f8f2485dcce1a27e2c9b43df988fbc6f","modified":1450350976174},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1450350976174},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"88559b13ce94311405b170a0506ded91273beceb","modified":1450350976175},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8909298333c6dfc6e3686d85e4d98c76dfcf75c9","modified":1450350976175},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"008d5f951144c7fe5c7e66dac330d5fb715a0a83","modified":1450350976176},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"f28f00b2acb0df0343e77400bcc8246b40ac046c","modified":1450350976177},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"52badf0e8a0a44bb67f16486ada44d945b1aba6b","modified":1450350976177},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1450350976178},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"90a36892f5f595dda58a86901782b1addbdb3b46","modified":1450350976179},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"b8e1b52b7aaa94b7c52d1681225e80f1af1219fa","modified":1450350976180},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1450350976180},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"3702c4c350524622f7dd658b05449fc425a819ef","modified":1450350976235},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"16a98866f5025c050c56e52312228355a16d00d9","modified":1450350976235},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"c46d16429b85570347373fd11db8c222f6ff914e","modified":1450350976236},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"7bdc92a55f2eee20b6b546e93e4566696b459b9d","modified":1450350976237},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"dbb0843ea5aa7c2ac2755a2d1ce60fa662f1b939","modified":1450350976277},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"692c01dcdc612c3e1e245cf93d0ace0a4e2aaf3f","modified":1450350976278},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"a9f5260198225801eb5c16345a69a7e3cab904fe","modified":1450350976278},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"df9e5a418f6e54abe69c1ab84649be46fb0c51a6","modified":1450350976279},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1450350976280},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1450350976335},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"6eaa5d9cb08ecfb2d377a475e541e41fbfe4c1b6","modified":1450350976336},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1450350976337},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"cd6527e4877f62f08e8668b020ec9f9e53f625a9","modified":1450350976337},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"9a9630b7aae08b5008f3a0ff1152bdca427ff644","modified":1450350976369},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"482784c04c0cd15a3f0d86444966fe306af7d13a","modified":1450350976370},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"406b78061c45bda0376ce2360ff2932262f5f2f0","modified":1450350976370},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"627cdd38b34b15c9fc17f4dc332b1be928f8ed0d","modified":1450350976474},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1450350976475},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1450350976476},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1450350976478},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"e4b5b56e1a035c99ebd50d00e93d89e2e8d0b735","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"452e71caf2c37fa5a06f8d9ada81337a57485885","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"3b0a186e8d9d5cfe30dd611456b61053ea535d7b","modified":1450350976521},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1450350976521},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"f10be4b0c642104a6f533b94ac09e22019aa640e","modified":1450350976522},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1450350976522},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"dd667be3f5f24cebdc15d0262c7d397f23d751c5","modified":1450350976523},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"e315ee6f604c2bcc44a5ef9078f5ce420c153a4b","modified":1450350976523},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"ecd76494cea5fbf592cc13ba1e4ccdfedbc5bf1b","modified":1450350976525},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"932cb9c53d64b086638adca05dcf4e2df239a8f9","modified":1450350976526},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"9bc1cad0c7a9f4fdfa665098fb5c542dc9e640db","modified":1450350976526},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1450350976527},{"_id":"themes/next/source/css/main.styl","shasum":"6bb842ad45a575774299bed3848d46475820fb9f","modified":1450350976528},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1450350976529},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1450350976529},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1450350976530},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1450350976530},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1450350976531},{"_id":"themes/next/source/images/cc-by.svg","shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1450350976531},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1450350976532},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450350976532},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450350976532},{"_id":"themes/next/source/images/quote-l.svg","shasum":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1450350976533},{"_id":"themes/next/source/images/quote-r.svg","shasum":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1450350976533},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1450350976533},{"_id":"themes/next/source/js/bootstrap.js","shasum":"5a963f40fb81d265a31679f8f543e50ffdcc7485","modified":1450350976534},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"97640be11a524b203781c1a03f623ef0b9195a02","modified":1450350976534},{"_id":"themes/next/source/js/fancy-box.js","shasum":"fbeabc936667a9e15556c8defb5fcd582add8067","modified":1450350976535},{"_id":"themes/next/source/js/helpers.js","shasum":"69d8ae9b686a82e3a4397b61a477eb8da68bd153","modified":1450350976535},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1450350976536},{"_id":"themes/next/source/js/motion.js","shasum":"a9327a3c0a5df289799c5ffe3e8bf7dd6e407797","modified":1450350976536},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"fc57202d8d952fceb3f1ad5b6e7183f47a3f1a0e","modified":1450350976537},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450350976538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450350976539},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450350976539},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450350976575},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450350976575},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450350976576},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450350976576},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1450350976577},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1450350976621},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1450350976621},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1450350976622},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1450350976622},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1450350976623},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1450350976624},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1450350976624},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1450350976625},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1450350976626},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1450350976650},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1450350976651},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1450350976651},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1450350976716},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1450350976716},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1450350976718},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1450350976719},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1450350976814},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1450350976846},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1450350976884},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","shasum":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1450350976884},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","shasum":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1450350976916},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1450350976917},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1450350976918},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1450350976920},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1450350976972},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1450350976974},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1450350976974},{"_id":"themes/next/test/helpers.js","shasum":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1450350976976},{"_id":"themes/next/test/intern.js","shasum":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1450350976977},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1450350976818},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1450350976819},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1450350976845},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1450350976849},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1450350976843},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1450350976924},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1450350976841}],"Category":[{"name":"信息学","_id":"cijvfnut50001igtgurd5r3t5"},{"name":"原创","parent":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnute0003igtgjkrrt2xq"},{"name":"易语言","_id":"cijvfnv8p000sigtg102o1gx1"},{"name":"原创","parent":"cijvfnv8p000sigtg102o1gx1","_id":"cijvfnv8q000uigtg7jzkxsjo"},{"name":"互联网","_id":"cijvfnv9o0019igtgoppapk7z"},{"name":"转载","parent":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnv9p001bigtgmmff8ybj"},{"name":"转载","parent":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv9v001gigtg2lgpa94c"},{"name":"原创","parent":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnvfr004figtgwoupcok8"}],"Data":[],"Page":[{"title":"Tagcloud","date":"2015-12-12T07:40:37.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: Tagcloud\ndate: 2015-12-12 15:40:37\ntype: \"tags\"\ncomments: false\n---\n","updated":"2015-12-17T11:16:13.426Z","path":"tags/index.html","layout":"page","_id":"cijvfnv2a0007igtg184fzz0k"},{"title":"categories","date":"2015-12-12T07:43:24.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-12 15:43:24\ntype: \"categories\"\ncomments: false\n---\n","updated":"2015-12-17T11:16:13.425Z","path":"categories/index.html","layout":"page","_id":"cijvfnv4s0008igtg94mivkhr"},{"title":"about","date":"2015-12-11T10:55:44.000Z","type":"about","comments":0,"_content":"Not Ready!","source":"about/index.md","raw":"title: about\ndate: 2015-12-11 18:55:44\ntype: \"about\"\ncomments: false\n---\nNot Ready!","updated":"2015-12-19T06:20:30.955Z","path":"about/index.html","layout":"page","_id":"cijvfnv6s0009igtgzfqv8wm2"}],"Post":[{"title":"9.4总结","date":"2015-09-05T00:20:00.000Z","_content":"今天是5校联考的第一天,然而我犯了很多小错误。\n****\nT1：感觉像是数学问题，然而并没有发现什么规律。最后还是想着暴力，去打搜索，每一次向上有四种转移。但是我计算的时间复杂度计算错误。所以我认为拿不了太多分。最后，交了搜索，只拿了30分。因为我犯了一个错误，没有把max开到long long的最大范围，只开到了int的最大范围。改一下这个可以拿50分。最后与100分失之交臂，是因为我搜索的减枝做的不是很好。一个很给力的剪枝（r-l+1>l）没有发现，这个剪枝是答案可行性剪枝。\n****\nT2：一开始想到与题解类似的想法，但是因为无法处理好合法串中有可能在一个位置右括号多余左括号，最后面发现我完全想错了。所以就抛弃了这种方法。转而向题目所给的（A）与AB方向想，先找到最简单的符合条件的串，再一次扩展，就能把这个字符串中多有的合法子串找出。最后我先打了个暴力，然后就去打这种方法。但最后因为时间不够没有调出来。只不过我觉得调出来也应该拿不到满分，因为有一些东西可以与处理出来，一个个构造相加太慢了。后面是看到一个人的程序，他的想法和我的类似，只不过他通过多个预处理实现了出来，每一组数据的时间复杂度只有O（len）。\n****\nT3：这道题非常的神奇，因为完全摸不着正解的头绪，蒟蒻只能打搜索了，然而又一次我的搜索打挂了。我并没有测多组数据，然后多组数据就挂了。最后面发现是哈夫曼树，然后跟着WWT大神的证明听了一遍，然后又请教了一下LB，最后将这道题的解与哈夫曼树相同性的证明弄懂了","source":"_posts/9-4总结.md","raw":"---\ntitle: 9.4总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-09-05 08:20:00\n---\n今天是5校联考的第一天,然而我犯了很多小错误。\n****\nT1：感觉像是数学问题，然而并没有发现什么规律。最后还是想着暴力，去打搜索，每一次向上有四种转移。但是我计算的时间复杂度计算错误。所以我认为拿不了太多分。最后，交了搜索，只拿了30分。因为我犯了一个错误，没有把max开到long long的最大范围，只开到了int的最大范围。改一下这个可以拿50分。最后与100分失之交臂，是因为我搜索的减枝做的不是很好。一个很给力的剪枝（r-l+1>l）没有发现，这个剪枝是答案可行性剪枝。\n****\nT2：一开始想到与题解类似的想法，但是因为无法处理好合法串中有可能在一个位置右括号多余左括号，最后面发现我完全想错了。所以就抛弃了这种方法。转而向题目所给的（A）与AB方向想，先找到最简单的符合条件的串，再一次扩展，就能把这个字符串中多有的合法子串找出。最后我先打了个暴力，然后就去打这种方法。但最后因为时间不够没有调出来。只不过我觉得调出来也应该拿不到满分，因为有一些东西可以与处理出来，一个个构造相加太慢了。后面是看到一个人的程序，他的想法和我的类似，只不过他通过多个预处理实现了出来，每一组数据的时间复杂度只有O（len）。\n****\nT3：这道题非常的神奇，因为完全摸不着正解的头绪，蒟蒻只能打搜索了，然而又一次我的搜索打挂了。我并没有测多组数据，然后多组数据就挂了。最后面发现是哈夫曼树，然后跟着WWT大神的证明听了一遍，然后又请教了一下LB，最后将这道题的解与哈夫曼树相同性的证明弄懂了","slug":"9-4总结","published":1,"updated":"2015-12-25T10:47:29.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnusw0000igtgk9orb0ev","sticky":0},{"title":"铺砖问题","date":"2015-08-11T01:44:00.000Z","_content":"Description\n==\n用1×2的 砖头铺满N*M的区域，不能有重叠，一共有多少种方案？如下图所示：\n![方式](http://img.blog.csdn.net/20150811093026083)\n\nData Constraint\n==\n20%的数据满足1<=N,M<=6\n50%的数据满足1<=N<=100,1<=M<=11\n另外50%的数据满足1<=N<=10^200,1<=M<=5\n\nAnalysis\n==\n**对于此题的前50%的数据**\n可以参照此位大神的解析：\nhttp://blog.csdn.net/yan_____/article/details/8719748\n我的程序前50%就是参考了这篇文章\n\n**对于100%的数据**\n1. 我们发现N很大，但是M却很小。\n2. 前50%的数据我们都是通过不同的二进制状态转移并累加得到的。这种转移就显然就是矩阵自乘的结果。而他的答案就是$a[(1 shl m)-1,(1 shl m)-1]$,表示从(1 shl m)-1转移到(1 shl m)-1的方案数。\n3. 那么我们可以将前50%数据得到的st数组中的对应值映射到[0..1 shl m,0..1 shl m]的矩阵中，然后将这个矩阵自乘n次即可得到答案。\n4. 矩阵自乘可以用快速幂进行优化。\n5. 因为做一次矩阵乘法的时间复杂度为$O(N^3)$。所以整体的时间复杂度为$O((2^m)^3*log(10^100)/log(2))$。\n6. 因为n极其的庞大所以在做快速幂时我们需要用到单精除。\n7. 可能很多人会不理解为什么用矩阵乘法和为什么答案是$a[(1 shl m)-1,(1 shl m)-1]$。(懂得人可以忽略此部分内容)\n\n对于每一层来说，因为st数组中$st[i][0] $都可以到$st[i][1]$ 。所以我们首先想想最简单的情况:\n当n=1时，他的答案就是从$dp[0][1 shl m-1]$ 到$dp[1][1 shl m-1] $。就是 $base[1 shl m -1] [1 shl m-1]$。\n当n=2 时，我们可以看看矩阵乘法的工作原理 对于答案$ans[i,j] += a[i,k]*a[k,j]$，他是通过枚举k将第i行和第j列一一对应相乘并累加的道德结果。而在我们的基础矩阵base存放的就是第i行的状态可以转移到哪j个状态。当你要从i这个状态到j这个状态，我们可以枚举一个中间点k让i先到k，再从k到j\n,这样恰好进行了两次转移所以这个ans矩阵，就代表从第i个状态经过了n次转移(看你乘了多少次)到达第j个状态的方案数。\n其实矩阵乘法可以类比floyd求最短路的算法。\n\nCode\n==\n因为代码比较丑，所以不要见怪\n```\nconst\tmaxn=100+5;maxm=10+5;\n\t\tmo=1000000007;len=17;size=(1 shl 5);jw=100000000000000000;\ntype\tbignum=array[0..15] of int64;\n\t\tmatrix=array[0..size,0..size] of int64;\nvar\ti,j,m,n,tot,tmp:longint;\n\tst:array[0..(1 shl maxm),0..1] of longint;\n\tdp:array[0..maxn,0..(1 shl maxm)] of int64;\n\ts,nn,mm:string;\n\tbase,ans:matrix;\n\tn1:bignum;\n\tsum:int64;\nprocedure dfs(n,from,next:longint);\nbegin\n\tif (n>m) then begin\n\t\texit;\n\tend;\n\tif (n=m) then begin\n\t\tst[tot][0]:=from;\n\t\tst[tot][1]:=next;\n\t\tinc(tot);\n\t\texit;\n\tend;\n\tdfs(n+2,(from<<2)+3,(next<<2)+3);\n\tdfs(n+1,(from<<1)+1,(next<<1));\n\tdfs(n+1,(from<<1),(next<<1)+1);\nend;\nprocedure div2(var x:bignum);\nvar\ti,t:longint;\nbegin\n\tt:=0;\n\tfor i:=x[0] downto 1 do begin\n\t\tx[i]:=t*jw+x[i];\n\t\tt:=x[i] mod 2;\n\t\tx[i]:=x[i] div 2;\n\t\tif x[i]=0 then x[0]:=i-1;\n\tend;\nend;\nprocedure stom(var s:string;var num:bignum);\nvar\tts:string[len];\n\ti:longint;\nbegin\n\tfillchar(num,sizeof(num),0);\n\tts:='';\n\tfor i:=length(s) downto 1 do begin\n\t\tts:=s[i]+ts;\n\t\tif length(ts)=len then begin\n\t\t\tinc(num[0]);\n\t\t\tval(ts,num[num[0]]);\n\t\t\tts:='';\n\t\tend;\n\tend;\n\tif ts<>'' then begin\n\t\tinc(num[0]);\n\t\tval(ts,num[num[0]]);\n\tend;\nend;\nfunction mul(x,y:matrix):matrix;//矩阵乘法\nvar     i,j,k,size1:integer;\n\tz:matrix;\nbegin\n\tsize1:=(1<<m);\n        fillchar(z,sizeof(z),0);\n        for i:=0 to size1 do\n        for j:=0 to size1 do\n\tfor k:=0 to size1 do begin\n\t\tz[i,j]:=(z[i,j]+x[i,k]*y[k,j])mod mo;\n\tend;\n\texit(z);\nend;\nprocedure work(y:bignum);\nbegin\n\tfillchar(ans,sizeof(ans),0);\n\tfor i:=0 to (1<<m) do ans[i][i]:=1;\n\t//单位矩阵，就是实数中的1\n\twhile (y[0]<>0) do begin\n\t\tif odd(y[1]) then begin\n\t\t\tans:=mul(ans,base);\n\t\tend;\n\t\tbase:=mul(base,base);\n\t\tdiv2(y);\n\tend;\nend;\nbegin\n\treadln(s);\n\ttmp:=pos(' ',s);\n\tnn:=copy(s,1,tmp-1);\n\tmm:=copy(s,tmp + 1,length(s) - tmp);val(mm,m);\n\n\ttot:=0;\n\tdfs(0,0,0);\n\tif (length(nn)<=2) or (nn='100') then begin\n\t\t//前50%的做法\n\t\tval(nn,n);\n\t\tif odd(n*m) then begin\n\t\t\twriteln(0);\n\t\t\texit;\n\t\tend;\t\n\n\t\tdp[0][(1<<m)-1]:=1;\n\t\tfor i:=1 to n do \n\t\t\tfor j:=0 to tot-1 do begin\n\t\t\t\tdp[i][st[j][1]]:=(dp[i][st[j][1]]+dp[i-1][st[j][0]]) mod mo;\n\t\t\tend;\n\t\twriteln(dp[n][(1<<m)-1]);\n\tend else begin\n\t\tfillchar(base,sizeof(base),0);\n\t\tfor j:=0 to tot-1 do begin\n\t\t\tbase[st[j][0]][st[j][1]]:=1;\n\t\tend;\n\t\t//初始化基础对应矩阵\n\t\tstom(nn,n1);//将nn这个字符串转化为高精度数组\n\t\twork(n1);//快速幂做矩阵乘法\n\t\tsum:=ans[(1<<m)-1][(1<<m)-1];\n\t\twriteln(sum mod mo);\n\tend;\nend.\n```\nTips\n==\n此题源自：zoj1100\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1100\n据说此题有通项公式，具体请看维基百科\nhttps://en.wikipedia.org/wiki/Domino_tiling\n","source":"_posts/铺砖问题.md","raw":"---\ntitle: 铺砖问题\ndate: 2015-08-11 09:44\ntags:\n  - 题解\n  - 矩阵乘法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n==\n用1×2的 砖头铺满N*M的区域，不能有重叠，一共有多少种方案？如下图所示：\n![方式](http://img.blog.csdn.net/20150811093026083)\n\nData Constraint\n==\n20%的数据满足1<=N,M<=6\n50%的数据满足1<=N<=100,1<=M<=11\n另外50%的数据满足1<=N<=10^200,1<=M<=5\n\nAnalysis\n==\n**对于此题的前50%的数据**\n可以参照此位大神的解析：\nhttp://blog.csdn.net/yan_____/article/details/8719748\n我的程序前50%就是参考了这篇文章\n\n**对于100%的数据**\n1. 我们发现N很大，但是M却很小。\n2. 前50%的数据我们都是通过不同的二进制状态转移并累加得到的。这种转移就显然就是矩阵自乘的结果。而他的答案就是$a[(1 shl m)-1,(1 shl m)-1]$,表示从(1 shl m)-1转移到(1 shl m)-1的方案数。\n3. 那么我们可以将前50%数据得到的st数组中的对应值映射到[0..1 shl m,0..1 shl m]的矩阵中，然后将这个矩阵自乘n次即可得到答案。\n4. 矩阵自乘可以用快速幂进行优化。\n5. 因为做一次矩阵乘法的时间复杂度为$O(N^3)$。所以整体的时间复杂度为$O((2^m)^3*log(10^100)/log(2))$。\n6. 因为n极其的庞大所以在做快速幂时我们需要用到单精除。\n7. 可能很多人会不理解为什么用矩阵乘法和为什么答案是$a[(1 shl m)-1,(1 shl m)-1]$。(懂得人可以忽略此部分内容)\n\n对于每一层来说，因为st数组中$st[i][0] $都可以到$st[i][1]$ 。所以我们首先想想最简单的情况:\n当n=1时，他的答案就是从$dp[0][1 shl m-1]$ 到$dp[1][1 shl m-1] $。就是 $base[1 shl m -1] [1 shl m-1]$。\n当n=2 时，我们可以看看矩阵乘法的工作原理 对于答案$ans[i,j] += a[i,k]*a[k,j]$，他是通过枚举k将第i行和第j列一一对应相乘并累加的道德结果。而在我们的基础矩阵base存放的就是第i行的状态可以转移到哪j个状态。当你要从i这个状态到j这个状态，我们可以枚举一个中间点k让i先到k，再从k到j\n,这样恰好进行了两次转移所以这个ans矩阵，就代表从第i个状态经过了n次转移(看你乘了多少次)到达第j个状态的方案数。\n其实矩阵乘法可以类比floyd求最短路的算法。\n\nCode\n==\n因为代码比较丑，所以不要见怪\n```\nconst\tmaxn=100+5;maxm=10+5;\n\t\tmo=1000000007;len=17;size=(1 shl 5);jw=100000000000000000;\ntype\tbignum=array[0..15] of int64;\n\t\tmatrix=array[0..size,0..size] of int64;\nvar\ti,j,m,n,tot,tmp:longint;\n\tst:array[0..(1 shl maxm),0..1] of longint;\n\tdp:array[0..maxn,0..(1 shl maxm)] of int64;\n\ts,nn,mm:string;\n\tbase,ans:matrix;\n\tn1:bignum;\n\tsum:int64;\nprocedure dfs(n,from,next:longint);\nbegin\n\tif (n>m) then begin\n\t\texit;\n\tend;\n\tif (n=m) then begin\n\t\tst[tot][0]:=from;\n\t\tst[tot][1]:=next;\n\t\tinc(tot);\n\t\texit;\n\tend;\n\tdfs(n+2,(from<<2)+3,(next<<2)+3);\n\tdfs(n+1,(from<<1)+1,(next<<1));\n\tdfs(n+1,(from<<1),(next<<1)+1);\nend;\nprocedure div2(var x:bignum);\nvar\ti,t:longint;\nbegin\n\tt:=0;\n\tfor i:=x[0] downto 1 do begin\n\t\tx[i]:=t*jw+x[i];\n\t\tt:=x[i] mod 2;\n\t\tx[i]:=x[i] div 2;\n\t\tif x[i]=0 then x[0]:=i-1;\n\tend;\nend;\nprocedure stom(var s:string;var num:bignum);\nvar\tts:string[len];\n\ti:longint;\nbegin\n\tfillchar(num,sizeof(num),0);\n\tts:='';\n\tfor i:=length(s) downto 1 do begin\n\t\tts:=s[i]+ts;\n\t\tif length(ts)=len then begin\n\t\t\tinc(num[0]);\n\t\t\tval(ts,num[num[0]]);\n\t\t\tts:='';\n\t\tend;\n\tend;\n\tif ts<>'' then begin\n\t\tinc(num[0]);\n\t\tval(ts,num[num[0]]);\n\tend;\nend;\nfunction mul(x,y:matrix):matrix;//矩阵乘法\nvar     i,j,k,size1:integer;\n\tz:matrix;\nbegin\n\tsize1:=(1<<m);\n        fillchar(z,sizeof(z),0);\n        for i:=0 to size1 do\n        for j:=0 to size1 do\n\tfor k:=0 to size1 do begin\n\t\tz[i,j]:=(z[i,j]+x[i,k]*y[k,j])mod mo;\n\tend;\n\texit(z);\nend;\nprocedure work(y:bignum);\nbegin\n\tfillchar(ans,sizeof(ans),0);\n\tfor i:=0 to (1<<m) do ans[i][i]:=1;\n\t//单位矩阵，就是实数中的1\n\twhile (y[0]<>0) do begin\n\t\tif odd(y[1]) then begin\n\t\t\tans:=mul(ans,base);\n\t\tend;\n\t\tbase:=mul(base,base);\n\t\tdiv2(y);\n\tend;\nend;\nbegin\n\treadln(s);\n\ttmp:=pos(' ',s);\n\tnn:=copy(s,1,tmp-1);\n\tmm:=copy(s,tmp + 1,length(s) - tmp);val(mm,m);\n\n\ttot:=0;\n\tdfs(0,0,0);\n\tif (length(nn)<=2) or (nn='100') then begin\n\t\t//前50%的做法\n\t\tval(nn,n);\n\t\tif odd(n*m) then begin\n\t\t\twriteln(0);\n\t\t\texit;\n\t\tend;\t\n\n\t\tdp[0][(1<<m)-1]:=1;\n\t\tfor i:=1 to n do \n\t\t\tfor j:=0 to tot-1 do begin\n\t\t\t\tdp[i][st[j][1]]:=(dp[i][st[j][1]]+dp[i-1][st[j][0]]) mod mo;\n\t\t\tend;\n\t\twriteln(dp[n][(1<<m)-1]);\n\tend else begin\n\t\tfillchar(base,sizeof(base),0);\n\t\tfor j:=0 to tot-1 do begin\n\t\t\tbase[st[j][0]][st[j][1]]:=1;\n\t\tend;\n\t\t//初始化基础对应矩阵\n\t\tstom(nn,n1);//将nn这个字符串转化为高精度数组\n\t\twork(n1);//快速幂做矩阵乘法\n\t\tsum:=ans[(1<<m)-1][(1<<m)-1];\n\t\twriteln(sum mod mo);\n\tend;\nend.\n```\nTips\n==\n此题源自：zoj1100\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1100\n据说此题有通项公式，具体请看维基百科\nhttps://en.wikipedia.org/wiki/Domino_tiling\n","slug":"铺砖问题","published":1,"updated":"2015-12-25T10:32:09.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnv6y000aigtgg8c3709f","sticky":0},{"title":"线段(segment)","date":"2015-08-18T14:25:00.000Z","_content":"Description\n--\n数轴上有很多单位线段，一开始时所有单位线段的权值都是1。有两种操作，第一种操作将某一区间内的单位线段权值乘以w，第二种操作将某一区间内的单位线段权值取w次幂。并且你还需要回答一些询问，每个询问需要求出某一区间的单位线段权值之积。由于答案可能很大，你只需要求出答案 mod (10^9+7)的值。\n\nInput\n--\n第一行一个整数n，表示操作数量。\n\n接下来n行，每行第一个整数表示操作类型，0表示第一种操作，1表示第二种操作，2表示询问，如果第一个数是0或1，则接下来3个数，表示操作区间和w，否则接下来两个数，表示询问区间。\n\nOutput\n--\n对于每组询问，输出一行，表示所求答案。\n\nSample Input\n--\n\n```\n7\n0 0 2 3\n1 1 3 2\n2 1 3\n0 0 3 2\n1 1 3 2\n2 1 3\n2 0 3\n```\n\nSample Output\n--\n\n```\n9\n1296\n7776\n```\n\nData Constraint\n--\n![下表中的“线段权值”表示“单位线段经过各种w处理后的权值范围”](http://img.blog.csdn.net/20150818220038129)\nAnalysis\n--\n看完标题和题目，就给人一种提醒，此题要用线段树。仔细观察可以发现这题类似于线段树维护区间和。所以同理能用线段树解决。只是将这道题改成了区间积和增加了对区间取幂次方的修改。因为有两种修改，所以我们要维护两个下传标记。但是区间的范围却非常大，这显然是要爆空间的节奏啊！！\n细心的我们发现，此题n很小，可是区间范围却很大，我们何不考虑一下离散化呢？这样子整个线段的长度就只有2n了。在做乘积的时候还需要用到快速幂。接下来就是怎么实现的问题了。\n实现过程还是挺复杂的！！首先我们把读入的数据离线掉，并将各个区间的值排序后塞入hash表中，在hash表中存入旧位置及新位置对应的匹配。这样我们就能很快的从旧的位置找到新的位置。\n剩下的问题就是如何去维护标记。我打了两个标记，一个是标记第一种操作在区间中乘了多少个w（没有他的L次幂，因为每个区间的L都有可能不同）。第二个标记是记录第二个操作（即这个区间乘了多少次方）。只用了这两个标记。剩下的就是线段树的实现了。\nCode\n--\n\n```\nconst\tmaxn=20000+2;mo=1000000007;hamo=200000+2;\ntype\tnode=record\n\t\tv,ad,ad2:longint;\n\tend;\n\tarr=array[1..2*maxn] of longint;\nvar\ti,n,sum,ret,x,y,z,t,kk:longint;\n\tq:array[1..maxn,1..4] of longint;\n\th:array[1..hamo] of node;\n\ta:arr;\n\tlen,d:array[1..hamo] of longint;\n\thash:array[0..hamo,1..2] of longint;\nprocedure times(var x:longint;y:longint);\nbegin\n\tx:=(int64(x) * (y mod mo)) mod mo;\nend;\nfunction pow(x:int64;y:longint):int64;\nbegin\n\tpow:=1;\n\twhile y<>0 do begin\n\t\tif odd(y) then pow:=(pow*x) mod mo;\n\t\tx:=(x*x) mod mo;\n\t\ty:=y>>1;\n\tend;\nend;\nprocedure qsort(var a1:arr;l,r:longint);\nvar\tm,i,j,t:longint;\nbegin\n\tm:=a1[(l+r) div 2];\n\ti:=l;j:=r;\n\trepeat\n\t\twhile a1[i]<m do inc(i);\n\t\twhile a1[j]>m do dec(j);\n\t\tif i<=j then begin\n\t\t\tt:=a1[i];\n\t\t\ta1[i]:=a1[j];\n\t\t\ta1[j]:=t;\n\t\t\tinc(i);dec(j);\n\t\tend;\n\tuntil i>j;\n\tif l<j then qsort(a1,l,j);\n\tif i<r then qsort(a1,i,r);\nend;\n\nprocedure maketree(x,l,r:longint);\nvar\tmid:longint;\nbegin\n\tif (l=r) then begin\n\t\th[x].v:=1;\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\t\td[x]:=len[l];\n\tend else begin\n\t\tmid:=(l+r) >> 1;\n\t\tmaketree(x*2,l,mid);\n\t\tmaketree(x*2+1,mid+1,r);\n\t\th[x].v:=1;\n\t\td[x]:=d[x*2]+d[x*2+1];\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\tend;\nend;\nprocedure change(x,l,r:longint);\nbegin\n        h[x*2].v\t:=pow(h[x*2].v,h[x].ad2);\n        h[x*2+1].v\t:=pow(h[x*2+1].v,h[x].ad2);\n        h[x*2].ad\t:=pow(h[x*2].ad,h[x].ad2);\n        h[x*2+1].ad\t:=pow(h[x*2+1].ad,h[x].ad2);\n        h[x*2].ad2\t:=(int64(h[x*2].ad2) * h[x].ad2) mod (mo-1);\n        h[x*2+1].ad2\t:=(int64(h[x*2+1].ad2) * h[x].ad2) mod (mo-1);\n        h[x].ad2\t:=1;\n\n        times(h[x*2].v,pow(h[x].ad,d[x*2]));\n        times(h[x*2].ad,h[x].ad);\n\ttimes(h[x*2+1].v,pow(h[x].ad,d[x*2+1]));\n        times(h[x*2+1].ad,h[x].ad);\n        h[x].ad := 1;\nend;\nprocedure modify1(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(h[x].v,pow(w,d[x]));\n\t\ttimes(h[x].ad,w);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify1(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify1(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify1(x*2,l,mid,st,mid,w);\n\t\t\tmodify1(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure modify2(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n                h[x].v := pow(h[x].v,w);\n                h[x].ad := pow(h[x].ad,w);\n                h[x].ad2 := (int64(h[x].ad2) * w) mod (mo-1);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify2(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify2(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify2(x*2,l,mid,st,mid,w);\n\t\t\tmodify2(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure query(x,l,r,st,en:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(ret,h[x].v);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then query(x*2,l,mid,st,en)\n\t\telse if st>mid then query(x*2+1,mid+1,r,st,en)\n\t\telse begin\n\t\t\tquery(x*2,l,mid,st,mid);\n\t\t\tquery(x*2+1,mid+1,r,mid+1,en);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\n\nprocedure enter(x,i:longint);\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,1]<>0 do y:=(y+1) mod hamo;\n\thash[y,1]:=i;\n\thash[y,2]:=x\nend;\nfunction ha(x:longint):longint;\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,2]<>x do y:=(y+1) mod hamo;\n\texit(hash[y,1]);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\tread(q[i,1],q[i,2],q[i,3]);\n\t\tif q[i,1]<>2 then read(q[i,4]);\n\t\tinc(t); a[t]:=q[i,2];\n\t\tinc(t); a[t]:=q[i,3];\n\tend;\n\tqsort(a,1,t);\n\tkk:=a[1];\n\tfor i:=2 to t do begin\n\t\tif kk<>a[i] then begin\n\t\t\tinc(sum);\n\t\t\tenter(kk,sum);\n\t\t\tlen[sum]:=a[i]-kk;\n\t\t\tkk:=a[i];\n\t\tend;\n\tend;\n\tinc(sum); enter(a[t],sum); dec(sum);\n\tmaketree(1,1,sum);\n\n\tfor i:=1 to n do begin\n\t\tx:=ha(q[i,2]);\n\t\ty:=ha(q[i,3])-1;\n\t\tcase q[i,1] of\n\t\t\t0:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify1(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t1:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify2(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t2:begin\n\t\t\t\tret:=1;\n\t\t\t\tquery(1,1,sum,x,y);\n\t\t\t\twriteln(ret);\n\t\t\tend;\n\t\tend;\n\tend; \nend.\n```","source":"_posts/线段-segment.md","raw":"---\ntitle: 线段(segment)\ndate: 2015-08-18 22:25:00\ntags:\n  - 题解\n  - 线段树\n  - hash\n  - 快速幂\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\n数轴上有很多单位线段，一开始时所有单位线段的权值都是1。有两种操作，第一种操作将某一区间内的单位线段权值乘以w，第二种操作将某一区间内的单位线段权值取w次幂。并且你还需要回答一些询问，每个询问需要求出某一区间的单位线段权值之积。由于答案可能很大，你只需要求出答案 mod (10^9+7)的值。\n\nInput\n--\n第一行一个整数n，表示操作数量。\n\n接下来n行，每行第一个整数表示操作类型，0表示第一种操作，1表示第二种操作，2表示询问，如果第一个数是0或1，则接下来3个数，表示操作区间和w，否则接下来两个数，表示询问区间。\n\nOutput\n--\n对于每组询问，输出一行，表示所求答案。\n\nSample Input\n--\n\n```\n7\n0 0 2 3\n1 1 3 2\n2 1 3\n0 0 3 2\n1 1 3 2\n2 1 3\n2 0 3\n```\n\nSample Output\n--\n\n```\n9\n1296\n7776\n```\n\nData Constraint\n--\n![下表中的“线段权值”表示“单位线段经过各种w处理后的权值范围”](http://img.blog.csdn.net/20150818220038129)\nAnalysis\n--\n看完标题和题目，就给人一种提醒，此题要用线段树。仔细观察可以发现这题类似于线段树维护区间和。所以同理能用线段树解决。只是将这道题改成了区间积和增加了对区间取幂次方的修改。因为有两种修改，所以我们要维护两个下传标记。但是区间的范围却非常大，这显然是要爆空间的节奏啊！！\n细心的我们发现，此题n很小，可是区间范围却很大，我们何不考虑一下离散化呢？这样子整个线段的长度就只有2n了。在做乘积的时候还需要用到快速幂。接下来就是怎么实现的问题了。\n实现过程还是挺复杂的！！首先我们把读入的数据离线掉，并将各个区间的值排序后塞入hash表中，在hash表中存入旧位置及新位置对应的匹配。这样我们就能很快的从旧的位置找到新的位置。\n剩下的问题就是如何去维护标记。我打了两个标记，一个是标记第一种操作在区间中乘了多少个w（没有他的L次幂，因为每个区间的L都有可能不同）。第二个标记是记录第二个操作（即这个区间乘了多少次方）。只用了这两个标记。剩下的就是线段树的实现了。\nCode\n--\n\n```\nconst\tmaxn=20000+2;mo=1000000007;hamo=200000+2;\ntype\tnode=record\n\t\tv,ad,ad2:longint;\n\tend;\n\tarr=array[1..2*maxn] of longint;\nvar\ti,n,sum,ret,x,y,z,t,kk:longint;\n\tq:array[1..maxn,1..4] of longint;\n\th:array[1..hamo] of node;\n\ta:arr;\n\tlen,d:array[1..hamo] of longint;\n\thash:array[0..hamo,1..2] of longint;\nprocedure times(var x:longint;y:longint);\nbegin\n\tx:=(int64(x) * (y mod mo)) mod mo;\nend;\nfunction pow(x:int64;y:longint):int64;\nbegin\n\tpow:=1;\n\twhile y<>0 do begin\n\t\tif odd(y) then pow:=(pow*x) mod mo;\n\t\tx:=(x*x) mod mo;\n\t\ty:=y>>1;\n\tend;\nend;\nprocedure qsort(var a1:arr;l,r:longint);\nvar\tm,i,j,t:longint;\nbegin\n\tm:=a1[(l+r) div 2];\n\ti:=l;j:=r;\n\trepeat\n\t\twhile a1[i]<m do inc(i);\n\t\twhile a1[j]>m do dec(j);\n\t\tif i<=j then begin\n\t\t\tt:=a1[i];\n\t\t\ta1[i]:=a1[j];\n\t\t\ta1[j]:=t;\n\t\t\tinc(i);dec(j);\n\t\tend;\n\tuntil i>j;\n\tif l<j then qsort(a1,l,j);\n\tif i<r then qsort(a1,i,r);\nend;\n\nprocedure maketree(x,l,r:longint);\nvar\tmid:longint;\nbegin\n\tif (l=r) then begin\n\t\th[x].v:=1;\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\t\td[x]:=len[l];\n\tend else begin\n\t\tmid:=(l+r) >> 1;\n\t\tmaketree(x*2,l,mid);\n\t\tmaketree(x*2+1,mid+1,r);\n\t\th[x].v:=1;\n\t\td[x]:=d[x*2]+d[x*2+1];\n\t\th[x].ad:=1;\n\t\th[x].ad2:=1;\n\tend;\nend;\nprocedure change(x,l,r:longint);\nbegin\n        h[x*2].v\t:=pow(h[x*2].v,h[x].ad2);\n        h[x*2+1].v\t:=pow(h[x*2+1].v,h[x].ad2);\n        h[x*2].ad\t:=pow(h[x*2].ad,h[x].ad2);\n        h[x*2+1].ad\t:=pow(h[x*2+1].ad,h[x].ad2);\n        h[x*2].ad2\t:=(int64(h[x*2].ad2) * h[x].ad2) mod (mo-1);\n        h[x*2+1].ad2\t:=(int64(h[x*2+1].ad2) * h[x].ad2) mod (mo-1);\n        h[x].ad2\t:=1;\n\n        times(h[x*2].v,pow(h[x].ad,d[x*2]));\n        times(h[x*2].ad,h[x].ad);\n\ttimes(h[x*2+1].v,pow(h[x].ad,d[x*2+1]));\n        times(h[x*2+1].ad,h[x].ad);\n        h[x].ad := 1;\nend;\nprocedure modify1(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(h[x].v,pow(w,d[x]));\n\t\ttimes(h[x].ad,w);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify1(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify1(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify1(x*2,l,mid,st,mid,w);\n\t\t\tmodify1(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure modify2(x,l,r,st,en,w:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n                h[x].v := pow(h[x].v,w);\n                h[x].ad := pow(h[x].ad,w);\n                h[x].ad2 := (int64(h[x].ad2) * w) mod (mo-1);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then modify2(x*2,l,mid,st,en,w)\n\t\telse if st>mid then modify2(x*2+1,mid+1,r,st,en,w)\n\t\telse begin\n\t\t\tmodify2(x*2,l,mid,st,mid,w);\n\t\t\tmodify2(x*2+1,mid+1,r,mid+1,en,w);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\nprocedure query(x,l,r,st,en:longint);\nvar\tmid:longint;\nbegin\n\tif (st<=l) and (r<=en) then begin\n\t\ttimes(ret,h[x].v);\n\tend else begin\n\t\tchange(x,l,r);\n\t\tmid:=(l+r) >> 1;\n\t\tif en<=mid then query(x*2,l,mid,st,en)\n\t\telse if st>mid then query(x*2+1,mid+1,r,st,en)\n\t\telse begin\n\t\t\tquery(x*2,l,mid,st,mid);\n\t\t\tquery(x*2+1,mid+1,r,mid+1,en);\n\t\tend;\n\t\th[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo;\n\tend;\nend;\n\nprocedure enter(x,i:longint);\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,1]<>0 do y:=(y+1) mod hamo;\n\thash[y,1]:=i;\n\thash[y,2]:=x\nend;\nfunction ha(x:longint):longint;\nvar\ty:longint;\nbegin\n\ty:=abs(x) mod hamo;\n\twhile hash[y,2]<>x do y:=(y+1) mod hamo;\n\texit(hash[y,1]);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\tread(q[i,1],q[i,2],q[i,3]);\n\t\tif q[i,1]<>2 then read(q[i,4]);\n\t\tinc(t); a[t]:=q[i,2];\n\t\tinc(t); a[t]:=q[i,3];\n\tend;\n\tqsort(a,1,t);\n\tkk:=a[1];\n\tfor i:=2 to t do begin\n\t\tif kk<>a[i] then begin\n\t\t\tinc(sum);\n\t\t\tenter(kk,sum);\n\t\t\tlen[sum]:=a[i]-kk;\n\t\t\tkk:=a[i];\n\t\tend;\n\tend;\n\tinc(sum); enter(a[t],sum); dec(sum);\n\tmaketree(1,1,sum);\n\n\tfor i:=1 to n do begin\n\t\tx:=ha(q[i,2]);\n\t\ty:=ha(q[i,3])-1;\n\t\tcase q[i,1] of\n\t\t\t0:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify1(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t1:begin\n\t\t\t\tz:=q[i,4];\n\t\t\t\tmodify2(1,1,sum,x,y,z);\n\t\t\tend;\n\t\t\t2:begin\n\t\t\t\tret:=1;\n\t\t\t\tquery(1,1,sum,x,y);\n\t\t\t\twriteln(ret);\n\t\t\tend;\n\t\tend;\n\tend; \nend.\n```","slug":"线段-segment","published":1,"updated":"2015-12-25T10:41:42.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnv8b000higtgxohtbph4","sticky":0},{"title":"抽签程序","date":"2013-11-09T15:54:24.000Z","_content":"最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","source":"_posts/抽签程序.md","raw":"title: 抽签程序\ndate: 2013-11-9 23:54:24\ntags: [软件]\ncategories: [易语言,原创]\n---\n最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","slug":"抽签程序","published":1,"updated":"2015-12-19T06:34:13.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnv8n000rigtgpcniu04w","sticky":0},{"title":"图形变换(transform)","date":"2015-08-21T02:39:00.000Z","_content":"Description\n--\n对一个由n个点组成的图形连续作平移、缩放、旋转变换。相关操作定义如下：\n\nTrans(dx,dy) 表示平移图形，即把图形上所有的点的横纵坐标分别加上dx和dy；\n\nScale(sx,sy) 表示缩放图形，即把图形上所有点的横纵坐标分别乘以sx和sy；\n\nRotate(θ,x0,y0) 表示旋转图形，即把图形上所有点的坐标绕(x0,y0)顺时针旋转θ角度\n\n由于某些操作会重复运行多次，还定义了循环指令：\n\nLoop(m)\n\n… \n\nEnd \n\n表示把Loop和对应End之间的操作循环执行m次，循环可以嵌套。\n\nInput\n--\n第一行一个整数n(n<=100)表示图形由n个点组成；\n\n接下来n行，每行空格隔开两个实数xi，yi表示点的坐标；\n\n接下来一直到文件结束，每行一条操作指令。保证指令格式合法，无多余空格。\nOutput\n--\n输出有n行，每行两个空格隔开实数xi，yi表示对应输入的点变换后的坐标。\n\n本题采用Special Judge判断，只要你输出的数值与标准答案误差不能超过1即可。\n\nSample Input\n--\n\n```\n3\n0.5 0\n2.5 2\n-4.5 1\nTrans(1.5,-1)\nLoop(2)\nTrans(1,1)\nLoop(2)\nRotate(90,0,0)\nEnd\nScale(2,3)\nEnd\n```\n\nSample Output\n--\n\n```\n10.0000 -3.0000\n18.0000 15.0000\n-10.0000 6.0000\n```\n\nData Constraint\n--\n保证操作中坐标值不会超过double范围，输出不会超过int范围；\n\n指令总共不超过1000行；\n\n对于所有的数据,所有循环指令中m<=1000000；\n\n对于60%的数据,所有循环指令中m<=1000；\n\n对于30%的数据不含嵌套循环。\nAnalysis\n--\n看到这道题，首先想到的肯定是模拟。平移和缩放都是很简单的操作，比较麻烦的是旋转操作。据说有一个公式可以求任意点绕着原点逆时针旋转θrad的公式。\n![绕原点旋转公式](http://img.blog.csdn.net/20150821112509577)\n因为题目要求的是顺时针我们将角度取反再加上2πrad就好了。对于绕着任一点旋转，我们可以平移所有的点，使得给定的点与原点重合，套用公式计算，再把所有的平移回去。这样就可以通过暴力模拟拿到30%的分了。\n\n因为循环的次数非常大，而给出的指令又比较少，所以我们应该想办法将循环之间的状态保存下来然后快速的做n次。因为我们注意到题目中的变换是对于两个变量的线性递推，所以可以用矩阵来实现。而每做一次相当于矩阵自乘一次。因为矩阵具有结合律，所以自乘的操作通过快速幂来实现就好了。\n\n我们可以将每一种操作用矩阵表示出来，O(M)的扫一遍整个指令后将每个矩阵相乘，即可得到做完所有操作后的最终矩阵。然后，我们O(N)的将每一个点都与这个矩阵相乘就能得到这个点经过M次操作后的最终结果了。\n\n接下来就是如何构造矩阵的问题了。平移，缩放的矩阵构造相对简单。基本上是通过系数于变量相乘和相加而得，具体可看程序实现。(可以自己手动模拟模拟矩阵乘法的工作过程)\n比较难得就是旋转的矩阵构造。\n我们不需要将一个旋转命令拆成几个命令，这样子太麻烦。可以一步构造矩阵实现平移与绕远点旋转。\n我们假设图形中的一个点为(x,y)，绕(x0,y0)这个点顺时针旋转θrad(可以通过取反再加上一圈转换)，那么举例说明x'是如何得到的。\nx' = (x-x0)cosθ-(y-y0)sinθ+x0=cosθx-sinθy+sinθy0-cosθx0+x0\ny' = 同理可得\n最后的矩阵就是这样的：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | cosθ | sinθ | 0\n| 2 | -sinθ | cosθ |0\n| 3 | sinθ*y0-cosθ*x0+x0 | cosθ*y0-sin*x0+y0 |1\n对于每一个点构造矩阵：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | x | y | 0\n| 2 | 0 | 0 |0\n| 3 | 0 | 0 |0\n最后就可以在O(M)的时间过啦~~~\nCode\n--\n\n```\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define pi M_PI\n#define rad(x) x*pi/180\nusing namespace std;\n\nconst int N = 105 , M = 1005;\ntypedef double matrix[4][4];\nstruct node\n{\n\tdouble x,y,angle;\n\tint type,time;\n} a[M];\nstruct point\n{\n\tdouble x,y;\n} p[N];\nint n,m,top,stack[M],end[M];\nmatrix H;\nchar ch;\n\nvoid mul(matrix &a,matrix b)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int k=1;k<=3;k++)\n\t\tfor (int i=1;i<=3;i++)\n\t\t\tfor (int j=1;j<=3;j++)\n\t\t\t\tc[i][j] += a[i][k]*b[k][j];\n\tmemcpy(a,c,sizeof c);\n}\nvoid pow(matrix &a,int y)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int i=1;i<=3;i ++) c[i][i]=1;\n\twhile (y>0)\n\t{\n\t\tif (y & 1 == 1) mul(c,a);\n\t\tmul(a,a);\n\t\ty >>= 1;\n\t}\n\tmemcpy(a,c,sizeof c);\n}\nvoid work(int st,int en)\n{\n\tif (st>en) return;\n\tmatrix F,G;\n\tmemset(F,0,sizeof F);\n\tfor (int i=1;i<=3;i++) F[i][i] = 1;\n\tfor (int i=st;i<=en;i++)\n\t{\n\t\tmemset(G,0,sizeof G);\n\t\tif (a[i].type==1)\n\t\t{\n\t\t\tG[1][1] = 1;\n\t\t\tG[2][2] = 1;\n\t\t\tG[3][1] = a[i].x;\n\t\t\tG[3][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==2)\n\t\t{\n\t\t\tG[1][1] = a[i].x;\n\t\t\tG[2][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==3)\n\t\t{\n\t\t\ta[i].angle = 360 - a[i].angle;\n\t\t\tdouble co=cos(rad(a[i].angle)),si=sin(rad(a[i].angle));\n\t\t\tG[1][1] = co;\n\t\t\tG[1][2] = si;\n\t\t\tG[2][1] = -si;\n\t\t\tG[2][2] = co;\n\t\t\tG[3][1] = si*a[i].y-co*a[i].x+a[i].x;\n\t\t\tG[3][2] = -co*a[i].y-si*a[i].x+a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==4)\n\t\t{\n\t\t\twork(i+1,end[i]-1);\n\t\t\tpow(H,a[i].time);\n\t\t\tmul(F,H);\n\t\t\ti = end[i];\n\t\t}\n\n\t}\n\tmemcpy(H,F,sizeof F);\n}\nint main()\n{\n\tfreopen(\"transform.in\",\"r\",stdin);\n\tfreopen(\"transform.out\",\"w\",stdout);\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lf%lf\\n\",&p[i].x,&p[i].y);\n\twhile (scanf(\"%c\",&ch) != EOF)\n\t{\n\t\tm ++;\n\t\tif (ch=='T') a[m].type = 1,scanf(\"rans(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='S') a[m].type = 2,scanf(\"cale(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='R') a[m].type = 3,scanf(\"otate(%lf,%lf,%lf)\\n\",&a[m].angle,&a[m].x,&a[m].y);\n\t\tif (ch=='L') a[m].type = 4,scanf(\"oop(%d)\\n\",&a[m].time);\n\t\tif (ch=='E') a[m].type = 5,scanf(\"nd\\n\");\n\t}\n\n\tint top = 0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (a[i].type == 4) stack[++ top] = i;\n\t\tif (a[i].type == 5) end[stack[top --]] = i;\n\t}\n\twork(1,m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmatrix F;\n\t\tmemset(F,0,sizeof F);\n\t\tF[1][1] = p[i].x , F[1][2] = p[i].y , F[1][3] = 1;\n\t\tmul(F,H);\n\t\tprintf(\"%.4lf %.4lf\\n\",F[1][1],F[1][2]);\n\t}\n\treturn 0;\n}\n```","source":"_posts/图形变换-transform.md","raw":"---\ntitle: 图形变换(transform)\ndate: 2015-08-21 10:39:00\ntags:\n  - 题解\n  - 矩阵乘法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\n对一个由n个点组成的图形连续作平移、缩放、旋转变换。相关操作定义如下：\n\nTrans(dx,dy) 表示平移图形，即把图形上所有的点的横纵坐标分别加上dx和dy；\n\nScale(sx,sy) 表示缩放图形，即把图形上所有点的横纵坐标分别乘以sx和sy；\n\nRotate(θ,x0,y0) 表示旋转图形，即把图形上所有点的坐标绕(x0,y0)顺时针旋转θ角度\n\n由于某些操作会重复运行多次，还定义了循环指令：\n\nLoop(m)\n\n… \n\nEnd \n\n表示把Loop和对应End之间的操作循环执行m次，循环可以嵌套。\n\nInput\n--\n第一行一个整数n(n<=100)表示图形由n个点组成；\n\n接下来n行，每行空格隔开两个实数xi，yi表示点的坐标；\n\n接下来一直到文件结束，每行一条操作指令。保证指令格式合法，无多余空格。\nOutput\n--\n输出有n行，每行两个空格隔开实数xi，yi表示对应输入的点变换后的坐标。\n\n本题采用Special Judge判断，只要你输出的数值与标准答案误差不能超过1即可。\n\nSample Input\n--\n\n```\n3\n0.5 0\n2.5 2\n-4.5 1\nTrans(1.5,-1)\nLoop(2)\nTrans(1,1)\nLoop(2)\nRotate(90,0,0)\nEnd\nScale(2,3)\nEnd\n```\n\nSample Output\n--\n\n```\n10.0000 -3.0000\n18.0000 15.0000\n-10.0000 6.0000\n```\n\nData Constraint\n--\n保证操作中坐标值不会超过double范围，输出不会超过int范围；\n\n指令总共不超过1000行；\n\n对于所有的数据,所有循环指令中m<=1000000；\n\n对于60%的数据,所有循环指令中m<=1000；\n\n对于30%的数据不含嵌套循环。\nAnalysis\n--\n看到这道题，首先想到的肯定是模拟。平移和缩放都是很简单的操作，比较麻烦的是旋转操作。据说有一个公式可以求任意点绕着原点逆时针旋转θrad的公式。\n![绕原点旋转公式](http://img.blog.csdn.net/20150821112509577)\n因为题目要求的是顺时针我们将角度取反再加上2πrad就好了。对于绕着任一点旋转，我们可以平移所有的点，使得给定的点与原点重合，套用公式计算，再把所有的平移回去。这样就可以通过暴力模拟拿到30%的分了。\n\n因为循环的次数非常大，而给出的指令又比较少，所以我们应该想办法将循环之间的状态保存下来然后快速的做n次。因为我们注意到题目中的变换是对于两个变量的线性递推，所以可以用矩阵来实现。而每做一次相当于矩阵自乘一次。因为矩阵具有结合律，所以自乘的操作通过快速幂来实现就好了。\n\n我们可以将每一种操作用矩阵表示出来，O(M)的扫一遍整个指令后将每个矩阵相乘，即可得到做完所有操作后的最终矩阵。然后，我们O(N)的将每一个点都与这个矩阵相乘就能得到这个点经过M次操作后的最终结果了。\n\n接下来就是如何构造矩阵的问题了。平移，缩放的矩阵构造相对简单。基本上是通过系数于变量相乘和相加而得，具体可看程序实现。(可以自己手动模拟模拟矩阵乘法的工作过程)\n比较难得就是旋转的矩阵构造。\n我们不需要将一个旋转命令拆成几个命令，这样子太麻烦。可以一步构造矩阵实现平移与绕远点旋转。\n我们假设图形中的一个点为(x,y)，绕(x0,y0)这个点顺时针旋转θrad(可以通过取反再加上一圈转换)，那么举例说明x'是如何得到的。\nx' = (x-x0)cosθ-(y-y0)sinθ+x0=cosθx-sinθy+sinθy0-cosθx0+x0\ny' = 同理可得\n最后的矩阵就是这样的：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | cosθ | sinθ | 0\n| 2 | -sinθ | cosθ |0\n| 3 | sinθ*y0-cosθ*x0+x0 | cosθ*y0-sin*x0+y0 |1\n对于每一个点构造矩阵：\n| --|1 | 2 | 3 |\n| --|:-:| :|\n| 1 | x | y | 0\n| 2 | 0 | 0 |0\n| 3 | 0 | 0 |0\n最后就可以在O(M)的时间过啦~~~\nCode\n--\n\n```\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define pi M_PI\n#define rad(x) x*pi/180\nusing namespace std;\n\nconst int N = 105 , M = 1005;\ntypedef double matrix[4][4];\nstruct node\n{\n\tdouble x,y,angle;\n\tint type,time;\n} a[M];\nstruct point\n{\n\tdouble x,y;\n} p[N];\nint n,m,top,stack[M],end[M];\nmatrix H;\nchar ch;\n\nvoid mul(matrix &a,matrix b)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int k=1;k<=3;k++)\n\t\tfor (int i=1;i<=3;i++)\n\t\t\tfor (int j=1;j<=3;j++)\n\t\t\t\tc[i][j] += a[i][k]*b[k][j];\n\tmemcpy(a,c,sizeof c);\n}\nvoid pow(matrix &a,int y)\n{\n\tmatrix c;\n\tmemset(c,0,sizeof c);\n\tfor (int i=1;i<=3;i ++) c[i][i]=1;\n\twhile (y>0)\n\t{\n\t\tif (y & 1 == 1) mul(c,a);\n\t\tmul(a,a);\n\t\ty >>= 1;\n\t}\n\tmemcpy(a,c,sizeof c);\n}\nvoid work(int st,int en)\n{\n\tif (st>en) return;\n\tmatrix F,G;\n\tmemset(F,0,sizeof F);\n\tfor (int i=1;i<=3;i++) F[i][i] = 1;\n\tfor (int i=st;i<=en;i++)\n\t{\n\t\tmemset(G,0,sizeof G);\n\t\tif (a[i].type==1)\n\t\t{\n\t\t\tG[1][1] = 1;\n\t\t\tG[2][2] = 1;\n\t\t\tG[3][1] = a[i].x;\n\t\t\tG[3][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==2)\n\t\t{\n\t\t\tG[1][1] = a[i].x;\n\t\t\tG[2][2] = a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==3)\n\t\t{\n\t\t\ta[i].angle = 360 - a[i].angle;\n\t\t\tdouble co=cos(rad(a[i].angle)),si=sin(rad(a[i].angle));\n\t\t\tG[1][1] = co;\n\t\t\tG[1][2] = si;\n\t\t\tG[2][1] = -si;\n\t\t\tG[2][2] = co;\n\t\t\tG[3][1] = si*a[i].y-co*a[i].x+a[i].x;\n\t\t\tG[3][2] = -co*a[i].y-si*a[i].x+a[i].y;\n\t\t\tG[3][3] = 1;\n\t\t\tmul(F,G);\n\t\t}\n\t\tif (a[i].type==4)\n\t\t{\n\t\t\twork(i+1,end[i]-1);\n\t\t\tpow(H,a[i].time);\n\t\t\tmul(F,H);\n\t\t\ti = end[i];\n\t\t}\n\n\t}\n\tmemcpy(H,F,sizeof F);\n}\nint main()\n{\n\tfreopen(\"transform.in\",\"r\",stdin);\n\tfreopen(\"transform.out\",\"w\",stdout);\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lf%lf\\n\",&p[i].x,&p[i].y);\n\twhile (scanf(\"%c\",&ch) != EOF)\n\t{\n\t\tm ++;\n\t\tif (ch=='T') a[m].type = 1,scanf(\"rans(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='S') a[m].type = 2,scanf(\"cale(%lf,%lf)\\n\",&a[m].x,&a[m].y);\n\t\tif (ch=='R') a[m].type = 3,scanf(\"otate(%lf,%lf,%lf)\\n\",&a[m].angle,&a[m].x,&a[m].y);\n\t\tif (ch=='L') a[m].type = 4,scanf(\"oop(%d)\\n\",&a[m].time);\n\t\tif (ch=='E') a[m].type = 5,scanf(\"nd\\n\");\n\t}\n\n\tint top = 0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (a[i].type == 4) stack[++ top] = i;\n\t\tif (a[i].type == 5) end[stack[top --]] = i;\n\t}\n\twork(1,m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmatrix F;\n\t\tmemset(F,0,sizeof F);\n\t\tF[1][1] = p[i].x , F[1][2] = p[i].y , F[1][3] = 1;\n\t\tmul(F,H);\n\t\tprintf(\"%.4lf %.4lf\\n\",F[1][1],F[1][2]);\n\t}\n\treturn 0;\n}\n```","slug":"图形变换-transform","published":1,"updated":"2015-12-25T10:44:05.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnv8w000yigtgk3thkqiu","sticky":0},{"title":"信息学程序模板","date":"2015-11-06T03:52:00.000Z","_content":"tarjan\n<script src=\"https://code.csdn.net/snippets/1310789.js\"></script> \n\n拓扑排序\n<script src=\"https://code.csdn.net/snippets/1310702.js\"></script> \n\n\n\n最小生成树 && 并查集\n<script src=\"https://code.csdn.net/snippets/1310674.js\"></script> \n\n\n\n快速幂\n<script src=\"https://code.csdn.net/snippets/1310653.js\"></script> \n\n\n\nLCA\n<script src=\"https://code.csdn.net/snippets/1310621.js\"></script> \n\n\n\ndijkstra\n<script src=\"https://code.csdn.net/snippets/1310589.js\"></script> \n\n\nspfa\n<script src=\"https://code.csdn.net/snippets/1310489.js\"></script> \n\n\nsort\n<script src=\"https://code.csdn.net/snippets/1310393.js\"></script> \n\n\n网络流最大流sap\n<script src=\"https://code.csdn.net/snippets/1375597.js\"></script> \n\ntri树\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int N = 300005, M = 4000005;\nstruct node\n{\n\tnode(){len = -1;}\n\tbool num;\n\tint len;\n\tint next,dep;\n\tint s[26];\n} h[M];\nint n,m,tot;\nint a[N],f[N];\nchar s[N];\nqueue <int> Q;\n\nvoid init()\n{\n\tscanf(\"%d\\n%s\\n%d\",&n,s,&m);\n\tfor (int i=0;i<n;i ++) a[i] = s[i] - 'a';\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint len = strlen(s),now = 0;\n\t\tfor (int j=0;j<len;j ++)\n\t\t{\n\t\t\tif (!h[now].s[s[j]-'a'])\n\t\t\t\th[now].s[s[j]-'a'] = ++ tot;\n\t\t\tnow = h[now].s[s[j]-'a'];\n\t\t}\n\t\th[now].num = 1;\n\t}\n\t//普通建tri\n\tfor (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);\n\t\n\tfor (int x=Q.front();!Q.empty();x=Q.front())\n\t{\n\t\tQ.pop();\n\t\tfor (int j=0;j<26;j ++)\n\t\t\tif (h[x].s[j])\n\t\t\t{\n\t\t\t\tint y = h[x].s[j];\n\t\t\t\th[y].next = h[h[x].next].s[j];\n\t\t\t\th[y].dep = h[x].dep + 1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t\telse h[x].s[j] = h[h[x].next].s[j];\n\t\tif (h[x].num) h[x].len = h[x].dep;\n\t\tif (h[x].len<0) h[x].len = h[h[x].next].len;\n\t}\n\t//求fail指针\n}\n\nvoid work()\n{\n\tfor (int i=0,x=0;i<n;i ++)\n\t{\n\t\tx = h[x].s[a[i]];\n\t\tif (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];\n\t}\n\tint ans = 0;\n\tfor (int i=0,sum = 0;i<n;i ++)\n\t\tsum += f[i],ans += !sum;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\t//freopen(\"3172.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n```","source":"_posts/信息学程序模板.md","raw":"---\ntitle: 信息学程序模板\ndate: 2015-11-06 11:52:00\ntags:\n  - 模板\ncategories:\n  - 信息学\n  - 原创\n---\ntarjan\n<script src=\"https://code.csdn.net/snippets/1310789.js\"></script> \n\n拓扑排序\n<script src=\"https://code.csdn.net/snippets/1310702.js\"></script> \n\n\n\n最小生成树 && 并查集\n<script src=\"https://code.csdn.net/snippets/1310674.js\"></script> \n\n\n\n快速幂\n<script src=\"https://code.csdn.net/snippets/1310653.js\"></script> \n\n\n\nLCA\n<script src=\"https://code.csdn.net/snippets/1310621.js\"></script> \n\n\n\ndijkstra\n<script src=\"https://code.csdn.net/snippets/1310589.js\"></script> \n\n\nspfa\n<script src=\"https://code.csdn.net/snippets/1310489.js\"></script> \n\n\nsort\n<script src=\"https://code.csdn.net/snippets/1310393.js\"></script> \n\n\n网络流最大流sap\n<script src=\"https://code.csdn.net/snippets/1375597.js\"></script> \n\ntri树\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int N = 300005, M = 4000005;\nstruct node\n{\n\tnode(){len = -1;}\n\tbool num;\n\tint len;\n\tint next,dep;\n\tint s[26];\n} h[M];\nint n,m,tot;\nint a[N],f[N];\nchar s[N];\nqueue <int> Q;\n\nvoid init()\n{\n\tscanf(\"%d\\n%s\\n%d\",&n,s,&m);\n\tfor (int i=0;i<n;i ++) a[i] = s[i] - 'a';\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint len = strlen(s),now = 0;\n\t\tfor (int j=0;j<len;j ++)\n\t\t{\n\t\t\tif (!h[now].s[s[j]-'a'])\n\t\t\t\th[now].s[s[j]-'a'] = ++ tot;\n\t\t\tnow = h[now].s[s[j]-'a'];\n\t\t}\n\t\th[now].num = 1;\n\t}\n\t//普通建tri\n\tfor (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);\n\t\n\tfor (int x=Q.front();!Q.empty();x=Q.front())\n\t{\n\t\tQ.pop();\n\t\tfor (int j=0;j<26;j ++)\n\t\t\tif (h[x].s[j])\n\t\t\t{\n\t\t\t\tint y = h[x].s[j];\n\t\t\t\th[y].next = h[h[x].next].s[j];\n\t\t\t\th[y].dep = h[x].dep + 1;\n\t\t\t\tQ.push(y);\n\t\t\t}\n\t\t\telse h[x].s[j] = h[h[x].next].s[j];\n\t\tif (h[x].num) h[x].len = h[x].dep;\n\t\tif (h[x].len<0) h[x].len = h[h[x].next].len;\n\t}\n\t//求fail指针\n}\n\nvoid work()\n{\n\tfor (int i=0,x=0;i<n;i ++)\n\t{\n\t\tx = h[x].s[a[i]];\n\t\tif (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];\n\t}\n\tint ans = 0;\n\tfor (int i=0,sum = 0;i<n;i ++)\n\t\tsum += f[i],ans += !sum;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\t//freopen(\"3172.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\tinit();\n\twork();\n\n\treturn 0;\n}\n```","slug":"信息学程序模板","published":1,"updated":"2016-01-05T09:07:17.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnv910013igtgt5mmfvkz","sticky":0},{"title":"使用七牛云存储作个人博客图床","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2014/11/25/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/使用七牛云存储作个人博客图床.md","raw":"---\ntitle: 使用七牛云存储作个人博客图床\ntags:\n  - 工具\ncategories:\n  - 互联网\n  - 转载\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2014/11/25/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/\"><title></title></head><body></body></html>\n转载文章","slug":"使用七牛云存储作个人博客图床","published":1,"date":"2015-12-21T11:07:53.355Z","updated":"2015-12-21T11:07:53.355Z","layout":"post","photos":[],"link":"","_id":"cijvfnv9h0018igtgh9tpvrb1","sticky":0},{"title":"从头到尾彻底理解KMP","comments":0,"_content":"<a href=\"http://blog.csdn.net/v_july_v/article/details/7041827\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://blog.csdn.net/v_july_v/article/details/7041827\"><title></title></head><body></body></html>\n","source":"_posts/从头到尾彻底理解KMP.md","raw":"---\ntitle: 从头到尾彻底理解KMP\ntags:\n  - KMP\ncategories:\n  - 信息学\n  - 转载\ncomments: false\n---\n<a href=\"http://blog.csdn.net/v_july_v/article/details/7041827\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://blog.csdn.net/v_july_v/article/details/7041827\"><title></title></head><body></body></html>\n","slug":"从头到尾彻底理解KMP","published":1,"date":"2015-12-22T09:54:54.740Z","updated":"2015-12-22T09:54:54.740Z","layout":"post","photos":[],"link":"","_id":"cijvfnv9t001figtg9wzebcn3","sticky":0},{"title":"五校联考7 总结","date":"2015-10-27T14:18:00.000Z","_content":"Day1\n==\nT1：上三角行列式 \n--\n简单的模拟判断题，但是考试时没注意一点元素的大小是|绝对值|≤10000,当累乘的值是个负数时是不可以取模的。而我并没有判断这种情况，但因为数据太水，还是过了。\n\nT2：n染色\n--\n这道题是一道数学题，考试时并没有推出公式，在隔壁LB的提示下得出了递推公式。然后在运用高中数列知识，将它化为通项公式，再用快速幂等算法的出答案。当然，此题还有很多种解法，也并不需要什么递推公式。考试时是过了的。\n\nT3：游戏 \n--\n这题考试时没有仔细研究，所以拿了60分的部分分。60分是一个O(N^2)的简单dp。后面需要仔细研究一道题。100分有一个巧妙的算法，可以严格O(N)线性解决这道题。\n\nDay2\n==\nT1：QYQ的字符串\n--\n初看此题觉得很难，只会暴力，结果后面发现暴力是可以过的......\n\nT2：QYQ的图\n--\n这道题想不到特别好的算法，想着打了一个搜索 ，枚举哪些点不选。最后题解就是这个方法。我应该是搜索判断选点的时候处理不好，判断方法错了。\n\nT3：QYQ的图\n--\n没有想到特别好的方法，题解是dp。因为dp一直是我的弱项，况且有时候还不知道题目能否dp。所以需要恶补一下才行。","source":"_posts/五校联考7-总结.md","raw":"---\ntitle: 五校联考7 总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-27 22:18:00\n---\nDay1\n==\nT1：上三角行列式 \n--\n简单的模拟判断题，但是考试时没注意一点元素的大小是|绝对值|≤10000,当累乘的值是个负数时是不可以取模的。而我并没有判断这种情况，但因为数据太水，还是过了。\n\nT2：n染色\n--\n这道题是一道数学题，考试时并没有推出公式，在隔壁LB的提示下得出了递推公式。然后在运用高中数列知识，将它化为通项公式，再用快速幂等算法的出答案。当然，此题还有很多种解法，也并不需要什么递推公式。考试时是过了的。\n\nT3：游戏 \n--\n这题考试时没有仔细研究，所以拿了60分的部分分。60分是一个O(N^2)的简单dp。后面需要仔细研究一道题。100分有一个巧妙的算法，可以严格O(N)线性解决这道题。\n\nDay2\n==\nT1：QYQ的字符串\n--\n初看此题觉得很难，只会暴力，结果后面发现暴力是可以过的......\n\nT2：QYQ的图\n--\n这道题想不到特别好的算法，想着打了一个搜索 ，枚举哪些点不选。最后题解就是这个方法。我应该是搜索判断选点的时候处理不好，判断方法错了。\n\nT3：QYQ的图\n--\n没有想到特别好的方法，题解是dp。因为dp一直是我的弱项，况且有时候还不知道题目能否dp。所以需要恶补一下才行。","slug":"五校联考7-总结","published":1,"updated":"2015-12-25T11:00:34.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnva3001ligtgqdajjd2b","sticky":0},{"title":"【转载】表达式求值问题","date":"2015-11-06T02:55:00.000Z","_content":"\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","source":"_posts/【转载】表达式求值问题.md","raw":"title: 【转载】表达式求值问题\ntags: \ncategories: [信息学,转载]\ndate: 2015-11-06 10:55\n---\n\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","slug":"【转载】表达式求值问题","published":1,"updated":"2015-12-19T06:29:41.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvab001pigtgr8yy8tts","sticky":0},{"title":"【转载】有向图强连通分量的Tarjan算法","date":"2015-10-29T09:15:00.000Z","_content":"<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","source":"_posts/【转载】有向图强连通分量的Tarjan算法.md","raw":"title: 【转载】有向图强连通分量的Tarjan算法\ntags: \ncategories: [信息学,转载]\ndate: 2015-10-29 17:15\n---\n<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","slug":"【转载】有向图强连通分量的Tarjan算法","published":1,"updated":"2015-12-19T06:30:14.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvaf001sigtgnxs12xbg","sticky":0},{"date":"2015-08-16T12:54:00.000Z","title":"【NOIP】独立集(bubble)","_content":"Tips\n--\n题目来源：http://www.luo.hustoj.com/problem.php?id=1287\n\nAnalysis\n--\n从这个顺(dou)旺(bi)基同学的代码中，我们发现他的算法实际上是给逆序对连边，而独立集所在的集合中，任意两个都不存在连边(即不是逆序对)，那就是顺序的。并且题目要求我们要找出一个最大的独立集，求出他的长度，那就是要我们求最长不下降子序列，而因为给出的n个数是全排列。所以就是求最长上升子序列。这个可以用(nlogn)的二分查找求出。最关键的就是怎么求第二问最长上升子序列中那些点是必选的。\n\n首先我们从左往右做一遍最长上升子序列，并得到他的数组f。f[i]表示以i结尾在[1..i]中的最长下上升子序列的长度\n同样我们从右往左最一遍最长下降子序列，并得到他的数组g。g[i]表示以i为结尾的在[i..n]中的最长下降子序列。\n\nans1表示第一个答案（即最长上升子序列）的值\n当f[i]+g[i]-1=ans1时，就说明这个点在其中一个最长上升子序列中（但不是第二题的合法位置）。所以我们要从这些点中找出唯一的点。如果在ans2的数组中发现一个位置有两个人已经使用过了，那么这个位置的答案就是不合法的。\n\n我们来看一下下面这个例子：\n\n\n**i      1  2  3  4  5**\n**a[i]  5  1  3  2  4**\n**f[i]   1  1  2  2  3**\n**g[i]  1  3  2  2  1**\n\nans1=3\n其中，2 3 4 5都是任意最长上升子序列中的一部分，但是因为2 与 3 的f值重复了，所以这两个点就不是答案了。\n\n现在还有一个问题就是如何快速的得到f和g数组。然而网上的O(N log N)只支持求长度而不能得到每一个f或g的值。而O(N^2)的算法又太慢了。因为这道题有一个关键的条件那就是：\n\t输入的数据是全排列\n所以我们可以从左往右求f值，将每一个f值塞入到线段数的叶子[a[i],a[i]]中然后维护线段树的最大值，当计算下一个f[i]的值时，就询问线段书[1,a[i]]的区间中的最大值,将得到的最大值+1就是当前的f[i]值，重复这样的操作就的合法的f序列。正确性显然。\n当你从左往右添加时，由于在右边的f[i]值并没有塞入线段数中，所以询问[1,a[i]]时并不会得到那些f值，只有已经在i前面的f值才能得到，并且这些f值所对应的a[j]都要比a[i]小。就与O(n^2)的算法转移类似。具体实现可看代码。\nCode\n--\n然而此题并不需要如此复杂的线段树，只要支持单点修改和区间查询最大值即可。当然如果你有能力完全可以写树状数组。\n```\nuses\tmath;\nconst\tmaxn=100000;\nvar\ti,n,maxx:longint;\n\th:array[1..4*maxn,1..2] of longint;\n\ta,g,f,ans:array[1..maxn] of longint;\nprocedure change(x,l,r,st,en,val:longint);\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\tinc(h[x,1],val);inc(h[x,2],val);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then change(x+x,l,mid,st,en,val)\n\t\telse if st>mid then change(x+x+1,mid+1,r,st,en,val)\n\t\telse begin\n\t\t\tchange(x+x,l,mid,st,mid,val);\n\t\t\tchange(x+x+1,mid+1,r,mid+1,en,val);\n\t\tend;\n\t\th[x,1]:=max(h[x+x,1],h[x+x+1,1]);\n\tend;\nend;\nfunction quary(x,l,r,st,en:longint):longint;\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\texit(h[x,1]);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then exit(quary(x+x,l,mid,st,en))\n\t\telse if st>mid then exit(quary(x+x+1,mid+1,r,st,en))\n\t\telse\n\t\texit(max(quary(x+x,l,mid,st,mid),quary(x+x+1,mid+1,r,mid+1,en)));\n\tend;\nend;\nbegin\n\t//assign(input,'3485.in');reset(input);\n\n\treadln(n);\n\tfor i:=1 to n do read(a[i]);\n\n\tmaxx:=0;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=1 to n do begin\n\t\tf[i]:=quary(1,1,n,1,a[i])+1;\n\t\tchange(1,1,n,a[i],a[i],f[i]);\n\t\tmaxx:=max(maxx,f[i]);\n\tend;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=n downto 1 do begin\n\t\tg[i]:=quary(1,1,n,a[i],n)+1;\n\t\tchange(1,1,n,a[i],a[i],g[i]);\n\tend;\n\tfor i:=1 to n do begin\n\t\tif (f[i]+g[i]-1=maxx) then begin\n\t\t\tif (ans[f[i]]>0) or (ans[f[i]]=-1) then \n\t\t\t\tans[f[i]]:=-1 \n\t\t\telse ans[f[i]]:=i;\n\t\tend;\n\tend;\n\twriteln(maxx);\n\tfor i:=1 to maxx do \n\t\tif ans[i]>0 then write(ans[i],' ');\n\twriteln;\nend.\n\n```","source":"_posts/【NOIP】独立集-bubble.md","raw":"---\ndate: 2015-08-16 20:54:00\ntitle: 【NOIP】独立集(bubble)\ntags:\n  - 题解\n  - 线段树\ncategories:\n  - 信息学\n  - 原创\n---\nTips\n--\n题目来源：http://www.luo.hustoj.com/problem.php?id=1287\n\nAnalysis\n--\n从这个顺(dou)旺(bi)基同学的代码中，我们发现他的算法实际上是给逆序对连边，而独立集所在的集合中，任意两个都不存在连边(即不是逆序对)，那就是顺序的。并且题目要求我们要找出一个最大的独立集，求出他的长度，那就是要我们求最长不下降子序列，而因为给出的n个数是全排列。所以就是求最长上升子序列。这个可以用(nlogn)的二分查找求出。最关键的就是怎么求第二问最长上升子序列中那些点是必选的。\n\n首先我们从左往右做一遍最长上升子序列，并得到他的数组f。f[i]表示以i结尾在[1..i]中的最长下上升子序列的长度\n同样我们从右往左最一遍最长下降子序列，并得到他的数组g。g[i]表示以i为结尾的在[i..n]中的最长下降子序列。\n\nans1表示第一个答案（即最长上升子序列）的值\n当f[i]+g[i]-1=ans1时，就说明这个点在其中一个最长上升子序列中（但不是第二题的合法位置）。所以我们要从这些点中找出唯一的点。如果在ans2的数组中发现一个位置有两个人已经使用过了，那么这个位置的答案就是不合法的。\n\n我们来看一下下面这个例子：\n\n\n**i      1  2  3  4  5**\n**a[i]  5  1  3  2  4**\n**f[i]   1  1  2  2  3**\n**g[i]  1  3  2  2  1**\n\nans1=3\n其中，2 3 4 5都是任意最长上升子序列中的一部分，但是因为2 与 3 的f值重复了，所以这两个点就不是答案了。\n\n现在还有一个问题就是如何快速的得到f和g数组。然而网上的O(N log N)只支持求长度而不能得到每一个f或g的值。而O(N^2)的算法又太慢了。因为这道题有一个关键的条件那就是：\n\t输入的数据是全排列\n所以我们可以从左往右求f值，将每一个f值塞入到线段数的叶子[a[i],a[i]]中然后维护线段树的最大值，当计算下一个f[i]的值时，就询问线段书[1,a[i]]的区间中的最大值,将得到的最大值+1就是当前的f[i]值，重复这样的操作就的合法的f序列。正确性显然。\n当你从左往右添加时，由于在右边的f[i]值并没有塞入线段数中，所以询问[1,a[i]]时并不会得到那些f值，只有已经在i前面的f值才能得到，并且这些f值所对应的a[j]都要比a[i]小。就与O(n^2)的算法转移类似。具体实现可看代码。\nCode\n--\n然而此题并不需要如此复杂的线段树，只要支持单点修改和区间查询最大值即可。当然如果你有能力完全可以写树状数组。\n```\nuses\tmath;\nconst\tmaxn=100000;\nvar\ti,n,maxx:longint;\n\th:array[1..4*maxn,1..2] of longint;\n\ta,g,f,ans:array[1..maxn] of longint;\nprocedure change(x,l,r,st,en,val:longint);\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\tinc(h[x,1],val);inc(h[x,2],val);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then change(x+x,l,mid,st,en,val)\n\t\telse if st>mid then change(x+x+1,mid+1,r,st,en,val)\n\t\telse begin\n\t\t\tchange(x+x,l,mid,st,mid,val);\n\t\t\tchange(x+x+1,mid+1,r,mid+1,en,val);\n\t\tend;\n\t\th[x,1]:=max(h[x+x,1],h[x+x+1,1]);\n\tend;\nend;\nfunction quary(x,l,r,st,en:longint):longint;\nvar\tmid:longint;\nbegin\n\tif (l=st) and (r=en) then begin\n\t\texit(h[x,1]);\n\tend else begin\n\t\tinc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]);\n\t\tinc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]);\n\t\th[x,2]:=0;\n\t\tmid:=(l+r)>>1;\n\t\tif en<=mid then exit(quary(x+x,l,mid,st,en))\n\t\telse if st>mid then exit(quary(x+x+1,mid+1,r,st,en))\n\t\telse\n\t\texit(max(quary(x+x,l,mid,st,mid),quary(x+x+1,mid+1,r,mid+1,en)));\n\tend;\nend;\nbegin\n\t//assign(input,'3485.in');reset(input);\n\n\treadln(n);\n\tfor i:=1 to n do read(a[i]);\n\n\tmaxx:=0;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=1 to n do begin\n\t\tf[i]:=quary(1,1,n,1,a[i])+1;\n\t\tchange(1,1,n,a[i],a[i],f[i]);\n\t\tmaxx:=max(maxx,f[i]);\n\tend;\n\tfillchar(h,sizeof(h),0);\n\tfor i:=n downto 1 do begin\n\t\tg[i]:=quary(1,1,n,a[i],n)+1;\n\t\tchange(1,1,n,a[i],a[i],g[i]);\n\tend;\n\tfor i:=1 to n do begin\n\t\tif (f[i]+g[i]-1=maxx) then begin\n\t\t\tif (ans[f[i]]>0) or (ans[f[i]]=-1) then \n\t\t\t\tans[f[i]]:=-1 \n\t\t\telse ans[f[i]]:=i;\n\t\tend;\n\tend;\n\twriteln(maxx);\n\tfor i:=1 to maxx do \n\t\tif ans[i]>0 then write(ans[i],' ');\n\twriteln;\nend.\n\n```","slug":"【NOIP】独立集-bubble","published":1,"updated":"2015-12-25T10:31:27.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvam001vigtg2qx6bfov","sticky":0},{"title":"【NOIP】总结 10.30晚-11.5","date":"2015-11-06T01:05:00.000Z","_content":"**10.30晚**\n--\n**概述**\n一定要用心想算法，在没想清楚之前，不要轻易打程序，不然后面耗的时间会更多\n\n**第一题**：没有细想，直接上暴力。发现暴力跑的挺快的，只有在某些特殊数据下跑的比较慢。要是细想不难发现规律，但还是有很多小细节需要注意。\n\n**第二题**：打了一个非常恶心的暴力，没有细致计算时间复杂度，最后发现好像连30%的数据都过不去。于是看了看数据范围，反过来想考察算法的时间复杂度。最后想到正解了。本来正解是对的，但因为题目描述和自己理解的一点偏差，将正解改成和暴力一样是错的了。\n下次一定要认真细致的看题！！！\n\n**第三题**：斜率优化，比较难想，也比较难打。因为时间原因，直接打了暴力。\n\n**11.2**\n--\n**概述**\n这套题做的很差，都不知道自己考试时在想什么。花了2.5小时打完了所有题的暴力，就陷入了无尽的思考，最后卡在了第二题中不靠谱的位运算优化，直到考试结束依旧没有调出来。时间分配不够合理。\n\n**T1：复制&粘贴2** \n这题其实很简单要有分离的思想，单个字符单个字符想。当看到特殊的数据范围是要注意。考试时只想到将整体的字符串移动，没有想到可以拆开，从后往前做。\n俗话说得好：正难则反，多角度思考。\n\n**T2:愉快的logo设计**\n题目有很好的匹配性质，然而我并没有注意到这一点，反而像另一个方向想（位运算），以致于大部分时间耗在了这道题上。\n\n**T3:有趣的有趣的家庭菜园**\n没有想到正解，就打了个纯暴力，但不知道为何只有9分，判断方式可能有问题。\n\n**11.2晚**\n--\n**概述**\n对自己的算法不要过度自信，一定想到一种在最坏情况下都可过的算法。\n\n**T1:Lala买面包** \n一开始看题目感觉挺简单，就往质因数分解的方向想了。最后面算了一下最坏的时间复杂度，觉得应该比较难构造这样的数据卡我的程序，在随机数测试下表现良好。实际上我想错了。其实我也有朝其他方面想，但是因为不想放弃这种方法，其他想法想的不多。其实真正的YES情况是很少的完全可以预处理出来，然后O(1)判断。\n\n**T2：我的天** \n想了很长一段时间，觉得这题应该用线段树，但是想不到模型转换。\n\n**T3:舳舻牌** \n最怕这种博弈论的题了，当时随便想了一下部分最优解，就打了，骗了5分。\n\n\n**11.3**\n--\n**概述**\n整套题都没什么感觉。觉得整个试题难度挺大的。\n\n**T1：装饰大楼**\n这题首先要观察规律，然后直接计算就好了，我模拟操作太慢了（因为怕错）。\n\n**T2:备用钥匙** \n把题目映射到时间轴后，就想不到其他得了，只能暴力\n\n**T3：IOIOI卡片占卜** \n没什么特别好的想法，那就暴力咯！\n\n\n**11.3晚**\n--\n**概述：**\n这套题基本上能拿的分都拿了。\n\n**T1:次芝麻** \n一开始发现数据有循环节，认为应该从第一位开始循环。后来发现错了。\n其实这题要大胆猜想，他就是不断乘2 mod (n+m)的结果，证明一下发现是可行的。\n这题因为在循环节上耗了太多的时间所以不划算。\n\n**T2：喝喝喝** \n这题想的时间最长，我因为将问题分成了两个自问题来单独考虑，而没有思考这两个子问题的相通性。考试时想到了50%做法，但是程序实现起来太繁琐，再加上时间也不是很够就没打。\n\n**T3:长寿花** \n这题的第一个限制很好做，但是加上了第二个限制就难了。本来我就不擅长推公式，打20%暴力就完了。\n\n\n**11.4**\n--\n**概述：**\n不要不屑于打暴力，有时候暴力也是可以过的。\n\n**T1：格点统计** \n观察一下就可以了O（$sqrt(n)$），注意一下细节。\n\n**T2:电话线铺设** \n考试时想到了正解，但已经没有时间打了。从数据范围推算法复杂度，很好想到正解。\n\n**T3：老司机**\n这题没有考虑到暴力可以过，而我打的暴力，太暴力。所以过的不多。\n\n**11.5**\n--\nNOIP模拟考的最后一试...\n**概述：**\n多思考，认真审题，当题目有些比较特殊的描述时，要细想性质。\n\n**T1：俄罗斯套娃** \n看一下就知道之前做过跟它类似的，还比这难的题。回忆一下，不难写出dp方程。\n\n**T2：Lucas的数列** \n一看就知道是线段树的题目，但是想来想去没仔细往离线方向想，其实这种有两种限制的题目（边做边加）以前做的多了，但考试时就是没有想到\n\n**T3：旅行**\n这题被我想复杂了，用了比较常用的求LCA的方法来做。但是因为没有开long long 爆类型了。其实这道题并没有那么复杂，只要用心观察题目给的特殊性质。就可以发现规律，发现规律后就非常的简单了。\n\n**T4：Xor** \n首先暴力就有30%，随便乱搞就有50%，数据非常的良心，100%的数据也不难，关键是要发现xor的实质，两个数对应的二进制位不同才可以的到更大的xor值，朝这个方向建一颗tri树就好了。","source":"_posts/【NOIP】总结-10-30晚-11-5.md","raw":"---\ntitle: 【NOIP】总结 10.30晚-11.5\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-06 09:05:00\n---\n**10.30晚**\n--\n**概述**\n一定要用心想算法，在没想清楚之前，不要轻易打程序，不然后面耗的时间会更多\n\n**第一题**：没有细想，直接上暴力。发现暴力跑的挺快的，只有在某些特殊数据下跑的比较慢。要是细想不难发现规律，但还是有很多小细节需要注意。\n\n**第二题**：打了一个非常恶心的暴力，没有细致计算时间复杂度，最后发现好像连30%的数据都过不去。于是看了看数据范围，反过来想考察算法的时间复杂度。最后想到正解了。本来正解是对的，但因为题目描述和自己理解的一点偏差，将正解改成和暴力一样是错的了。\n下次一定要认真细致的看题！！！\n\n**第三题**：斜率优化，比较难想，也比较难打。因为时间原因，直接打了暴力。\n\n**11.2**\n--\n**概述**\n这套题做的很差，都不知道自己考试时在想什么。花了2.5小时打完了所有题的暴力，就陷入了无尽的思考，最后卡在了第二题中不靠谱的位运算优化，直到考试结束依旧没有调出来。时间分配不够合理。\n\n**T1：复制&粘贴2** \n这题其实很简单要有分离的思想，单个字符单个字符想。当看到特殊的数据范围是要注意。考试时只想到将整体的字符串移动，没有想到可以拆开，从后往前做。\n俗话说得好：正难则反，多角度思考。\n\n**T2:愉快的logo设计**\n题目有很好的匹配性质，然而我并没有注意到这一点，反而像另一个方向想（位运算），以致于大部分时间耗在了这道题上。\n\n**T3:有趣的有趣的家庭菜园**\n没有想到正解，就打了个纯暴力，但不知道为何只有9分，判断方式可能有问题。\n\n**11.2晚**\n--\n**概述**\n对自己的算法不要过度自信，一定想到一种在最坏情况下都可过的算法。\n\n**T1:Lala买面包** \n一开始看题目感觉挺简单，就往质因数分解的方向想了。最后面算了一下最坏的时间复杂度，觉得应该比较难构造这样的数据卡我的程序，在随机数测试下表现良好。实际上我想错了。其实我也有朝其他方面想，但是因为不想放弃这种方法，其他想法想的不多。其实真正的YES情况是很少的完全可以预处理出来，然后O(1)判断。\n\n**T2：我的天** \n想了很长一段时间，觉得这题应该用线段树，但是想不到模型转换。\n\n**T3:舳舻牌** \n最怕这种博弈论的题了，当时随便想了一下部分最优解，就打了，骗了5分。\n\n\n**11.3**\n--\n**概述**\n整套题都没什么感觉。觉得整个试题难度挺大的。\n\n**T1：装饰大楼**\n这题首先要观察规律，然后直接计算就好了，我模拟操作太慢了（因为怕错）。\n\n**T2:备用钥匙** \n把题目映射到时间轴后，就想不到其他得了，只能暴力\n\n**T3：IOIOI卡片占卜** \n没什么特别好的想法，那就暴力咯！\n\n\n**11.3晚**\n--\n**概述：**\n这套题基本上能拿的分都拿了。\n\n**T1:次芝麻** \n一开始发现数据有循环节，认为应该从第一位开始循环。后来发现错了。\n其实这题要大胆猜想，他就是不断乘2 mod (n+m)的结果，证明一下发现是可行的。\n这题因为在循环节上耗了太多的时间所以不划算。\n\n**T2：喝喝喝** \n这题想的时间最长，我因为将问题分成了两个自问题来单独考虑，而没有思考这两个子问题的相通性。考试时想到了50%做法，但是程序实现起来太繁琐，再加上时间也不是很够就没打。\n\n**T3:长寿花** \n这题的第一个限制很好做，但是加上了第二个限制就难了。本来我就不擅长推公式，打20%暴力就完了。\n\n\n**11.4**\n--\n**概述：**\n不要不屑于打暴力，有时候暴力也是可以过的。\n\n**T1：格点统计** \n观察一下就可以了O（$sqrt(n)$），注意一下细节。\n\n**T2:电话线铺设** \n考试时想到了正解，但已经没有时间打了。从数据范围推算法复杂度，很好想到正解。\n\n**T3：老司机**\n这题没有考虑到暴力可以过，而我打的暴力，太暴力。所以过的不多。\n\n**11.5**\n--\nNOIP模拟考的最后一试...\n**概述：**\n多思考，认真审题，当题目有些比较特殊的描述时，要细想性质。\n\n**T1：俄罗斯套娃** \n看一下就知道之前做过跟它类似的，还比这难的题。回忆一下，不难写出dp方程。\n\n**T2：Lucas的数列** \n一看就知道是线段树的题目，但是想来想去没仔细往离线方向想，其实这种有两种限制的题目（边做边加）以前做的多了，但考试时就是没有想到\n\n**T3：旅行**\n这题被我想复杂了，用了比较常用的求LCA的方法来做。但是因为没有开long long 爆类型了。其实这道题并没有那么复杂，只要用心观察题目给的特殊性质。就可以发现规律，发现规律后就非常的简单了。\n\n**T4：Xor** \n首先暴力就有30%，随便乱搞就有50%，数据非常的良心，100%的数据也不难，关键是要发现xor的实质，两个数对应的二进制位不同才可以的到更大的xor值，朝这个方向建一颗tri树就好了。","slug":"【NOIP】总结-10-30晚-11-5","published":1,"updated":"2015-12-25T11:00:17.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvaq0020igtgi6ieq6ci","sticky":0},{"title":"【NOIP】剑与魔法(dragons)","date":"2015-08-16T11:56:00.000Z","_content":"\nDescription\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```pascal\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","source":"_posts/【NOIP】剑与魔法(dragons).md","raw":"---\ntitle: 【NOIP】剑与魔法(dragons)\ntags: [题解]\ncategories: [信息学,原创]\ndate: 2015-08-16 19:56\n---\n\nDescription\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```pascal\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","slug":"【NOIP】剑与魔法(dragons)","published":1,"updated":"2015-12-19T06:27:49.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvba0024igtg793nh9dd","sticky":0},{"title":"【NOIP】11.13-11.14总结","date":"2015-10-29T09:25:00.000Z","_content":"<strong>DAY1\n--\n这次考试时间的分配和程序调试方面都有待加强\n\nT1:题目比较简单，很容易理解。写了个六重循环暴力，没有想到特别好的方法。本来可以加区间累加优化，怕写错就没加。还是拿了60。\n这题用二分答案很好打，只不过要注意判断。一开始我将所有蛋糕块的巧克力都求出来最后判大小，超时！！直接判可以减少不少时间。\n\nT2:一看没有什么思路，在纸上画了下草稿，发现有一条必经之路，每个节点都可以转到这条路的任意一个节点，求它到其他个点的最短距离。想法还是可以的。但是，在调程序时，因为太复杂始终没调处来就放弃了。\n\nT3:根据样例解释和数据范围，结合题目意思，很容易就知道对于每个牛棚，要使其的噪音总和最小，只需将每个牛棚平均分配一下，这样得到的噪音总是最小的。我就只考虑m=1的情况处理了一下，但还是错了。在余数的处理方面有问题。\n\n\n今天的题目理解上比较容易，但是程序实现上还是有难度。\n\n<strong>DAY2\n--\n\nT1：刚开始想的时候就像枚举每一个点是否改变，打了一个dfs，最后面发现忘记考虑M的值，dfs也有些小问题。用dp的做法没想到。不是很会dp，对状态的转移，和组合数的有关知识，有些欠缺。\n\nT2：看到这题本想着用字符串去做，发现会有负数且不宜分割，打了一个类似链表的数组，可能在删除节点的时候，前驱和后继出现了问题。标准答案跟程序的答案。自己试了一些小数据都没有大的问题。看完题解后，发现这道题很简单，用两个栈然后维护前缀的最大值。初赛的时候就曾见过类似的程序。很快就改出来了。\n\nT3：这题刚开始并没有什么好的想法，看了一下数据范围，发现一种变换和两种变换比较好判定。但思考的方向想错了，想着将两种变换解出来，最后没写成。这题还是可以骗些分的。\n\n<strong>Sources\n--\nJZOJ：3918-3920\nJZOJ：3921-3923","source":"_posts/【NOIP】11-13-11-14总结.md","raw":"---\ntitle: 【NOIP】11.13-11.14总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-29 17:25:00\n---\n<strong>DAY1\n--\n这次考试时间的分配和程序调试方面都有待加强\n\nT1:题目比较简单，很容易理解。写了个六重循环暴力，没有想到特别好的方法。本来可以加区间累加优化，怕写错就没加。还是拿了60。\n这题用二分答案很好打，只不过要注意判断。一开始我将所有蛋糕块的巧克力都求出来最后判大小，超时！！直接判可以减少不少时间。\n\nT2:一看没有什么思路，在纸上画了下草稿，发现有一条必经之路，每个节点都可以转到这条路的任意一个节点，求它到其他个点的最短距离。想法还是可以的。但是，在调程序时，因为太复杂始终没调处来就放弃了。\n\nT3:根据样例解释和数据范围，结合题目意思，很容易就知道对于每个牛棚，要使其的噪音总和最小，只需将每个牛棚平均分配一下，这样得到的噪音总是最小的。我就只考虑m=1的情况处理了一下，但还是错了。在余数的处理方面有问题。\n\n\n今天的题目理解上比较容易，但是程序实现上还是有难度。\n\n<strong>DAY2\n--\n\nT1：刚开始想的时候就像枚举每一个点是否改变，打了一个dfs，最后面发现忘记考虑M的值，dfs也有些小问题。用dp的做法没想到。不是很会dp，对状态的转移，和组合数的有关知识，有些欠缺。\n\nT2：看到这题本想着用字符串去做，发现会有负数且不宜分割，打了一个类似链表的数组，可能在删除节点的时候，前驱和后继出现了问题。标准答案跟程序的答案。自己试了一些小数据都没有大的问题。看完题解后，发现这道题很简单，用两个栈然后维护前缀的最大值。初赛的时候就曾见过类似的程序。很快就改出来了。\n\nT3：这题刚开始并没有什么好的想法，看了一下数据范围，发现一种变换和两种变换比较好判定。但思考的方向想错了，想着将两种变换解出来，最后没写成。这题还是可以骗些分的。\n\n<strong>Sources\n--\nJZOJ：3918-3920\nJZOJ：3921-3923","slug":"【NOIP】11-13-11-14总结","published":1,"updated":"2015-12-25T10:55:45.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvbg0028igtgowo4elhw","sticky":0},{"title":"【NOIP】10.31总结","date":"2015-11-05T09:12:00.000Z","_content":"<strong>概述\n--\n今天这套题做的还好，只是一开始题目意思比较难以理解。\n****\n<strong>T1:Ocd \n--\n第一题看了半天都没看明白。最后通过样例数据和猜测，明白了题目的意思。\n并没有什么太好的方法，打了个暴力本来想着应该过40%的数据，最后过了70%。正解也不是特别难想。\n****\n<strong>T2:Mancity \n--\n没有特别好的方法，一步一步走暴力\n****\n<strong>T3:Captcha \n--\n****\n这题比较好玩，虽然代码复杂度比较高，但仔细想一下，发现其中的规律，还是很好做的","source":"_posts/【NOIP】10-31总结.md","raw":"---\ntitle: 【NOIP】10.31总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-05 17:12:00\n---\n<strong>概述\n--\n今天这套题做的还好，只是一开始题目意思比较难以理解。\n****\n<strong>T1:Ocd \n--\n第一题看了半天都没看明白。最后通过样例数据和猜测，明白了题目的意思。\n并没有什么太好的方法，打了个暴力本来想着应该过40%的数据，最后过了70%。正解也不是特别难想。\n****\n<strong>T2:Mancity \n--\n没有特别好的方法，一步一步走暴力\n****\n<strong>T3:Captcha \n--\n****\n这题比较好玩，虽然代码复杂度比较高，但仔细想一下，发现其中的规律，还是很好做的","slug":"【NOIP】10-31总结","published":1,"updated":"2015-12-25T11:00:19.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvbo002cigtgeoawwqn8","sticky":0},{"title":"【NOIP】10.29总结 B组","date":"2015-10-29T09:05:00.000Z","_content":"<strong>概述\n--\n今天这套题并不太难，时间分配还算比较合理。第一题花费的时间有点多。\n第四题，一开始想的太复杂了。打程序前一定要确定算法的可行性，及算法的复杂度。想好再打，不然会白白浪费很多调试时间。\n<strong>T1:质数 \n--\n第一题比较简单，先筛选处理出$\\sqrt{n}$的素数，然后枚举素数。注意一下边界，记得测试小数据，和大数据就行了。\n\n<strong>T2:平方数游戏 \n--\n这题打完40分暴力后就去做后面的题，因为过多的专注于第二问的回答。没仔细观察第一问的回答，是有循环节的。当我昨晚后面的题时，回过头已经没时间了，当时也不知道有这样的规律。下次对于额外数据还是多关注一下。\n<strong>T3:树上路径\n--\n先画一副复杂一点的树，观察一下发现每个节点只需要维护三个值就好了。\n考试时不大确定其正确性。\n<strong>T3:抓知了 \n--\n首先给定一个序列，就是要我们求最长不下降子序列。dfs动态维护F数组即可。\n考试时以为既要满足最长不下降子序列,还要求它们的和。\n理解错题意，下次要注意。","source":"_posts/【NOIP】10-29总结-B组.md","raw":"---\ntitle: 【NOIP】10.29总结 B组\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-29 17:05:00\n---\n<strong>概述\n--\n今天这套题并不太难，时间分配还算比较合理。第一题花费的时间有点多。\n第四题，一开始想的太复杂了。打程序前一定要确定算法的可行性，及算法的复杂度。想好再打，不然会白白浪费很多调试时间。\n<strong>T1:质数 \n--\n第一题比较简单，先筛选处理出$\\sqrt{n}$的素数，然后枚举素数。注意一下边界，记得测试小数据，和大数据就行了。\n\n<strong>T2:平方数游戏 \n--\n这题打完40分暴力后就去做后面的题，因为过多的专注于第二问的回答。没仔细观察第一问的回答，是有循环节的。当我昨晚后面的题时，回过头已经没时间了，当时也不知道有这样的规律。下次对于额外数据还是多关注一下。\n<strong>T3:树上路径\n--\n先画一副复杂一点的树，观察一下发现每个节点只需要维护三个值就好了。\n考试时不大确定其正确性。\n<strong>T3:抓知了 \n--\n首先给定一个序列，就是要我们求最长不下降子序列。dfs动态维护F数组即可。\n考试时以为既要满足最长不下降子序列,还要求它们的和。\n理解错题意，下次要注意。","slug":"【NOIP】10-29总结-B组","published":1,"updated":"2015-12-25T10:54:42.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvbs002gigtgazooo1re","sticky":0},{"title":"【NOIP】10.28总结 A组","date":"2015-10-28T03:28:00.000Z","_content":"概述：\n--\n看完题目整个人都是晕的，感觉上第二题较简单一点。\n这次考试时间分配上不好，因为总想把第二题调出来，花费了大量时间。最后还是不要太依赖调试工具和对拍，多读读代码！！\nT1：0(0)，T2：0(50)，T3：30(30)\nT1：同余 \n--\n考试时看到这题一点想法都没有，只想到暴力，感觉暴力效率太低了，就暂且跳过了。\n有关数论、乘法逆元等相关知识。\n\nT2:数列\n--\n又犯了和昨天类似的问题，没有看到输出格式中的解释。一开始以为题目出错了。题目要求的是最优方案对应的序号。\n先看数据：暴力乱搞就有30分了......\n再看额外数据。打表搞出几种情况，发现他们之间的规律，然后就照着想法打了。\n其实想法没错，但是考试时花了很多时间在调试身上，对拍的时候发现一个又一个bug，还有一个bug是暴力程序错了。耗费了我大量时间。\n这题满分做法就是贪心，要是当时想的在深入一点，可能就能想到正解了！\n\nT3:递推\n--\n看完题目先想了一下暴力，可以过前30%的数据。再看那20%的数据，发觉是一个斐波那契数列，但是要打一个矩阵乘法太麻烦，时间也已经不容许我打了。这题的关键在于将题目的意思转变成一个矩阵对矩阵进行加法乘法，再配上数学上的优化，就好了。","source":"_posts/【NOIP】10-28总结-A组.md","raw":"---\ntitle: 【NOIP】10.28总结 A组\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-28 11:28:00\n---\n概述：\n--\n看完题目整个人都是晕的，感觉上第二题较简单一点。\n这次考试时间分配上不好，因为总想把第二题调出来，花费了大量时间。最后还是不要太依赖调试工具和对拍，多读读代码！！\nT1：0(0)，T2：0(50)，T3：30(30)\nT1：同余 \n--\n考试时看到这题一点想法都没有，只想到暴力，感觉暴力效率太低了，就暂且跳过了。\n有关数论、乘法逆元等相关知识。\n\nT2:数列\n--\n又犯了和昨天类似的问题，没有看到输出格式中的解释。一开始以为题目出错了。题目要求的是最优方案对应的序号。\n先看数据：暴力乱搞就有30分了......\n再看额外数据。打表搞出几种情况，发现他们之间的规律，然后就照着想法打了。\n其实想法没错，但是考试时花了很多时间在调试身上，对拍的时候发现一个又一个bug，还有一个bug是暴力程序错了。耗费了我大量时间。\n这题满分做法就是贪心，要是当时想的在深入一点，可能就能想到正解了！\n\nT3:递推\n--\n看完题目先想了一下暴力，可以过前30%的数据。再看那20%的数据，发觉是一个斐波那契数列，但是要打一个矩阵乘法太麻烦，时间也已经不容许我打了。这题的关键在于将题目的意思转变成一个矩阵对矩阵进行加法乘法，再配上数学上的优化，就好了。","slug":"【NOIP】10-28总结-A组","published":1,"updated":"2015-12-25T10:53:31.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvc0002kigtg73xsojxo","sticky":0},{"title":"【NOIP2015】10.30总结","date":"2015-10-30T08:04:00.000Z","_content":"<strong>概述\n--\n这套题题目难度还是比较大的。但不管题目有多难，都不能弃疗！！能拿的暴力分都要拿。\n\n<strong>T1:Family \n--\n第一题其实还是比较简单的，然而我陷入了一个思维中，没有从其他角度想。应该有种全局的眼光，不要只盯着少了几个点对看。以致于前1个小时的时间都在想这道题，拖慢了后面的题。从其他角度想更容易想到正解，而且也很好理解。目前已知至少有3种方法能解决问题。\n所以最后只拿了50%的数据。\n\n<strong>T2:Flower\n--\n看完题目很快就明白这题的题目意思，让我们在n个数中选任意的k个数的乘积的和。很快想到一个O(n^2)的dp。100%的做法，也是从这个dp中推来的。后面的计算方法就比较复杂，考试的时候也没时间细想。\n\n<strong>T3:Forget \n--\n这题题目内容比较繁琐，要将题目意思转化为数学模型。但是被题目绕的稀里糊涂。如果充分理解题目意思（在n个标号中选连续k个标号，让这些标号在树中都有边能够联通），还是很好打暴力的！","source":"_posts/【NOIP2015】10-30总结.md","raw":"---\ntitle: 【NOIP2015】10.30总结\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-30 16:04:00\n---\n<strong>概述\n--\n这套题题目难度还是比较大的。但不管题目有多难，都不能弃疗！！能拿的暴力分都要拿。\n\n<strong>T1:Family \n--\n第一题其实还是比较简单的，然而我陷入了一个思维中，没有从其他角度想。应该有种全局的眼光，不要只盯着少了几个点对看。以致于前1个小时的时间都在想这道题，拖慢了后面的题。从其他角度想更容易想到正解，而且也很好理解。目前已知至少有3种方法能解决问题。\n所以最后只拿了50%的数据。\n\n<strong>T2:Flower\n--\n看完题目很快就明白这题的题目意思，让我们在n个数中选任意的k个数的乘积的和。很快想到一个O(n^2)的dp。100%的做法，也是从这个dp中推来的。后面的计算方法就比较复杂，考试的时候也没时间细想。\n\n<strong>T3:Forget \n--\n这题题目内容比较繁琐，要将题目意思转化为数学模型。但是被题目绕的稀里糊涂。如果充分理解题目意思（在n个标号中选连续k个标号，让这些标号在树中都有边能够联通），还是很好打暴力的！","slug":"【NOIP2015】10-30总结","published":1,"updated":"2015-12-25T10:56:22.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvcq002oigtggpryvh9o","sticky":0},{"title":"【NOIP2013模拟联考9】阿Q的停车场","date":"2015-08-11T00:24:00.000Z","_content":"Description\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","source":"_posts/【NOIP2013模拟联考9】阿Q的停车场.md","raw":"title:  【NOIP2013模拟联考9】阿Q的停车场\ntags: [题解]\ncategories: [信息学,原创]\ndate: 2015-08-11 08:24\n---\nDescription\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","slug":"【NOIP2013模拟联考9】阿Q的停车场","published":1,"updated":"2015-12-19T06:28:42.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvcy002sigtgfbxh8oiq","sticky":0},{"title":"Hello World","date":"2015-12-17T11:00:00.000Z","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\ndate: 2015-12-17 19:00:00\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2015-12-19T06:32:58.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvd4002wigtgfhziux5t","sticky":0},{"title":"cc软件集","date":"2012-03-24T12:56:48.000Z","_content":"cc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","source":"_posts/cc软件集.md","raw":"title: cc软件集\ndate: 2012-3-24 20:56:48\ntags: [软件]\ncategories: [易语言,原创]\n---\ncc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","slug":"cc软件集","published":1,"updated":"2015-12-19T06:34:04.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvd7002xigtge9hlwb5x","sticky":0},{"title":"bzoj3732 Network","date":"2015-08-11T13:13:00.000Z","_content":"Description\n==\n题目来源\nbzoj[3732]\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=3732\n\n\nAnalysis\n==\n这题给的输入是一个无向连通图，说明图中会有环和一些树枝。对于一个询问在环上的两个点，有两条可以联通的道路。\n一条中的边权最大值是整个环的最大值（舍弃），\n另一条的边权最大值是整个环的次大值（需要）。\n所以只有次大值才是我们想要的！因此，我们想到了最小生成树，将这些环中的最大边权值所属的边删掉。\n最小生成树的求法就是，先让边权从小到大排序，然后依次添加并用并查集维护即可。（Kruskal算法）\n\n所以，现在问题就转化成在一棵树中，求任意两点A，B路径上边权的最大值。\n\n此时我们就需要求LCA了，并维护两点到LCA边权的最大值，在做LCA的时候使用倍增算法，再配上RMQ问题中的st算法即可解决问题。\n\ncode\n==\n\n```C++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=30000+100,M=30000+100;\n\nstruct node{int x,y,d;}c[N];\nstruct node1{int y,v,next;}h[2*M];\nint n,m,k,u,v,tot,e[N],fw[N][16],fv[N][16],fa[N],dep[N];\n\nbool cmp(node a, node b) {return a.d<b.d;}\n\nint gf(int x)\n{\n\tif (fa[x] == x) return x;\n\treturn fa[x] = gf(fa[x]);\n}\n\nvoid add(int x,int y,int z)\n{\n\ttot ++;\n\th[tot].y = y;\n\th[tot].v = z;\n\th[tot].next=e[x];\n\te[x] = tot;\n}\n\nvoid dfs(int x ,int fat)\n{\n\tfor (int i = e[x];i;i = h[i].next)\n\t\tif (h[i].y!=fat)\n\t\t{\n\t\t\tdep[h[i].y] = dep[x]+1;\n\t\t\tdfs(h[i].y,x);\n\t\t\tfv[h[i].y][0] = h[i].v;\n\t\t\tfw[h[i].y][0] = x;\n\t\t}\n}\n\nint move(int &x,int d)\n{\n\tint i,t=0;\n\twhile (dep[fw[x][0]]!=d)\n\t{\n\t\tfor (i = 0;dep[fw[x][i]]>d;i++);\n\t\tt = max(t,fv[x][i-1]);\n\t\tx = fw[x][i-1];\n\t}\n\tt = max(t,fv[x][0]);\n\tx = fw[x][0];\n\treturn t;\n}\n\nint lca(int u,int v)\n{\n\tint i,t = 0;\n\tif (dep[u]>dep[v]) t = move(u,dep[v]);\n\telse if (dep[u]<dep[v]) t = move(v,dep[u]);\n\twhile (fw[u][0]!=fw[v][0])\n\t{\n\t\tfor (i = 0;fw[u][i] != fw[v][i];i ++);\n\t\tt = max(t,max(fv[u][i-1],fv[v][i-1]));\n\t\tu = fw[u][i-1];\n\t\tv = fw[v][i-1];\n\t}\n\tif (u!=v)\n\tt = max(max(fv[u][0],fv[v][0]),t);\n\treturn t;\n}\n\nint main()\n{\n\t//freopen(\"1738.in\",\"r\",stdin);\n\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor (int i=1;i <= m ; i ++)\n\tscanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].d);\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1 ; i <= n ; i ++) fa[i]=i;\n\tfor (int i=1 ; i <= m ; i ++)\n\t{\n\t\tif (gf(c[i].x)!=gf(c[i].y))\n\t\t{\n\t\t\tadd(c[i].x,c[i].y,c[i].d);\n\t\t\tadd(c[i].y,c[i].x,c[i].d);\n\t\t\tfa[fa[c[i].x]] = fa[fa[c[i].y]];\n\t\t}\n\t}\n\tdep[1] = 1;\n\tdfs(1,0);\n\tfor (int j=1 ; j <= 14; j ++)\n\tfor (int i=1 ;i<=n;i ++)\n\tif (fw[fw[i][j-1]][j-1] != 0)//limit excepeted\n\t{\n\t\tfw[i][j] = fw[fw[i][j-1]][j-1];\n\t\tfv[i][j] = max(fv[i][j-1],fv[fw[i][j-1]][j-1]);\n\t}\n\tfor (int i = 1 ; i <= k ; i ++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tprintf(\"%d\\n\",lca(u,v));\n\t}\n\n\treturn 0;\n}\n```\n\nTips\n==\nKruskal算法：http://baike.baidu.com/link?url=0x-xezmCp5Fud_PyEPvp6gBHGzdU2tnG-6zEg42g5f6jL7QCCOygSbY8CwqnDalzqb9Ol-36JJJVrw2UBaN5x_#4_1\nLCA 倍增算法：http://www.tuicool.com/articles/N7jQV32\nRMQ st算法http://www.cnblogs.com/Missa/archive/2012/10/01/2709686.html\n\n","source":"_posts/bzoj3732-Network.md","raw":"---\ntitle: bzoj3732 Network\ndate: 2015-08-11 21:13\ntags:\n  - 题解\n  - LCA\n  - RMQ\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n==\n题目来源\nbzoj[3732]\nhttp://www.lydsy.com/JudgeOnline/problem.php?id=3732\n\n\nAnalysis\n==\n这题给的输入是一个无向连通图，说明图中会有环和一些树枝。对于一个询问在环上的两个点，有两条可以联通的道路。\n一条中的边权最大值是整个环的最大值（舍弃），\n另一条的边权最大值是整个环的次大值（需要）。\n所以只有次大值才是我们想要的！因此，我们想到了最小生成树，将这些环中的最大边权值所属的边删掉。\n最小生成树的求法就是，先让边权从小到大排序，然后依次添加并用并查集维护即可。（Kruskal算法）\n\n所以，现在问题就转化成在一棵树中，求任意两点A，B路径上边权的最大值。\n\n此时我们就需要求LCA了，并维护两点到LCA边权的最大值，在做LCA的时候使用倍增算法，再配上RMQ问题中的st算法即可解决问题。\n\ncode\n==\n\n```C++\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=30000+100,M=30000+100;\n\nstruct node{int x,y,d;}c[N];\nstruct node1{int y,v,next;}h[2*M];\nint n,m,k,u,v,tot,e[N],fw[N][16],fv[N][16],fa[N],dep[N];\n\nbool cmp(node a, node b) {return a.d<b.d;}\n\nint gf(int x)\n{\n\tif (fa[x] == x) return x;\n\treturn fa[x] = gf(fa[x]);\n}\n\nvoid add(int x,int y,int z)\n{\n\ttot ++;\n\th[tot].y = y;\n\th[tot].v = z;\n\th[tot].next=e[x];\n\te[x] = tot;\n}\n\nvoid dfs(int x ,int fat)\n{\n\tfor (int i = e[x];i;i = h[i].next)\n\t\tif (h[i].y!=fat)\n\t\t{\n\t\t\tdep[h[i].y] = dep[x]+1;\n\t\t\tdfs(h[i].y,x);\n\t\t\tfv[h[i].y][0] = h[i].v;\n\t\t\tfw[h[i].y][0] = x;\n\t\t}\n}\n\nint move(int &x,int d)\n{\n\tint i,t=0;\n\twhile (dep[fw[x][0]]!=d)\n\t{\n\t\tfor (i = 0;dep[fw[x][i]]>d;i++);\n\t\tt = max(t,fv[x][i-1]);\n\t\tx = fw[x][i-1];\n\t}\n\tt = max(t,fv[x][0]);\n\tx = fw[x][0];\n\treturn t;\n}\n\nint lca(int u,int v)\n{\n\tint i,t = 0;\n\tif (dep[u]>dep[v]) t = move(u,dep[v]);\n\telse if (dep[u]<dep[v]) t = move(v,dep[u]);\n\twhile (fw[u][0]!=fw[v][0])\n\t{\n\t\tfor (i = 0;fw[u][i] != fw[v][i];i ++);\n\t\tt = max(t,max(fv[u][i-1],fv[v][i-1]));\n\t\tu = fw[u][i-1];\n\t\tv = fw[v][i-1];\n\t}\n\tif (u!=v)\n\tt = max(max(fv[u][0],fv[v][0]),t);\n\treturn t;\n}\n\nint main()\n{\n\t//freopen(\"1738.in\",\"r\",stdin);\n\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor (int i=1;i <= m ; i ++)\n\tscanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].d);\n\tsort(c+1,c+1+m,cmp);\n\tfor (int i=1 ; i <= n ; i ++) fa[i]=i;\n\tfor (int i=1 ; i <= m ; i ++)\n\t{\n\t\tif (gf(c[i].x)!=gf(c[i].y))\n\t\t{\n\t\t\tadd(c[i].x,c[i].y,c[i].d);\n\t\t\tadd(c[i].y,c[i].x,c[i].d);\n\t\t\tfa[fa[c[i].x]] = fa[fa[c[i].y]];\n\t\t}\n\t}\n\tdep[1] = 1;\n\tdfs(1,0);\n\tfor (int j=1 ; j <= 14; j ++)\n\tfor (int i=1 ;i<=n;i ++)\n\tif (fw[fw[i][j-1]][j-1] != 0)//limit excepeted\n\t{\n\t\tfw[i][j] = fw[fw[i][j-1]][j-1];\n\t\tfv[i][j] = max(fv[i][j-1],fv[fw[i][j-1]][j-1]);\n\t}\n\tfor (int i = 1 ; i <= k ; i ++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tprintf(\"%d\\n\",lca(u,v));\n\t}\n\n\treturn 0;\n}\n```\n\nTips\n==\nKruskal算法：http://baike.baidu.com/link?url=0x-xezmCp5Fud_PyEPvp6gBHGzdU2tnG-6zEg42g5f6jL7QCCOygSbY8CwqnDalzqb9Ol-36JJJVrw2UBaN5x_#4_1\nLCA 倍增算法：http://www.tuicool.com/articles/N7jQV32\nRMQ st算法http://www.cnblogs.com/Missa/archive/2012/10/01/2709686.html\n\n","slug":"bzoj3732-Network","published":1,"updated":"2015-12-25T10:31:42.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvdb0031igtgzh5owaqx","sticky":0},{"title":"Road","date":"2015-12-20T10:07:30.000Z","_content":"\n**Description**\n--\n给你一棵有N个结点的数。这N个结点都有一个权值为$C[i]$。\n询问你两个结点u、v，在这两个结点的最短路径上，选取两个点i、j，且i靠近结点u，j靠近结点v。让你计算$Max(c[j]-c[i],0)$\n\n**Input**\n--\n输入第一行有一个整数N(1≤n≤50000)\n接下来有N 行，每行一个整数Ci(1≤Ci≤50000)\n再接下来有N-1 行，每行两个整数x,y(1≤x,y≤50000)，表示x 和y 之间有一条边。\n接下来有一个整数M，表示有M 个询问。\n然后M 行，每行两个整数，x,y(1≤x,y≤50000)询问$Max(c[j]-c[i],0)$\n**Output**\n--\n对于每次询问,输出对应最大值结果\n\n**Sample Input**\n--\n\n```\n4 \n1 \n2 \n3\n4\n1 2\n1 4\n2 3\n3\n1 3\n3 1\n1 4\n```\n\n**Sample Output**\n--\n\n```\n2\n0\n3\n```\n\n**Data Constraint**\n--\n对于30%的数据, 1≤N,M≤100\n对于60%的数据，1≤N,M≤1000\n对于100%的数据，1≤N,M≤50000\n\n**Analysis**\n--\n因为是一棵树，所以任意两点的最短路径是唯一的。\n**1°30%　＆＆　60％的数据**\n\n - 对于每一个询问我们可以O(N)的扫一遍整副图，直到找到终点v。并记录下此时经过路径的结点。然后在O(3*N)的扫一遍得到从结点u到结点i的最小值$(\\sum\\_{i=u}^v A[i] = Min(C[i]))$，以及从结点i到结点v的最大值$(\\sum\\_{i=v}^u B[i] = Max(C[i]))$，最后只需要每一个结点对应扫一遍就行了计算最大值即可。$(\\sum\\_{i=u}^v Ans = Max(B[i]-A[i]))$。这样做的时间复杂度就是$O（MN）$。\n\n - 还有一种是这种算法的改进。\n就是充分利用树的特点，先dfs预处理一遍所有结点到根节点的深度，在一步步向上跳。直到调到他们的LCA。后续的答案计算和前面一样。时间复杂度虽然也是$O（MN）$，可是当数据是随机生成的时候很有可能会优化到$O(2*M*log(N))$。\n\n详情请见代码1......\n\n****\n**2°100％的数据**\n这种涉及到路径的问题肯定会与LCA有关，LCA最快的在线做法就是倍增。\n但是倍增在计算是需要合并两个块，所以我们可以考虑一下，怎样合并两个块。\n对于一个块就是一个有顺序的结点集合，它需要存放四个值，即：\n1. 块中所有结点的最小值 (buy)\n2. 块中所有结点的最大值 (sell)\n3. 先最小值后最大值的差的绝对值的最大值(Max(bs))\n4. 先最大值后最小值的差的绝对值的最大值(Min(sb))\n****\n我们发现当维护了这四个值后我们就可以进行块合并操作了。\n假设要合并的块分别为A和B，合并后的块为C。\n1. $C.buy = Min(A.buy,B.buy)$\n2. $C.sell = Max(A.sell,B.sell)$\n3. $C.bs = Max(A.bs,B.bs,B.sell-A.buy)$\n4. $C.sb = Max(A.sb,B.sb,A.sell-B.buy)$\n\n然后倍增的到LCA后我们只需要知道$\\sum\\_{i=u}^{LCA}$的块与$\\sum\\_{i=v}^{LCA}$的块合并后即可知道答案。\n同理我们也可以用tarjan离线LCA的方法来解决这个问题，这样时间复杂度就是$O（N）$。\n详情请见代码2......\n****\n**下面说一下具体的程序实现的小问题**\n对于离线的tarjan算法，因为用到了并查集，所以我们可以对每一个节点，维护它向上的块，维护的大小取决于当前并查集的大小，这样就能完成从$\\sum\\_{i=u}^{LCA}$的块维护，对于另一边我们可以在(u,v)的LCA上打一个标记，当tarjan遍历回到了LCA后。在进行合并。\n可以对照这篇博客中的图看一看：http://blog.csdn.net/hnust_xiehonghao/article/details/9109295\n****\n**Code**\n--\n代码1：\n\n```\nuses\tmath;\nconst\tmaxn=50002;\ntype\tnode=record\n\t\ty,next:longint;\n\tend;\nvar\ti,j,k,m,n,tot,x,y,ans:longint;\n\tv,e,dep,fa:array[1..maxn] of longint;\n\th:array[1..2*maxn] of node;\n\ta,a1,a2,b,c:array[0..maxn] of longint;\n\tflag:array[1..maxn] of boolean;\nprocedure add(x,y:longint);\nbegin\n\tinc(tot);\n\th[tot].y:=y;\n\th[tot].next:=e[x];\n\te[x]:=tot;\nend;\nprocedure dfs(x:longint);\nvar\ti:longint;\nbegin\n\tif flag[x] then exit;\n\tflag[x]:=true;\n\ti:=e[x];\n\twhile i<>0 do begin\n\t\tif flag[h[i].y] then begin\n\t\t\ti:=h[i].next;\n\t\t\tcontinue;\n\t\tend;\n\t\tdep[h[i].y]:=dep[x]+1;\n\t\tfa[h[i].y]:=x;\n\t\tdfs(h[i].y);\n\t\ti:=h[i].next;\n\tend;\nend;\nprocedure up(var x:longint;y:longint);\nbegin\n\tif odd(y) then begin\n\t\tinc(a1[0]);\n\t\ta1[a1[0]]:=x;\n\tend else begin\n\t\tinc(a2[0]);\n\t\ta2[a2[0]]:=x;\n\tend;\n\tx:=fa[x];\nend;\nprocedure link;\nvar\ti:longint;\nbegin\n\tfor i:=1 to a1[0] do a[i]:=a1[i];\n\ta[0]:=a1[0];\n\tfor i:=a2[0] downto 1 do begin\n\t\tinc(a[0]);\n\t\ta[a[0]]:=a2[i];\n\tend;\nend;\nprocedure work(x,y:longint);\nvar\ti:longint;\nbegin\n\ta1[0]:=0;a2[0]:=0;ans:=0;\n\twhile dep[x]>dep[y] do up(x,1);\n\twhile dep[x]<dep[y] do up(y,2);\n\twhile x<>y do begin\n\t\tup(x,1);up(y,2);\n\tend;\n\tinc(a1[0]);\n\ta1[a1[0]]:=x;\n\tlink;\n\tb[0]:=1000000007;c[a[0]+1]:=0;\n\tfor i:=1 to a[0] do b[i]:=min(b[i-1],v[a[i]]);\n\tfor i:=a[0] downto 1 do c[i]:=max(c[i+1],v[a[i]]);\n\tfor i:=1 to a[0] do ans:=max(ans,c[i]-b[i]);\n\t{\n\tfor i:=1 to a[0] do begin\n\t\tfor j:=i+1 to a[0] do begin\n\t\t\tans:=max(ans,v[a[j]]-v[a[i]]);\n\t\tend;\n\tend;\n\t}\nend;\nbegin\n\t//assign(input,'1230.in');reset(input);\n\t//assign(output,'1230.out');rewrite(output);\n\n\treadln(n);\n\tfor i:=1 to n do read(v[i]);\n\tfor i:=1 to n-1 do begin\n\t\treadln(x,y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\tend;\n\tdep[1]:=1;fa[1]:=0;\n\tdfs(1);\n\treadln(m);\n\tfor i:=1 to m do begin\n\t\treadln(x,y);\n\t\twork(x,y);\n\t\twriteln(ans);\n\tend;\nend.\n```\n\n****\n代码2：\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int N = 50000+5,M = N*3;\n\nstruct node\n{\n\tint fa,buy,sell,bs,sb;\n\tnode (int A=0,int B=0,int C=0,int D=0,int E=0)\n\t{\n\t\tfa = A,buy = B,sell = C,bs = D,sb = E;\n\t}\n} f[N];\n\nstruct Edge\n{\n\tint y,next;\n} h[3][M];\n\nint e[3][N],tot[3],b[N][2],ans[N],a[N];\nint n,m;\nbool vis[N];\n\nvoid add(int x,int y,int kind)\n{\n\th[kind][++ tot[kind]].y = y;\n\th[kind][tot[kind]].next = e[kind][x];\n\te[kind][x] = tot[kind];\n}\n\nnode gf(int x)\n{\n\tnode t;\n\tif (f[x].fa != x)\n\t{\n\t\tt = gf(f[x].fa);\n\t\tf[x] = node(t.fa,min(f[x].buy,t.buy),max(f[x].sell,t.sell),max(t.sell-f[x].buy,max(f[x].bs,t.bs)),max(f[x].sell-t.buy,max(f[x].sb,t.sb)));\n\t}\n\treturn f[x];\n}\n\nvoid tarjan(int x,int fa)\n{\n\tvis[x] = 1;\n\tfor (int i=e[0][x];i;i=h[0][i].next)\n\t{\n\t\tint y = h[0][i].y;\n\t\tif (y==fa) continue; \n\t\ttarjan(y,x);\n\t\tf[y].fa = x;\n\t}\n\tfor (int i=e[1][x];i;i=h[1][i].next)\n\t{\n\t\tint j = h[1][i].y,y = b[j][b[j][0] == x];//Υµ½Αν»µγ\n\t\tif (!vis[y]) continue;\n\t\tif (gf(y).fa != x) \n\t\t\tadd(f[y].fa,j,2);\n\t}\n\tfor (int i=e[2][x];i;i = h[2][i].next)\n\t{\n\t\tint j=h[2][i].y,x=b[j][0],y=b[j][1];\n\t\tgf(x),gf(y);\n\t\tans[j] = max(ans[j],f[x].bs);\n\t\tans[j] = max(ans[j],f[y].sb);\n\t\tans[j] = max(ans[j],f[y].sell-f[x].buy);\n\t}\n}\n\n\nint main()\n{\n\t//freopen(\"1230.in\",\"r\",stdin);\n\t//freopen(\"1230.out\",\"w\",stdout);\n\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i ++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i] = node(i,a[i],a[i],0,0);\n\t}\n\tfor (int i=1;i<n;i ++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y,0),add(y,x,0);\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%d%d\",&b[i][0],&b[i][1]);\n\t\tadd(b[i][0],i,1);add(b[i][1],i,1);\n\t}\n\ttarjan(1,0);\n\tfor (int i=1;i<=m;i ++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```","source":"_posts/Road.md","raw":"---\ntitle: Road\ntags:\n  - 题解\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-12-20 18:07:30\n---\n\n**Description**\n--\n给你一棵有N个结点的数。这N个结点都有一个权值为$C[i]$。\n询问你两个结点u、v，在这两个结点的最短路径上，选取两个点i、j，且i靠近结点u，j靠近结点v。让你计算$Max(c[j]-c[i],0)$\n\n**Input**\n--\n输入第一行有一个整数N(1≤n≤50000)\n接下来有N 行，每行一个整数Ci(1≤Ci≤50000)\n再接下来有N-1 行，每行两个整数x,y(1≤x,y≤50000)，表示x 和y 之间有一条边。\n接下来有一个整数M，表示有M 个询问。\n然后M 行，每行两个整数，x,y(1≤x,y≤50000)询问$Max(c[j]-c[i],0)$\n**Output**\n--\n对于每次询问,输出对应最大值结果\n\n**Sample Input**\n--\n\n```\n4 \n1 \n2 \n3\n4\n1 2\n1 4\n2 3\n3\n1 3\n3 1\n1 4\n```\n\n**Sample Output**\n--\n\n```\n2\n0\n3\n```\n\n**Data Constraint**\n--\n对于30%的数据, 1≤N,M≤100\n对于60%的数据，1≤N,M≤1000\n对于100%的数据，1≤N,M≤50000\n\n**Analysis**\n--\n因为是一棵树，所以任意两点的最短路径是唯一的。\n**1°30%　＆＆　60％的数据**\n\n - 对于每一个询问我们可以O(N)的扫一遍整副图，直到找到终点v。并记录下此时经过路径的结点。然后在O(3*N)的扫一遍得到从结点u到结点i的最小值$(\\sum\\_{i=u}^v A[i] = Min(C[i]))$，以及从结点i到结点v的最大值$(\\sum\\_{i=v}^u B[i] = Max(C[i]))$，最后只需要每一个结点对应扫一遍就行了计算最大值即可。$(\\sum\\_{i=u}^v Ans = Max(B[i]-A[i]))$。这样做的时间复杂度就是$O（MN）$。\n\n - 还有一种是这种算法的改进。\n就是充分利用树的特点，先dfs预处理一遍所有结点到根节点的深度，在一步步向上跳。直到调到他们的LCA。后续的答案计算和前面一样。时间复杂度虽然也是$O（MN）$，可是当数据是随机生成的时候很有可能会优化到$O(2*M*log(N))$。\n\n详情请见代码1......\n\n****\n**2°100％的数据**\n这种涉及到路径的问题肯定会与LCA有关，LCA最快的在线做法就是倍增。\n但是倍增在计算是需要合并两个块，所以我们可以考虑一下，怎样合并两个块。\n对于一个块就是一个有顺序的结点集合，它需要存放四个值，即：\n1. 块中所有结点的最小值 (buy)\n2. 块中所有结点的最大值 (sell)\n3. 先最小值后最大值的差的绝对值的最大值(Max(bs))\n4. 先最大值后最小值的差的绝对值的最大值(Min(sb))\n****\n我们发现当维护了这四个值后我们就可以进行块合并操作了。\n假设要合并的块分别为A和B，合并后的块为C。\n1. $C.buy = Min(A.buy,B.buy)$\n2. $C.sell = Max(A.sell,B.sell)$\n3. $C.bs = Max(A.bs,B.bs,B.sell-A.buy)$\n4. $C.sb = Max(A.sb,B.sb,A.sell-B.buy)$\n\n然后倍增的到LCA后我们只需要知道$\\sum\\_{i=u}^{LCA}$的块与$\\sum\\_{i=v}^{LCA}$的块合并后即可知道答案。\n同理我们也可以用tarjan离线LCA的方法来解决这个问题，这样时间复杂度就是$O（N）$。\n详情请见代码2......\n****\n**下面说一下具体的程序实现的小问题**\n对于离线的tarjan算法，因为用到了并查集，所以我们可以对每一个节点，维护它向上的块，维护的大小取决于当前并查集的大小，这样就能完成从$\\sum\\_{i=u}^{LCA}$的块维护，对于另一边我们可以在(u,v)的LCA上打一个标记，当tarjan遍历回到了LCA后。在进行合并。\n可以对照这篇博客中的图看一看：http://blog.csdn.net/hnust_xiehonghao/article/details/9109295\n****\n**Code**\n--\n代码1：\n\n```\nuses\tmath;\nconst\tmaxn=50002;\ntype\tnode=record\n\t\ty,next:longint;\n\tend;\nvar\ti,j,k,m,n,tot,x,y,ans:longint;\n\tv,e,dep,fa:array[1..maxn] of longint;\n\th:array[1..2*maxn] of node;\n\ta,a1,a2,b,c:array[0..maxn] of longint;\n\tflag:array[1..maxn] of boolean;\nprocedure add(x,y:longint);\nbegin\n\tinc(tot);\n\th[tot].y:=y;\n\th[tot].next:=e[x];\n\te[x]:=tot;\nend;\nprocedure dfs(x:longint);\nvar\ti:longint;\nbegin\n\tif flag[x] then exit;\n\tflag[x]:=true;\n\ti:=e[x];\n\twhile i<>0 do begin\n\t\tif flag[h[i].y] then begin\n\t\t\ti:=h[i].next;\n\t\t\tcontinue;\n\t\tend;\n\t\tdep[h[i].y]:=dep[x]+1;\n\t\tfa[h[i].y]:=x;\n\t\tdfs(h[i].y);\n\t\ti:=h[i].next;\n\tend;\nend;\nprocedure up(var x:longint;y:longint);\nbegin\n\tif odd(y) then begin\n\t\tinc(a1[0]);\n\t\ta1[a1[0]]:=x;\n\tend else begin\n\t\tinc(a2[0]);\n\t\ta2[a2[0]]:=x;\n\tend;\n\tx:=fa[x];\nend;\nprocedure link;\nvar\ti:longint;\nbegin\n\tfor i:=1 to a1[0] do a[i]:=a1[i];\n\ta[0]:=a1[0];\n\tfor i:=a2[0] downto 1 do begin\n\t\tinc(a[0]);\n\t\ta[a[0]]:=a2[i];\n\tend;\nend;\nprocedure work(x,y:longint);\nvar\ti:longint;\nbegin\n\ta1[0]:=0;a2[0]:=0;ans:=0;\n\twhile dep[x]>dep[y] do up(x,1);\n\twhile dep[x]<dep[y] do up(y,2);\n\twhile x<>y do begin\n\t\tup(x,1);up(y,2);\n\tend;\n\tinc(a1[0]);\n\ta1[a1[0]]:=x;\n\tlink;\n\tb[0]:=1000000007;c[a[0]+1]:=0;\n\tfor i:=1 to a[0] do b[i]:=min(b[i-1],v[a[i]]);\n\tfor i:=a[0] downto 1 do c[i]:=max(c[i+1],v[a[i]]);\n\tfor i:=1 to a[0] do ans:=max(ans,c[i]-b[i]);\n\t{\n\tfor i:=1 to a[0] do begin\n\t\tfor j:=i+1 to a[0] do begin\n\t\t\tans:=max(ans,v[a[j]]-v[a[i]]);\n\t\tend;\n\tend;\n\t}\nend;\nbegin\n\t//assign(input,'1230.in');reset(input);\n\t//assign(output,'1230.out');rewrite(output);\n\n\treadln(n);\n\tfor i:=1 to n do read(v[i]);\n\tfor i:=1 to n-1 do begin\n\t\treadln(x,y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\tend;\n\tdep[1]:=1;fa[1]:=0;\n\tdfs(1);\n\treadln(m);\n\tfor i:=1 to m do begin\n\t\treadln(x,y);\n\t\twork(x,y);\n\t\twriteln(ans);\n\tend;\nend.\n```\n\n****\n代码2：\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int N = 50000+5,M = N*3;\n\nstruct node\n{\n\tint fa,buy,sell,bs,sb;\n\tnode (int A=0,int B=0,int C=0,int D=0,int E=0)\n\t{\n\t\tfa = A,buy = B,sell = C,bs = D,sb = E;\n\t}\n} f[N];\n\nstruct Edge\n{\n\tint y,next;\n} h[3][M];\n\nint e[3][N],tot[3],b[N][2],ans[N],a[N];\nint n,m;\nbool vis[N];\n\nvoid add(int x,int y,int kind)\n{\n\th[kind][++ tot[kind]].y = y;\n\th[kind][tot[kind]].next = e[kind][x];\n\te[kind][x] = tot[kind];\n}\n\nnode gf(int x)\n{\n\tnode t;\n\tif (f[x].fa != x)\n\t{\n\t\tt = gf(f[x].fa);\n\t\tf[x] = node(t.fa,min(f[x].buy,t.buy),max(f[x].sell,t.sell),max(t.sell-f[x].buy,max(f[x].bs,t.bs)),max(f[x].sell-t.buy,max(f[x].sb,t.sb)));\n\t}\n\treturn f[x];\n}\n\nvoid tarjan(int x,int fa)\n{\n\tvis[x] = 1;\n\tfor (int i=e[0][x];i;i=h[0][i].next)\n\t{\n\t\tint y = h[0][i].y;\n\t\tif (y==fa) continue; \n\t\ttarjan(y,x);\n\t\tf[y].fa = x;\n\t}\n\tfor (int i=e[1][x];i;i=h[1][i].next)\n\t{\n\t\tint j = h[1][i].y,y = b[j][b[j][0] == x];//Υµ½Αν»µγ\n\t\tif (!vis[y]) continue;\n\t\tif (gf(y).fa != x) \n\t\t\tadd(f[y].fa,j,2);\n\t}\n\tfor (int i=e[2][x];i;i = h[2][i].next)\n\t{\n\t\tint j=h[2][i].y,x=b[j][0],y=b[j][1];\n\t\tgf(x),gf(y);\n\t\tans[j] = max(ans[j],f[x].bs);\n\t\tans[j] = max(ans[j],f[y].sb);\n\t\tans[j] = max(ans[j],f[y].sell-f[x].buy);\n\t}\n}\n\n\nint main()\n{\n\t//freopen(\"1230.in\",\"r\",stdin);\n\t//freopen(\"1230.out\",\"w\",stdout);\n\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i ++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i] = node(i,a[i],a[i],0,0);\n\t}\n\tfor (int i=1;i<n;i ++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y,0),add(y,x,0);\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i ++)\n\t{\n\t\tscanf(\"%d%d\",&b[i][0],&b[i][1]);\n\t\tadd(b[i][0],i,1);add(b[i][1],i,1);\n\t}\n\ttarjan(1,0);\n\tfor (int i=1;i<=m;i ++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```","slug":"Road","published":1,"updated":"2015-12-21T10:53:51.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvdj0039igtgnkvlgii1","sticky":0},{"title":"[NOIP2015提高组复赛]总结","date":"2015-11-17T09:16:00.000Z","_content":"**概述**\n--\n考试时太浮躁！不要心急打程序，一定要静下心来仔细思考算法。是否可行（时限能否过）。保证思考算法的时间。对于自己熟练地算法，要相信能想得出来就一定能最快的调出来。根据数据范围，大胆猜测考得是什么算法。有时候直接想暴力是不科学的，暴力有时非常的复杂，还会带乱对整道题的思绪。\n对一些普通算法的应用还不够了解，看不出一道题考察的是什么算法。平时训练要多一些对算法的思考，能不看题解就不看题解，花多点时间在思考上。\n**DAY1**\n--\n开考时有点小紧张，看到T1题目很长，就更紧张了！！！\nT1:仔细读题，纯暴力。打完用了半个小时，又打了一个判断正确性的程序拍了一下，花了1个多小时，耗时较大，拖慢了后面的解题时间。\n\nT2:紧张依旧挥之不去，随手画了个图，发现是找一个最小的环，然后就想到了tarjan缩点。就开打了。到了最后才发现，tarjan会爆栈，然而为时已晚。\n考试时要及时测试小数据和大数据，不要嫌麻烦而只出随机数据。尽管大部分时候程序可以在随机数据下面表现良好。\n考试时要冷静下来，仔细思考算法是否存在漏洞。\n\nT3:题目复杂，加之从小到大不会打牌，所以看了很多遍题目。大概了解了出牌方法。发现了花色是没有用的。\n于是打dfs，但是没有将牌统计到一块打了半天又长又有诸多bug。所以直接被我推倒重来了。感觉dfs特别难打，所以打了一个错误的贪心。\n\n**DAY2**\n--\nT1:这道题怎么想都没有想到可以用二分答案的方法去算，一开始想把每一块最短的石头都拿出来，但是部分最优解并不能推出全局最有解。所以打了一个错误的贪心，在贪心的路上越走越远，依然没走到尽头。\n\nT2:想到搜索,算了一下搜索太慢。就冲着50%的数据去了，但是到最后面k==m的情况还是没有想到满足时限的做法。当时只要推一下，很快就能得到dp方程。\n\nT3:打了倍增最短路，计划过30%的数据，确实想不到特别好的算法，暴力非常复杂，打了很长时间，才打完。","source":"_posts/NOIP2015提高组复赛-总结.md","raw":"---\ntitle: '[NOIP2015提高组复赛]总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-17 17:16:00\n---\n**概述**\n--\n考试时太浮躁！不要心急打程序，一定要静下心来仔细思考算法。是否可行（时限能否过）。保证思考算法的时间。对于自己熟练地算法，要相信能想得出来就一定能最快的调出来。根据数据范围，大胆猜测考得是什么算法。有时候直接想暴力是不科学的，暴力有时非常的复杂，还会带乱对整道题的思绪。\n对一些普通算法的应用还不够了解，看不出一道题考察的是什么算法。平时训练要多一些对算法的思考，能不看题解就不看题解，花多点时间在思考上。\n**DAY1**\n--\n开考时有点小紧张，看到T1题目很长，就更紧张了！！！\nT1:仔细读题，纯暴力。打完用了半个小时，又打了一个判断正确性的程序拍了一下，花了1个多小时，耗时较大，拖慢了后面的解题时间。\n\nT2:紧张依旧挥之不去，随手画了个图，发现是找一个最小的环，然后就想到了tarjan缩点。就开打了。到了最后才发现，tarjan会爆栈，然而为时已晚。\n考试时要及时测试小数据和大数据，不要嫌麻烦而只出随机数据。尽管大部分时候程序可以在随机数据下面表现良好。\n考试时要冷静下来，仔细思考算法是否存在漏洞。\n\nT3:题目复杂，加之从小到大不会打牌，所以看了很多遍题目。大概了解了出牌方法。发现了花色是没有用的。\n于是打dfs，但是没有将牌统计到一块打了半天又长又有诸多bug。所以直接被我推倒重来了。感觉dfs特别难打，所以打了一个错误的贪心。\n\n**DAY2**\n--\nT1:这道题怎么想都没有想到可以用二分答案的方法去算，一开始想把每一块最短的石头都拿出来，但是部分最优解并不能推出全局最有解。所以打了一个错误的贪心，在贪心的路上越走越远，依然没走到尽头。\n\nT2:想到搜索,算了一下搜索太慢。就冲着50%的数据去了，但是到最后面k==m的情况还是没有想到满足时限的做法。当时只要推一下，很快就能得到dp方程。\n\nT3:打了倍增最短路，计划过30%的数据，确实想不到特别好的算法，暴力非常复杂，打了很长时间，才打完。","slug":"NOIP2015提高组复赛-总结","published":1,"updated":"2015-12-25T11:00:14.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvdo003digtgu9wdidd3","sticky":0},{"title":"[NOIP]考前必备","date":"2015-11-03T09:26:00.000Z","_content":"考试前首先要调整好自己的心态，忘却之前发生的任何事情。\n\n<strong>考试前(调试机子)\n==\n首先做好所有文件名后缀的关联，将.in，.out的文件关联至Notepad ++。\n将.cpp，.pas关联至gvim。\n在_vimrc中敲入下面配置信息\n****\n```\nsyntax on\nset nu!\ncolorscheme darkblue\n\nimap <F2> <esc>:w<cr>i\nimap <F9> <F2><esc>:!fpc -g %<cr>i\nimap <F10> <F2><esc>:!g++ -Wall -g % -o %:r<cr>i\nimap <F11> assign(input,'.in');reset(input);\nimap <F12> freopen(\".in\",\"r\",stdin);\n```\n****\n在notepad ++中设置\n****\n 1. 将窗口界面调小\n 2. 配色方案选择blackboard\n 3. 在首选项中设置自动更新文件\n****\n打好对拍程序\n****\n对拍\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t2.exe<data.in>1.out\n\t22.exe<data.in>11.out\nfc \"1.out\" \"11.out\"\nif not errorlevel 1 goto loop\npause\ngoto loop\n```\n单测\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t1.exe<data.in\n\techo .............\n\techo.\ngoto loop\n```\n****\n打好文件输入输出\n****\ncpp版本\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\treturn 0;\n}\n```\npascal版本\n\n```\nvar\ti,j,k,m,n:longint;\nbegin\n\tassign(input,'.in');reset(input);\n\tassign(output,'.out');rewrite(output);\n\t\n\tclose(input);close(output);\nend.\n```\n\n****\n测试一下g++,fpc,gdb是否可用，若不可用，将环境变量设置一下。\n\n<strong>考试中\n==\n考试时间3.5小时，有三道题目，注意分配好时间。\n1. 先浏览三道题目，确保充分理解题目意思，并且能够模拟出样例数据。自己在心中评出试题的难度等级(一般题目顺序就是难度顺序)。最好能够在15分钟完成这部分内容。\n2. 对每一道题目重新理解后，对照着数据范围想一个暴力可过好打的程序。(作为对拍的标程)，然后尽自己所能想一个最好的算法。\n\t\n - 在样例数据可以过的情况下，手动出一些小数据和一些一般性数据。然后用data生成大数据测试。\n - 在暴力确保正确性，且不超过暴力程序的数据范围的情况下，对拍“标程”。\n\n3.在完成并测试过第一题的时间最好在比赛开始后的1个小时内(方便准备后面的题目)\n4.第二三题尽量在1个小时之内完成。\n5.在考试后的最后10分钟内，停止正在做的题目，将所有的程序文件输入输出改对，去掉调试代码。还有时间在争取能否做完其他题目。\n\n<strong>考试后\n==\n1. 跟同学讨论一下试题，调整好心态，忘掉当天发生的任何事。\n2. 如果心理素质较好写个总结也是可以的\n\n<strong>NOIP知识点\n==\nhttp://blog.sina.com.cn/s/blog_6b249a4f0100uvu1.html\nhttp://www.zybang.com/question/924e718b7ff691252820f49ddec9e792.html\n","source":"_posts/NOIP-考前必备.md","raw":"---\ntitle: '[NOIP]考前必备'\ndate: 2015-11-03 17:26:00\ntags:\ncategories:\n  - 信息学\n  - 原创\n---\n考试前首先要调整好自己的心态，忘却之前发生的任何事情。\n\n<strong>考试前(调试机子)\n==\n首先做好所有文件名后缀的关联，将.in，.out的文件关联至Notepad ++。\n将.cpp，.pas关联至gvim。\n在_vimrc中敲入下面配置信息\n****\n```\nsyntax on\nset nu!\ncolorscheme darkblue\n\nimap <F2> <esc>:w<cr>i\nimap <F9> <F2><esc>:!fpc -g %<cr>i\nimap <F10> <F2><esc>:!g++ -Wall -g % -o %:r<cr>i\nimap <F11> assign(input,'.in');reset(input);\nimap <F12> freopen(\".in\",\"r\",stdin);\n```\n****\n在notepad ++中设置\n****\n 1. 将窗口界面调小\n 2. 配色方案选择blackboard\n 3. 在首选项中设置自动更新文件\n****\n打好对拍程序\n****\n对拍\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t2.exe<data.in>1.out\n\t22.exe<data.in>11.out\nfc \"1.out\" \"11.out\"\nif not errorlevel 1 goto loop\npause\ngoto loop\n```\n单测\n```\n@echo off\n:loop\n\tdata.exe>data.in\n\t1.exe<data.in\n\techo .............\n\techo.\ngoto loop\n```\n****\n打好文件输入输出\n****\ncpp版本\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\treturn 0;\n}\n```\npascal版本\n\n```\nvar\ti,j,k,m,n:longint;\nbegin\n\tassign(input,'.in');reset(input);\n\tassign(output,'.out');rewrite(output);\n\t\n\tclose(input);close(output);\nend.\n```\n\n****\n测试一下g++,fpc,gdb是否可用，若不可用，将环境变量设置一下。\n\n<strong>考试中\n==\n考试时间3.5小时，有三道题目，注意分配好时间。\n1. 先浏览三道题目，确保充分理解题目意思，并且能够模拟出样例数据。自己在心中评出试题的难度等级(一般题目顺序就是难度顺序)。最好能够在15分钟完成这部分内容。\n2. 对每一道题目重新理解后，对照着数据范围想一个暴力可过好打的程序。(作为对拍的标程)，然后尽自己所能想一个最好的算法。\n\t\n - 在样例数据可以过的情况下，手动出一些小数据和一些一般性数据。然后用data生成大数据测试。\n - 在暴力确保正确性，且不超过暴力程序的数据范围的情况下，对拍“标程”。\n\n3.在完成并测试过第一题的时间最好在比赛开始后的1个小时内(方便准备后面的题目)\n4.第二三题尽量在1个小时之内完成。\n5.在考试后的最后10分钟内，停止正在做的题目，将所有的程序文件输入输出改对，去掉调试代码。还有时间在争取能否做完其他题目。\n\n<strong>考试后\n==\n1. 跟同学讨论一下试题，调整好心态，忘掉当天发生的任何事。\n2. 如果心理素质较好写个总结也是可以的\n\n<strong>NOIP知识点\n==\nhttp://blog.sina.com.cn/s/blog_6b249a4f0100uvu1.html\nhttp://www.zybang.com/question/924e718b7ff691252820f49ddec9e792.html\n","slug":"NOIP-考前必备","published":1,"updated":"2015-12-26T04:00:07.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnve3003higtgo614xfjq","sticky":0},{"title":"[NOIP]11.21总结","date":"2015-11-21T07:49:00.000Z","_content":"T1:粉刷匠\n刚一开始看错题目啦!我认为竖着也可以粉刷,然而并不是,这只是每行粉刷。\n因为每一行都是独立的，所以可以分开一行一行染色，随后染色的数目等于T，对于每一行，只需要看这一行用j次粉刷能粉刷的最大数目是多少就可以了。\n\nT2:迷路\n在不知道是矩阵乘法时，我是没思路的，当知道是矩阵乘法时只知道边权为1时怎么做。当边权为1时，矩阵乘法一次邻接矩阵，就相当于都走了一步。\n因为边权很小在$[1,9]$之间,所以可以将一个点拆成9个点,将他们连接起来。做T次矩阵乘法，就能得到答案。\n\nT3:游戏\n将对应关系建成一幅图，发现整个图是有若干个环组成。答案就是求若干个环的大小相加为N时的$\\Sigma(LCM)$。到了这一步就不知道怎么做了。因为这里有一个性质\n\n> 考虑最小公倍数不为1的情况，这它为m。\n则m=p1^a1*p2^a2...，而对于一个m，存在一个序列的最小公倍数为m的充要条件是：\np1^a1+p2^a2+....<=n。\n\n按照上述条件做一下背包就可以了。$F[i][j]$表示做到第i个质数$\\Sigma$为j时$(j<=n)$\n\n","source":"_posts/NOIP-11-21总结.md","raw":"---\ntitle: '[NOIP]11.21总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-11-21 15:49:00\n---\nT1:粉刷匠\n刚一开始看错题目啦!我认为竖着也可以粉刷,然而并不是,这只是每行粉刷。\n因为每一行都是独立的，所以可以分开一行一行染色，随后染色的数目等于T，对于每一行，只需要看这一行用j次粉刷能粉刷的最大数目是多少就可以了。\n\nT2:迷路\n在不知道是矩阵乘法时，我是没思路的，当知道是矩阵乘法时只知道边权为1时怎么做。当边权为1时，矩阵乘法一次邻接矩阵，就相当于都走了一步。\n因为边权很小在$[1,9]$之间,所以可以将一个点拆成9个点,将他们连接起来。做T次矩阵乘法，就能得到答案。\n\nT3:游戏\n将对应关系建成一幅图，发现整个图是有若干个环组成。答案就是求若干个环的大小相加为N时的$\\Sigma(LCM)$。到了这一步就不知道怎么做了。因为这里有一个性质\n\n> 考虑最小公倍数不为1的情况，这它为m。\n则m=p1^a1*p2^a2...，而对于一个m，存在一个序列的最小公倍数为m的充要条件是：\np1^a1+p2^a2+....<=n。\n\n按照上述条件做一下背包就可以了。$F[i][j]$表示做到第i个质数$\\Sigma$为j时$(j<=n)$\n\n","slug":"NOIP-11-21总结","published":1,"updated":"2015-12-25T11:00:11.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvei003kigtg6b76t561","sticky":0},{"title":"[NOIP]10.27总结","date":"2015-10-27T14:08:00.000Z","_content":"概述\n--\n这场比赛主要是第二题题意理解上出了问题，以及第三题的推导公式还有待加强。\nT1:挑竹签\n--\n看完题目后，想着画了一下与之对应的图。发现此题就是每次取走入度为0的节点（竹签），询问最多能取多少。那就是一个拓扑排序，知道最后只剩下环。（环是无法挑的）\n\nT2：魔道研究\n--\n这题我连题目意思都理解错了，还理解错了两次。直到考试结束后经与其他人的讨论，才彻底理解了题目的意思。一开始想的题目意思太简单了。认为只是纯模拟给出的操作，最后输出结果。后面理解了题目意思，想了很久都没想到什么特别好的数据结构，最后提示用线段树，想想很快就懂了。用map存一下就好了。复杂度是O（NlogN）的。测试了些大数据级小数据后就去看第三题了。\n\nT3：魔法阵\n==\n看着这题复杂，所以直奔部分分去了，对于k=1的情况还是很好想的。每个相邻矩形中差的三角形数是定制4*6，所以等差数列求第n项就好了。对于k=2的情况想了很久，本来想放弃的，但是考试时间还多，就拿起来退了一下。可能是推错了。最后没得部分分。\n\n","source":"_posts/NOIP-10-27总结.md","raw":"---\ntitle: '[NOIP]10.27总结'\ntags:\n  - 总结\ncategories:\n  - 信息学\n  - 原创\ndate: 2015-10-27 22:08:00\n---\n概述\n--\n这场比赛主要是第二题题意理解上出了问题，以及第三题的推导公式还有待加强。\nT1:挑竹签\n--\n看完题目后，想着画了一下与之对应的图。发现此题就是每次取走入度为0的节点（竹签），询问最多能取多少。那就是一个拓扑排序，知道最后只剩下环。（环是无法挑的）\n\nT2：魔道研究\n--\n这题我连题目意思都理解错了，还理解错了两次。直到考试结束后经与其他人的讨论，才彻底理解了题目的意思。一开始想的题目意思太简单了。认为只是纯模拟给出的操作，最后输出结果。后面理解了题目意思，想了很久都没想到什么特别好的数据结构，最后提示用线段树，想想很快就懂了。用map存一下就好了。复杂度是O（NlogN）的。测试了些大数据级小数据后就去看第三题了。\n\nT3：魔法阵\n==\n看着这题复杂，所以直奔部分分去了，对于k=1的情况还是很好想的。每个相邻矩形中差的三角形数是定制4*6，所以等差数列求第n项就好了。对于k=2的情况想了很久，本来想放弃的，但是考试时间还多，就拿起来退了一下。可能是推错了。最后没得部分分。\n\n","slug":"NOIP-10-27总结","published":1,"updated":"2015-12-25T10:51:31.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnveq003oigtg53g8z53q","sticky":0},{"title":"Git教程","date":"2015-12-12T05:13:00.000Z","_content":"#关于本教程\n![Git-Logo](http://img.blog.csdn.net/20151212130120447)\n\n##史上最浅显易懂的Git教程！\n\n为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。\n\n既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？\n\n首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度；\n\n其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。\n\n##文字+图片还看不明白？有视频！！！\n\n本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。\n\n如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！\n\n##关于作者\n\n<a href=\"http://weibo.com/liaoxuefeng\">廖雪峰</a>，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在[GitHub](https://github.com/michaelliao)，欢迎微博交流：\n\n<a href=\"http://weibo.com/u/1658384301?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/1658384301/078cedea/2.png\"/></a>\n\n\n#Git简介\n\nGit是什么？\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。\n\nGit有什么特点？简单来说就是：高端大气上档次！\n\n那什么是版本控制系统？\n\n如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：\n\n想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130221073)\n\n过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。\n\n看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。\n\n更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。\n\n于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？\n\n这个软件用起来就应该像这个样子，能记录每次文件的改动：\n\n<table class=\"table table-bordered\">\n<tr><th>版本</th><th>用户</th><th>说明</th><th>日期</th></tr>\n<tr><td>1</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr>\n<tr><td>2</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr>\n<tr><td>3</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr>\n<tr><td>4</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr>\n</table>\n\n这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。\n\n##Git的诞生\n\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\n\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\n\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\n\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\n\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n\n##集中式vs分布式\n\nLinus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？\n\n先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130245660)\n\n集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。\n\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130259965)\n\n当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。\n\nCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n\n\n#安装Git\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n\n要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：\n\n## 在Linux上安装Git\n\n首先，你可以试着输入git，看看系统有没有安装Git：\n\n    $ git\n    The program 'git' is currently not installed. You can install it by typing:\n    sudo apt-get install git\n\n像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。\n\n如果你碰巧用Debian或Ubuntu Linux，通过一条“sudo apt-get install git”就可以直接完成Git的安装，非常简单。\n\n<video width=\"638\" height=\"478\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.webm\" /></video>\n\n老一点的Debian或Ubuntu Linux，要把命令改为“sudo apt-get install git-core”，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。\n\n如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。\n\n## 在Mac OS X上安装Git\n\n如果你正在使用Mac做开发，有两种安装Git的方法。\n\n一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：[http://brew.sh/](http://brew.sh/)。\n\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130320870)\n\nXcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！\n\n## 在Windows上安装Git\n\n实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。\n\nWindows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。\n\nmsysgit是Windows版的Git，从[http://msysgit.github.io/](http://msysgit.github.io/)下载，然后按默认选项安装即可。\n\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130331785)\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n    $ git config --global user.name \"Your Name\"\n    $ git config --global user.email \"email@example.com\"\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意*git config*命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n\n#创建版本库\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n    $ mkdir learngit\n    $ cd learngit\n    $ pwd\n    /Users/michael/learngit\n\npwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。\n\n<i class=\"icon-warning-sign\"></i> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\n\n    $ git init\n    Initialized empty Git repository in /Users/michael/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.webm\" /></video>\n\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n\n## 把文件添加到版本库\n\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n<i class=\"icon-warning-sign\"></i> 使用Windows的童鞋要特别注意，千万不要使用Windows自带的**记事本**编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载[Notepad++](http://notepad-plus-plus.org/)代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130355971)\n\n言归正传，现在我们编写一个readme.txt文件，内容如下：\n\n    Git is a version control system.\n    Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n第一步，用命令*git add*告诉Git，把文件添加到仓库：\n\n    $ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n\n第二步，用命令*git commit*告诉Git，把文件提交到仓库：\n\n    $ git commit -m \"wrote a readme file\"\n    [master (root-commit) cb926e7] wrote a readme file\n     1 file changed, 2 insertions(+)\n     create mode 100644 readme.txt\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.webm\" /></video>\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\n嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。\n\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。\n\n为什么Git添加文件需要*add*，*commit*一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n    $ git add file1.txt\n    $ git add file2.txt\n    $ git add file3.txt\n    $ git commit -m \"add 3 files.\"\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n* 第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；\n\n* 第二步，使用命令git commit，完成。\n\n\n#时光机穿梭\n\n我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：\n\n    Git is a distributed version control system.\n    Git is free software.\n\n现在，运行*git status*命令看看结果：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #\tmodified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n*git status*命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用*git diff*这个命令看看：\n\n    $ git diff readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 46d49bf..9247db6 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,2 +1,2 @@\n    -Git is a version control system.\n    +Git is a distributed version control system.\n     Git is free software.\n\n*git diff*顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。\n\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\n\n    $ git add readme.txt\n\n同样没有任何输出。在执行第二步git commit之前，我们再运行*git status*看看当前仓库的状态：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n*git status*告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\n\n    $ git commit -m \"add distributed\"\n    [master ea34578] add distributed\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n提交后，我们再用*git status*命令看看仓库的当前状态：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.webm\" /></video>\n\n**小结**\n\n* 要随时掌握工作区的状态，使用git status命令。\n\n* 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n##版本回退\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n然后尝试提交：\n\n    $ git add readme.txt\n    $ git commit -m \"append GPL\"\n    [master 3628164] append GPL\n    1 file changed, 1 insertion(+), 1 deletion(-)\n\n像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n\n版本1：wrote a readme file\n\n    Git is a version control system.\n    Git is free software.\n\n版本2：add distributed\n\n    Git is a distributed version control system.\n    Git is free software.\n\n版本3：append GPL\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n\n    $ git log\n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n        append GPL\n\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    add distributed\n\n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n        wrote a readme file\n\n*git log*命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\n\n    $ git log --pretty=oneline\n    3628164fb26d48395383f8f31179f24e0882e1e0 append GPL\n    ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed\n    cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file\n\n需要友情提示的是，你看到的一大串类似“ 3628164...882e1e0”的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130518407)\n\n好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164...882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：\n\n    $ git reset --hard HEAD^\n    HEAD is now at ea34578 add distributed\n\n--hard参数有啥意义？这个后面再讲，现在你先放心使用。\n\n看看readme.txt的内容是不是版本“add distributed”：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software.\n\n果然。\n\n还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用*git log*再看看现在版本库的状态：\n\n    $ git log\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    \n        add distributed\n    \n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n    \n        wrote a readme file\n\n最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“3628164...”，于是就可以指定回到未来的某个版本：\n\n    $ git reset --hard 3628164\n    HEAD is now at 3628164 append GPL\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n再小心翼翼地看看readme.txt的内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n果然，我胡汉山又回来了。\n\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130538635)\n\n改为指向“add distributed”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130611271)\n\n然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.webm\" /></video>\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用*$ git reset --hard HEAD^*回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令*git reflog*用来记录你的每一次命令：\n\n    $ git reflog\n    ea34578 HEAD@{0}: reset: moving to HEAD^\n    3628164 HEAD@{1}: commit: append GPL\n    ea34578 HEAD@{2}: commit: add distributed\n    cb926e7 HEAD@{3}: commit (initial): wrote a readme file\n\n终于舒了口气，第二行显示“append GPL”的commit id是3628164，现在，你又可以乘坐时光机回到未来了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.webm\" /></video>\n\n**小结**\n\n现在总结一下：\n\n* HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令*git reset --hard commit\\_id*。\n\n* 穿梭前，用*git log*可以查看提交历史，以便确定要回退到哪个版本。\n\n* 要重返未来，用*git reflog*查看命令历史，以便确定要回到未来的哪个版本。\n\n##工作区和暂存区\n\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n先来看名词解释。\n\n**工作区**（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130631844)\n\n**版本库**（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130639967)\n\n分支和HEAD的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，commit就是往master分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n\n然后，在工作区新增一个LICENSE文本文件（内容随便写）。\n\n先用git status查看一下状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    # Untracked files:\n    #   (use \"git add <file>...\" to include in what will be committed)\n    #\n    #       LICENSE\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nGit非常清楚地告诉我们，*readme.txt*被修改了，而*LICENSE*还从来没有被添加过，所以它的状态是Untracked。\n\n现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   LICENSE\n    #       modified:   readme.txt\n    #\n\n现在，暂存区的状态就变成这样了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130652035)\n\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n\n    $ git commit -m \"understand how stage works\"\n    [master 27c9860] understand how stage works\n     2 files changed, 675 insertions(+)\n     create mode 100644 LICENSE\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130702566)\n\n**小结**\n\n暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n\n没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。\n\n##管理修改\n\n现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes.\n\n然后，添加：\n\n    $ git add readme.txt\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n然后，再修改readme.txt：\n\n    $ cat readme.txt \n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n提交：\n\n    $ git commit -m \"git tracks changes\"\n    [master d4f25b6] git tracks changes\n     1 file changed, 1 insertion(+)\n\n提交后，再看看状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n咦，怎么第二次的修改没有被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> git add -> 第二次修改 -> git commit\n\n你看，我们前面讲了，Git管理的是修改，当你用“git add”命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，“git commit”只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n提交后，用“git diff HEAD -- readme.txt”命令可以查看工作区和版本库里面最新版本的区别：\n\n    $ git diff HEAD -- readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 76d770f..a9c5755 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,4 +1,4 @@\n     Git is a distributed version control system.\n     Git is free software distributed under the GPL.\n     Git has a mutable index called stage.\n    -Git tracks changes.\n    +Git tracks changes of files.\n\n可见，第二次修改确实没有被提交。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.webm\" /></video>\n\n那怎么提交第二次修改呢？你可以继续add再commit，也可以别着急提交第一次修改，先add第二次修改，再commit，就相当于把两次修改合并后一块提交了：\n\n第一次修改 -> add -> 第二次修改 -> add -> commit\n\n好，现在，把第二次修改提交了，然后开始小结。\n\n**小结**\n\n现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。\n\n##撤销修改\n\n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n\n在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！\n\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用*git status*查看一下：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n你可以发现，Git会告诉你，*git checkout -- file*可以丢弃工作区的修改：\n\n    $ git checkout -- readme.txt\n\n命令*git checkout -- readme.txt*意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n现在，看看readme.txt的文件内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n文件内容果然复原了。\n\n*git checkout -- file*命令中的“--”很重要，没有“--”，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到*git checkout*命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.webm\" /></video>\n\n现在假定是凌晨3点，你不但写了一些胡话，还*git add*到暂存区了：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n    \n    $ git add readme.txt\n\n庆幸的是，在commit之前，你发现了这个问题。用*git status*查看一下，修改只是添加到了暂存区，还没有提交：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\nGit同样告诉我们，用命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n    $ git reset HEAD readme.txt\n    Unstaged changes after reset:\n    M       readme.txt\n\n*git reset*命令既可以回退版本，也可以把工作区的某些文件替换为版本库中的文件。当我们用HEAD时，表示最新的版本。\n\n再用*git status*查看一下，现在暂存区是干净的，工作区有修改：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n还记得如何丢弃工作区的修改吗？\n\n    $ git checkout -- readme.txt\n    \n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n整个世界终于清静了！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.webm\" /></video>\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退](file/时光机穿梭.md#anchor_1)一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……\n\n**小结**\n\n又到了小结时间。\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令*git checkout -- file*。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令*git reset HEAD file*，就回到了场景1，第二步按场景1操作。\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](file/时光机穿梭.md#anchor_1)一节，不过前提是没有推送到远程库。\n\n##删除文件\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n\n    $ git add test.txt\n    $ git commit -m \"add test.txt\"\n    [master 94cdc44] add test.txt\n     1 file changed, 1 insertion(+)\n     create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n\n    $ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，*git status*命令会立刻告诉你哪些文件被删除了：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add/rm <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       deleted:    test.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令*git rm*删掉，并且commit：\n\n    $ git rm test.txt\n    rm 'test.txt'\n    $ git commit -m \"remove test.txt\"\n    [master d17efd8] remove test.txt\n     1 file changed, 1 deletion(-)\n     delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.webm\" /></video>\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n    $ git checkout -- test.txt\n\n*git checkout*其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**小结**\n\n命令*git rm*用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n\n#远程仓库\n\n到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。\n\n可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。\n\n没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。\n\nGit是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。\n\n你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？\n\n其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。\n\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\n\n完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫[GitHub](https://github.com/)的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n\n在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id\\_rsa和id\\_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n    $ ssh-keygen -t rsa -C \"your\\_email@example.com\"\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.webm\" /></video>\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id\\_rsa和id\\_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id\\_rsa是私钥，不能泄露出去，id\\_rsa.pub是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id\\_rsa.pub文件的内容：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130738501)\n\n点“Add Key”，你就应该看到已经添加的Key：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130748040)\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n\n**小结**\n\n“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机\n\n##添加远程库\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130803583)\n\n在Repository name填入*learngit*，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130812619)\n\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n\n    $ git remote add origin git@github.com:michaelliao/learngit.git\n\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n\n添加后，远程库的名字就是*origin*，这是Git默认的叫法，也可以改成别的，但是*origin*这个名字一看就知道是远程库。\n\n下一步，就可以把本地库的所有内容推送到远程库上：\n\n    $ git push -u origin master\n    Counting objects: 19, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (19/19), done.\n    Writing objects: 100% (19/19), 13.73 KiB, done.\n    Total 23 (delta 6), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new branch]      master -> master\n    Branch master set up to track remote branch master from origin.\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.webm\" /></video>\n\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130830387)\n\n从现在起，只要本地作了提交，就可以通过命令：\n\n    $ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n**小结**\n\n要关联一个远程库，使用命令*git remote add origin git@server-name:path/repo-name.git*；\n\n关联后，使用命令*git push -u origin master*第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令*git push origin master*推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##从远程库克隆\n\n上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130842191)\n\n我们勾选*Initialize this repository with a README*，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130850414)\n\n现在，远程库已经准备好了，下一步是用命令*git clone*克隆一个本地库：\n\n    $ git clone git@github.com:michaelliao/gitskills.git\n    Cloning into 'gitskills'...\n    remote: Counting objects: 3, done.\n    remote: Total 3 (delta 0), reused 0 (delta 0)\n    Receiving objects: 100% (3/3), done.\n\n    $ cd gitskills\n    $ ls\n    README.md\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.webm\" /></video>\n\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用*https://github.com/michaelliao/gitskills.git*这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n**小结**\n\n要克隆一个仓库，首先必须知道仓库的地址，然后使用*git clone*命令克隆。\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n\n#分支管理\n\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\n\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。问题是，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130904432)\n\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。\n\n但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n##创建与合并分支\n\n在[版本回退](file/时光机穿梭.md#anchor_1)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130949931)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.webm\" /></video>\n\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130958401)\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131005897)\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131013034)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131034735)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.webm\" /></video>\n\n下面开始实战。\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n*git checkout*命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n    $ git branch dev\n    $ git checkout dev\n    Switched to branch 'dev'\n\n然后，用*git branch*命令查看当前分支：\n\n    $ git branch\n    * dev\n      master\n\n*git branch*命令会列出所有分支，当前分支前面会标一个\\*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\n\n    Creating a new branch is quick.\n\n然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"branch test\"\n    [dev fec145a] branch test\n     1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131104567)\n\n现在，我们把dev分支的工作成果合并到master分支上：\n\n    $ git merge dev\n    Updating d17efd8..fec145a\n    Fast-forward\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n*git merge*命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能*Fast-forward*，我们后面会将其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n\n    $ git branch -d dev\n    Deleted branch dev (was fec145a).\n\n删除后，查看branch，就只剩下master分支了：\n\n    $ git branch\n    * master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.webm\" /></video>\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：git branch\n\n创建分支：git branch *name*\n\n切换分支：git checkout *name*\n\n创建+切换分支：git checkout -b *name*\n\n合并某分支到当前分支：git merge *name*\n\n删除分支：git branch -d *name*\n\n##解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的feature1分支，继续我们的新分支开发：\n\n    $ git checkout -b feature1\n    Switched to a new branch 'feature1'\n\n修改readme.txt最后一行，改为：\n\n    Creating a new branch is quick AND simple.\n\n在feature1分支上提交：\n\n    $ git add readme.txt \n    $ git commit -m \"AND simple\"\n    [feature1 75a857c] AND simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n切换到master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 1 commit.\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n\n在master分支上把readme.txt文件的最后一行改为：\n\n    Creating a new branch is quick & simple.\n\n提交：\n\n    $ git add readme.txt \n    $ git commit -m \"& simple\"\n    [master 400b400] & simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131125396)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n    $ git merge feature1\n    Auto-merging readme.txt\n    CONFLICT (content): Merge conflict in readme.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。*git status*也可以告诉我们冲突的文件：\n\n    $ git status\n    # On branch master\n    # Your branch is ahead of 'origin/master' by 2 commits.\n    #\n    # Unmerged paths:\n    #   (use \"git add/rm <file>...\" as appropriate to mark resolution)\n    #\n    #       both modified:      readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n我们可以直接查看readme.txt的内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    <<<<<<< HEAD\n    Creating a new branch is quick & simple.\n    =======\n    Creating a new branch is quick AND simple.\n    >>>>>>> feature1\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：\n\n    Creating a new branch is quick and simple.\n\n再提交：\n\n    $ git add readme.txt \n    $ git commit -m \"conflict fixed\"\n    [master 59bc1cb] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131136505)\n\n用带参数的*git log*也可以看到分支的合并情况：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   59bc1cb conflict fixed\n    |\\\n    | * 75a857c AND simple\n    * | 400b400 & simple\n    |/\n    * fec145a branch test\n    ...\n\n现在，删除feature1分支：\n\n    $ git branch -d feature1\n    Deleted branch feature1 (was 75a857c).\n\n工作完成。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.webm\" /></video>\n\n**小结**\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n用*git log --graph*命令可以看到分支合并图。\n\n##分支管理策略\n\n通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下*--no-ff*方式的merge：\n\n首先，仍然创建并切换dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n修改readme.txt文件，并提交一个新的commit：\n\n    $ git add readme.txt \n    $ git commit -m \"add merge\"\n    [dev 6224937] add merge\n     1 file changed, 1 insertion(+)\n\n现在，我们切换会master：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n准备合并dev分支，请注意*--no-ff*参数，表示禁用“Fast forward”：\n\n    $ git merge --no-ff -m \"merge with no-ff\" dev\n    Merge made by the 'recursive' strategy.\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n因为本次合并要创建一个新的commit，所以加上*-m*参数，把commit描述写进去。\n\n合并后，我们用*git log*看看分支历史：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   7825a50 merge with no-ff\n    |\\\n    | * 6224937 add merge\n    |/\n    *   59bc1cb conflict fixed\n    ...\n\n可以看到，不使用“Fast forward”模式，merge后就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131151608)\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.webm\" /></video>\n\n### 分支策略\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131159864)\n\n**小结**\n\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上*--no-ff*参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而*fast forward*合并就看不出来曾经做过合并。\n\n##Bug分支\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n    $ git status\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n    $ git stash\n    Saved working directory and index state WIP on dev: 6224937 add merge\n    HEAD is now at 6224937 add merge\n\n现在，用*git status*查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 6 commits.\n    $ git checkout -b issue-101\n    Switched to a new branch 'issue-101'\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"fix bug 101\"\n    [issue-101 cc17032] fix bug 101\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 2 commits.\n    $ git merge --no-ff -m \"merged bug fix 101\" issue-101\n    Merge made by the 'recursive' strategy.\n     readme.txt |    2 +-\n     1 file changed, 1 insertion(+), 1 deletion(-)\n    $ git branch -d issue-101\n    Deleted branch issue-101 (was cc17032).\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n    $ git checkout dev\n    Switched to branch 'dev'\n    $ git status\n    # On branch dev\n    nothing to commit (working directory clean)\n\n工作区是干净的，刚才的工作现场存到哪去了？用*git stash list*命令看看：\n\n    $ git stash list\n    stash@{0}: WIP on dev: 6224937 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用*git stash apply*恢复，但是恢复后，stash内容并不删除，你需要用*git stash drop*来删除；\n\n另一种方式是用*git stash pop*，恢复的同时把stash内容也删了：\n\n    $ git stash pop\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)\n\n再用*git stash list*查看，就看不到任何stash内容了：\n\n    $ git stash list\n\n你可以多次stash，恢复的时候，先用*git stash list*查看，然后恢复指定的stash，用命令：\n\n    $ git stash apply stash@{0}\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.webm\" /></video>\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场*git stash*一下，然后去修复bug，修复后，再*git stash pop*，回到工作现场。\n\n##Feature分支\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n    $ git checkout -b feature-vulcan\n    Switched to a new branch 'feature-vulcan'\n\n5分钟后，开发完毕：\n\n    $ git status\n    # On branch feature-vulcan\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   vulcan.py\n    #\n    $ git commit -m \"add feature vulcan\"\n    [feature-vulcan 756d4af] add feature vulcan\n     1 file changed, 2 insertions(+)\n     create mode 100644 vulcan.py\n\n切回dev，准备合并：\n\n    $ git checkout dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是，\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个分支还是必须就地销毁：\n\n    $ git branch -d feature-vulcan\n    error: The branch 'feature-vulcan' is not fully merged.\n    If you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令*git branch -D feature-vulcan*。\n\n现在我们强行删除：\n\n    $ git branch -D feature-vulcan\n    Deleted branch feature-vulcan (was 756d4af).\n\n终于删除成功！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.webm\" /></video>\n\n**小结**\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过*git branch -D name*强行删除。\n\n##多人协作\n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用*git remote*：\n\n    $ git remote\n    origin\n\n或者，用*git remote -v*显示更详细的信息：\n\n    $ git remote -v\n    origin  git@github.com:michaelliao/learngit.git (fetch)\n    origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n    $ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n\n    $ git push origin dev\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n* master分支是主分支，因此要时刻与远程同步；\n\n* dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n* bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n* feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.webm\" /></video>\n\n### 抓取分支\n\n多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n    $ git clone git@github.com:michaelliao/learngit.git\n    Cloning into 'learngit'...\n    remote: Counting objects: 46, done.\n    remote: Compressing objects: 100% (26/26), done.\n    remote: Total 46 (delta 16), reused 45 (delta 15)\n    Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.\n    Resolving deltas: 100% (16/16), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用*git branch*命令看看：\n\n    $ git branch\n    * master\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n    $ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n    $ git commit -m \"add /usr/bin/env\"\n    [dev 291bea8] add /usr/bin/env\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    Counting objects: 5, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (2/2), done.\n    Writing objects: 100% (3/3), 349 bytes, done.\n    Total 3 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       fc38031..291bea8  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.webm\" /></video>\n\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n    $ git add hello.py \n    $ git commit -m \"add coding: utf-8\"\n    [dev bd6ae48] add coding: utf-8\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    To git@github.com:michaelliao/learngit.git\n     ! [rejected]        dev -> dev (non-fast-forward)\n    error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\n    hint: Updates were rejected because the tip of your current branch is behind\n    hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')\n    hint: before pushing again.\n    hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用*git pull*把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n    $ git pull\n    remote: Counting objects: 5, done.\n    remote: Compressing objects: 100% (2/2), done.\n    remote: Total 3 (delta 0), reused 3 (delta 0)\n    Unpacking objects: 100% (3/3), done.\n    From github.com:michaelliao/learngit\n       fc38031..291bea8  dev        -> origin/dev\n    There is no tracking information for the current branch.\n    Please specify which branch you want to merge with.\n    See git-pull(1) for details\n    \n        git pull <remote> <branch>\n    \n    If you wish to set tracking information for this branch you can do so with:\n    \n        git branch --set-upstream dev origin/<branch>\n\n*git pull*也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n    $ git branch --set-upstream dev origin/dev\n    Branch dev set up to track remote branch dev from origin.\n\n再pull：\n\n    $ git pull\n    Auto-merging hello.py\n    CONFLICT (content): Merge conflict in hello.py\n    Automatic merge failed; fix conflicts and then commit the result.\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000)完全一样。解决后，提交，再push：\n\n    $ git commit -m \"merge & fix hello.py\"\n    [dev adca45d] merge & fix hello.py\n    $ git push origin dev\n    Counting objects: 10, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (5/5), done.\n    Writing objects: 100% (6/6), 747 bytes, done.\n    Total 6 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       291bea8..adca45d  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.webm\" /></video>\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用*git push origin branch-name*推送自己的修改；\n\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用*git pull*试图合并；\n\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n\n4. 没有冲突或者解决掉冲突后，再用*git push origin branch-name*推送就能成功！\n\n如果*git pull*提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令*git branch --set-upstream branch-name origin/branch-name*。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n* 查看远程库信息，使用*git remote -v*；\n\n* 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n* 从本地推送分支，使用*git push origin branch-name*，如果推送失败，先用*git pull*抓取远程的新提交；\n\n* 在本地创建和远程分支对应的分支，使用*git checkout -b branch-name origin/branch-name*，本地和远程分支的名称最好一致；\n\n* 建立本地分支和远程分支的关联，使用*git branch --set-upstream branch-name origin/branch-name*；\n\n* 从远程抓取分支，使用*git pull*，如果有冲突，要先处理冲突。\n\n\n#标签管理\n\n发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\n\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\n\n##创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n\n    $ git branch\n    * dev\n      master\n    $ git checkout master\n    Switched to branch 'master'\n\n然后，敲命令*git tag name*就可以打一个新标签：\n\n    $ git tag v1.0\n\n可以用命令*git tag*查看所有标签：\n\n    $ git tag\n    v1.0\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n\n方法是找到历史提交的commit id，然后打上就可以了：\n\n    $ git log --pretty=oneline --abbrev-commit\n    6a5819e merged bug fix 101\n    cc17032 fix bug 101\n    7825a50 merge with no-ff\n    6224937 add merge\n    59bc1cb conflict fixed\n    400b400 & simple\n    75a857c AND simple\n    fec145a branch test\n    d17efd8 remove test.txt\n    ...\n\n比方说要对“add merge”这次提交打标签，它对应的commit id是“6224937”，敲入命令：\n\n    $ git tag v0.9 6224937\n\n再用命令*git tag*查看标签：\n\n    $ git tag\n    v0.9\n    v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用*git show tagname*查看标签信息：\n\n    $ git show v0.9\n    commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 11:22:08 2013 +0800\n    \n        add merge\n    ...\n\n可以看到，“v0.9”确实打在“add merge”这次提交上。\n\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n\n    $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n\n用命令*git show tagname*可以看到说明文字：\n\n    $ git show v0.1\n    tag v0.1\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:11 2013 +0800\n    \n    version 0.1 released\n    \n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n    \n        append GPL\n    ...\n\n还可以通过-s用私钥签名一个标签：\n\n    $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：\n\n    gpg: signing failed: secret key not available\n    error: gpg failed to sign the data\n    error: unable to sign the tag\n\n如果报错，请参考GnuPG帮助文档配置Key。\n\n用命令*git show tagname*可以看到PGP签名信息：\n\n    $ git show v0.2\n    tag v0.2\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:33 2013 +0800\n    \n    signed version 0.2 released\n    -----BEGIN PGP SIGNATURE-----\n    Version: GnuPG v1.4.12 (Darwin)\n    \n    iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...\n    -----END PGP SIGNATURE-----\n    \n    commit fec145accd63cdc9ed95a2f557ea0658a2a6537f\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 10:37:30 2013 +0800\n    \n        branch test\n    ...\n\n用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.webm\" /></video>\n\n**小结**\n\n* 命令*git tag name*用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n* -a tagname -m \"blablabla...\"可以指定标签信息；\n\n* -s tagname -m \"blablabla...\"可以用PGP签名标签；\n\n* 命令*git tag*可以查看所有标签；\n\n##操作标签\n\n如果标签打错了，也可以删除：\n\n    $ git tag -d v0.1\n    Deleted tag 'v0.1' (was e078af9)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n\n如果要推送某个标签到远程，使用命令git push origin tagname：\n\n    $ git push origin v1.0\n    Total 0 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v1.0 -> v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n    $ git push origin --tags\n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 554 bytes, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v0.2 -> v0.2\n     * [new tag]         v0.9 -> v0.9\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n    $ git tag -d v0.9\n    Deleted tag 'v0.9' (was 6224937)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n    $ git push origin :refs/tags/v0.9\n    To git@github.com:michaelliao/learngit.git\n     - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.webm\" /></video>\n\n**小结**\n\n* 命令*git push origin tagname*可以推送一个本地标签；\n\n* 命令*git push origin --tags*可以推送全部未推送过的本地标签；\n\n* 命令*git tag -d tagname*可以删除一个本地标签；\n\n* 命令*git push origin :refs/tags/tagname*可以删除一个远程标签。\n\n\n#自定义Git\n\n在[安装Git](file/git安装.md#anchor_0)一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。\n\n比如，让Git显示颜色，会让命令输出看起来更醒目：\n\n    $ git config --global color.ui true\n\n这样，Git会适当地显示不同的颜色，比如*git status*命令：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131228046)\n\n文件名就会标上颜色。\n\n我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。\n\n##忽略特殊文件\n\n有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次*git status*都会显示“Untracked files ...”，有强迫症的童鞋心里肯定不爽。\n\n好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的*.gitignore*文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n\n不需要从头写*.gitignore*文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：[https://github.com/github/gitignore](https://github.com/github/gitignore)\n\n忽略文件的原则是：\n\n1. 忽略操作系统自动生成的文件，比如缩略图等；\n2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的*.class*文件；\n3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n举个例子：\n\n假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有*Desktop.ini*文件，因此你需要忽略Windows自动生成的垃圾文件：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n\n然后，继续忽略Python编译产生的*.pyc*、*.pyo*、*dist*等文件或目录：\n\n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n\n加上你自己定义的文件，最终得到一个完整的*.gitignore*文件，内容如下：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n    \n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n    \n    # My configurations:\n    db.ini\n    deploy_key_rsa\n\n最后一步就是把*.gitignore*也提交到Git，就完成了！当然检验*.gitignore*的标准是*git status*命令是不是说“working directory clean”。\n\n**小结**\n\n1. 忽略某些文件时，需要编写*.gitignore*。\n2. *.gitignore*文件本身要放到版本库里，并且可以对*.gitignore*做版本管理！\n\n##配置别名\n\n有没有经常敲错命令？比如*git status*？*status*这个单词真心不好记。\n\n如果敲*git st*就表示*git status*那就简单多了，当然这种偷懒的办法我们是极力赞成的。\n\n我们只需要敲一行命令，告诉Git，以后*st*就表示*status*：\n\n    $ git config --global alias.st status\n\n好了，现在敲*git st*看看效果。\n\n当然还有别的命令可以简写，很多人都用*co*表示*checkout*，*ci*表示*commit*，*br*表示*branch*：\n\n    $ git config --global alias.co checkout\n    $ git config --global alias.ci commit\n    $ git config --global alias.br branch\n\n以后提交就可以简写成：\n\n    $ git ci -m \"bala bala bala...\"\n\n*--global*参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。\n\n在[撤销修改](file/时光机穿梭.md#anchor_4)一节中，我们知道，命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：\n\n    $ git config --global alias.unstage 'reset HEAD'\n\n当你敲入命令：\n\n    $ git unstage test.py\n\n实际上Git执行的是：\n\n    $ git reset HEAD test.py\n\n配置一个*git last*，让其显示最后一次提交信息：\n\n    $ git config --global alias.last 'log -1'\n\n这样，用*git last*就能显示最近一次的提交：\n\n    $ git last\n    commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2\n    Merge: bd6ae48 291bea8\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 22:49:22 2013 +0800\n    \n        merge & fix hello.py\n\n甚至还有人丧心病狂地把*lg*配置成了：\n\n    git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n\n来看看*git lg*的效果：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131238572)\n\n为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！\n\n**小结**\n\n给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。\n\n##搭建Git服务器\n\n在[远程仓库](file/远程仓库.md#anchor_0)一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。\n\nGitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。\n\n搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n\n假设你已经有sudo权限的用户账号，下面，正式开始安装。\n\n第一步，安装git：\n\n    $ sudo apt-get install git\n\n第二步，创建一个git用户，用来运行git服务：\n\n    $ sudo adduser git\n\n第三步，创建证书登录：\n\n收集所有需要登录的用户的公钥，就是他们自己的id\\_rsa.pub文件，把所有公钥导入到*/home/git/.ssh/authorized\\_keys*文件里，一行一个。\n\n第四步，初始化Git仓库：\n\n先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：\n\n    $ sudo git init --bare sample.git\n\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n\n    $ sudo chown -R git:git sample.git\n\n第五步，禁用shell登录：\n\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n\n    git:x:1001:1001:,,,:/home/git:/bin/bash\n\n改为：\n\n    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n\n第六步，克隆远程仓库：\n\n现在，可以通过*git clone*命令克隆远程仓库了，在各自的电脑上运行：\n\n    $ git clone git@server:/srv/sample.git\n    Cloning into 'sample'...\n    warning: You appear to have cloned an empty repository.\n\n剩下的推送就简单了。\n\n### 管理公钥\n\n如果团队很小，把每个人的公钥收集起来放到服务器的*/home/git/.ssh/authorized\\_keys*文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用[Gitosis](https://github.com/res0nat0r/gitosis)来管理公钥。\n\n这里我们不介绍怎么玩[Gitosis](https://github.com/res0nat0r/gitosis)了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。\n\n### 管理权限\n\n有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。[Gitolite](https://github.com/sitaramc/gitolite)就是这个工具。\n\n这里我们也不介绍[Gitolite](https://github.com/sitaramc/gitolite)了，不要把有限的生命浪费到权限斗争中。\n\n**小结**\n\n搭建Git服务器非常简单，通常10分钟即可完成；\n\n要方便管理公钥，用[Gitosis](https://github.com/sitaramc/gitolite)；\n\n要像SVN那样变态地控制权限，用[Gitolite](https://github.com/sitaramc/gitolite)。\n\n\n#期末总结\n\n终于到了期末总结的时刻了！\n\n经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。\n\nGit虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。\n\n友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：\n\n[Git Cheat Sheet](http://www.git-tower.com/blog/assets/2013-05-22-git-cheat-sheet/cheat-sheet-large01.png)\n\n现在告诉你Git的官方网站：[http://git-scm.com](http://git-scm.com)，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。\n\n如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。为了激励我写出更优秀的教程，你可以考虑赠送我一杯咖啡，至于是喝麦当劳还是星巴克就看你的心情了。有支付宝的童鞋请狠狠地点这里：\n\n<a href=\"https://me.alipay.com/askxuefeng\" target=\"_blank\" class=\"btn btn-success btn-large\" style=\"padding-left:60px;background-repeat:no-repeat;background-position:15px center;background-image:url(http://static.itranswarp.com/0013738742366844b31d0ceab84491682c4556f8daa5101000/attachment/2013/8/12/9d9043ba785d43ab8f4cffb04a4b1300.png)\">请我喝咖啡</a>\n\n谢谢观看！","source":"_posts/Git教程.md","raw":"---\ntitle: Git教程\ndate: 2015-12-12 13:13:00\ntags: [教程,版本控制]\ncategories: [互联网,转载]\n---\n#关于本教程\n![Git-Logo](http://img.blog.csdn.net/20151212130120447)\n\n##史上最浅显易懂的Git教程！\n\n为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。\n\n既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？\n\n首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度；\n\n其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。\n\n##文字+图片还看不明白？有视频！！！\n\n本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。\n\n如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！\n\n##关于作者\n\n<a href=\"http://weibo.com/liaoxuefeng\">廖雪峰</a>，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在[GitHub](https://github.com/michaelliao)，欢迎微博交流：\n\n<a href=\"http://weibo.com/u/1658384301?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/1658384301/078cedea/2.png\"/></a>\n\n\n#Git简介\n\nGit是什么？\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。\n\nGit有什么特点？简单来说就是：高端大气上档次！\n\n那什么是版本控制系统？\n\n如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：\n\n想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130221073)\n\n过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。\n\n看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。\n\n更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。\n\n于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？\n\n这个软件用起来就应该像这个样子，能记录每次文件的改动：\n\n<table class=\"table table-bordered\">\n<tr><th>版本</th><th>用户</th><th>说明</th><th>日期</th></tr>\n<tr><td>1</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr>\n<tr><td>2</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr>\n<tr><td>3</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr>\n<tr><td>4</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr>\n</table>\n\n这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。\n\n##Git的诞生\n\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\n\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\n\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\n\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\n\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n\n##集中式vs分布式\n\nLinus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？\n\n先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130245660)\n\n集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。\n\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130259965)\n\n当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。\n\nCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n\n\n#安装Git\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n\n要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：\n\n## 在Linux上安装Git\n\n首先，你可以试着输入git，看看系统有没有安装Git：\n\n    $ git\n    The program 'git' is currently not installed. You can install it by typing:\n    sudo apt-get install git\n\n像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。\n\n如果你碰巧用Debian或Ubuntu Linux，通过一条“sudo apt-get install git”就可以直接完成Git的安装，非常简单。\n\n<video width=\"638\" height=\"478\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.webm\" /></video>\n\n老一点的Debian或Ubuntu Linux，要把命令改为“sudo apt-get install git-core”，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。\n\n如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。\n\n## 在Mac OS X上安装Git\n\n如果你正在使用Mac做开发，有两种安装Git的方法。\n\n一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：[http://brew.sh/](http://brew.sh/)。\n\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130320870)\n\nXcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！\n\n## 在Windows上安装Git\n\n实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。\n\nWindows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。\n\nmsysgit是Windows版的Git，从[http://msysgit.github.io/](http://msysgit.github.io/)下载，然后按默认选项安装即可。\n\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130331785)\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n    $ git config --global user.name \"Your Name\"\n    $ git config --global user.email \"email@example.com\"\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意*git config*命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n\n#创建版本库\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n    $ mkdir learngit\n    $ cd learngit\n    $ pwd\n    /Users/michael/learngit\n\npwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。\n\n<i class=\"icon-warning-sign\"></i> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\n\n    $ git init\n    Initialized empty Git repository in /Users/michael/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.webm\" /></video>\n\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n\n## 把文件添加到版本库\n\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n<i class=\"icon-warning-sign\"></i> 使用Windows的童鞋要特别注意，千万不要使用Windows自带的**记事本**编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载[Notepad++](http://notepad-plus-plus.org/)代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130355971)\n\n言归正传，现在我们编写一个readme.txt文件，内容如下：\n\n    Git is a version control system.\n    Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n第一步，用命令*git add*告诉Git，把文件添加到仓库：\n\n    $ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n\n第二步，用命令*git commit*告诉Git，把文件提交到仓库：\n\n    $ git commit -m \"wrote a readme file\"\n    [master (root-commit) cb926e7] wrote a readme file\n     1 file changed, 2 insertions(+)\n     create mode 100644 readme.txt\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.webm\" /></video>\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\n嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。\n\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。\n\n为什么Git添加文件需要*add*，*commit*一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n    $ git add file1.txt\n    $ git add file2.txt\n    $ git add file3.txt\n    $ git commit -m \"add 3 files.\"\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n* 第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；\n\n* 第二步，使用命令git commit，完成。\n\n\n#时光机穿梭\n\n我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：\n\n    Git is a distributed version control system.\n    Git is free software.\n\n现在，运行*git status*命令看看结果：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #\tmodified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n*git status*命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用*git diff*这个命令看看：\n\n    $ git diff readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 46d49bf..9247db6 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,2 +1,2 @@\n    -Git is a version control system.\n    +Git is a distributed version control system.\n     Git is free software.\n\n*git diff*顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。\n\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\n\n    $ git add readme.txt\n\n同样没有任何输出。在执行第二步git commit之前，我们再运行*git status*看看当前仓库的状态：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n*git status*告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\n\n    $ git commit -m \"add distributed\"\n    [master ea34578] add distributed\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n提交后，我们再用*git status*命令看看仓库的当前状态：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.webm\" /></video>\n\n**小结**\n\n* 要随时掌握工作区的状态，使用git status命令。\n\n* 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n##版本回退\n现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n然后尝试提交：\n\n    $ git add readme.txt\n    $ git commit -m \"append GPL\"\n    [master 3628164] append GPL\n    1 file changed, 1 insertion(+), 1 deletion(-)\n\n像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n\n版本1：wrote a readme file\n\n    Git is a version control system.\n    Git is free software.\n\n版本2：add distributed\n\n    Git is a distributed version control system.\n    Git is free software.\n\n版本3：append GPL\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n\n    $ git log\n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n        append GPL\n\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    add distributed\n\n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n        wrote a readme file\n\n*git log*命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\n\n    $ git log --pretty=oneline\n    3628164fb26d48395383f8f31179f24e0882e1e0 append GPL\n    ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed\n    cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file\n\n需要友情提示的是，你看到的一大串类似“ 3628164...882e1e0”的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130518407)\n\n好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164...882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：\n\n    $ git reset --hard HEAD^\n    HEAD is now at ea34578 add distributed\n\n--hard参数有啥意义？这个后面再讲，现在你先放心使用。\n\n看看readme.txt的内容是不是版本“add distributed”：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software.\n\n果然。\n\n还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用*git log*再看看现在版本库的状态：\n\n    $ git log\n    commit ea34578d5496d7dd233c827ed32a8cd576c5ee85\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 14:53:12 2013 +0800\n    \n        add distributed\n    \n    commit cb926e7ea50ad11b8f9e909c05226233bf755030\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 19 17:51:55 2013 +0800\n    \n        wrote a readme file\n\n最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“3628164...”，于是就可以指定回到未来的某个版本：\n\n    $ git reset --hard 3628164\n    HEAD is now at 3628164 append GPL\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n再小心翼翼地看看readme.txt的内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n\n果然，我胡汉山又回来了。\n\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130538635)\n\n改为指向“add distributed”：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130611271)\n\n然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.webm\" /></video>\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用*$ git reset --hard HEAD^*回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令*git reflog*用来记录你的每一次命令：\n\n    $ git reflog\n    ea34578 HEAD@{0}: reset: moving to HEAD^\n    3628164 HEAD@{1}: commit: append GPL\n    ea34578 HEAD@{2}: commit: add distributed\n    cb926e7 HEAD@{3}: commit (initial): wrote a readme file\n\n终于舒了口气，第二行显示“append GPL”的commit id是3628164，现在，你又可以乘坐时光机回到未来了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.webm\" /></video>\n\n**小结**\n\n现在总结一下：\n\n* HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令*git reset --hard commit\\_id*。\n\n* 穿梭前，用*git log*可以查看提交历史，以便确定要回退到哪个版本。\n\n* 要重返未来，用*git reflog*查看命令历史，以便确定要回到未来的哪个版本。\n\n##工作区和暂存区\n\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n先来看名词解释。\n\n**工作区**（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130631844)\n\n**版本库**（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。\n\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130639967)\n\n分支和HEAD的概念我们以后再讲。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，commit就是往master分支上提交更改。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n\n然后，在工作区新增一个LICENSE文本文件（内容随便写）。\n\n先用git status查看一下状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    # Untracked files:\n    #   (use \"git add <file>...\" to include in what will be committed)\n    #\n    #       LICENSE\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nGit非常清楚地告诉我们，*readme.txt*被修改了，而*LICENSE*还从来没有被添加过，所以它的状态是Untracked。\n\n现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   LICENSE\n    #       modified:   readme.txt\n    #\n\n现在，暂存区的状态就变成这样了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130652035)\n\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n\n    $ git commit -m \"understand how stage works\"\n    [master 27c9860] understand how stage works\n     2 files changed, 675 insertions(+)\n     create mode 100644 LICENSE\n\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n\n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n现在版本库变成了这样，暂存区就没有任何内容了：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130702566)\n\n**小结**\n\n暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n\n没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。\n\n##管理修改\n\n现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes.\n\n然后，添加：\n\n    $ git add readme.txt\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\n然后，再修改readme.txt：\n\n    $ cat readme.txt \n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n提交：\n\n    $ git commit -m \"git tracks changes\"\n    [master d4f25b6] git tracks changes\n     1 file changed, 1 insertion(+)\n\n提交后，再看看状态：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n咦，怎么第二次的修改没有被提交？\n\n别激动，我们回顾一下操作过程：\n\n第一次修改 -> git add -> 第二次修改 -> git commit\n\n你看，我们前面讲了，Git管理的是修改，当你用“git add”命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，“git commit”只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n提交后，用“git diff HEAD -- readme.txt”命令可以查看工作区和版本库里面最新版本的区别：\n\n    $ git diff HEAD -- readme.txt \n    diff --git a/readme.txt b/readme.txt\n    index 76d770f..a9c5755 100644\n    --- a/readme.txt\n    +++ b/readme.txt\n    @@ -1,4 +1,4 @@\n     Git is a distributed version control system.\n     Git is free software distributed under the GPL.\n     Git has a mutable index called stage.\n    -Git tracks changes.\n    +Git tracks changes of files.\n\n可见，第二次修改确实没有被提交。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.webm\" /></video>\n\n那怎么提交第二次修改呢？你可以继续add再commit，也可以别着急提交第一次修改，先add第二次修改，再commit，就相当于把两次修改合并后一块提交了：\n\n第一次修改 -> add -> 第二次修改 -> add -> commit\n\n好，现在，把第二次修改提交了，然后开始小结。\n\n**小结**\n\n现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。\n\n##撤销修改\n\n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n\n在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！\n\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用*git status*查看一下：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n你可以发现，Git会告诉你，*git checkout -- file*可以丢弃工作区的修改：\n\n    $ git checkout -- readme.txt\n\n命令*git checkout -- readme.txt*意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n现在，看看readme.txt的文件内容：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n\n文件内容果然复原了。\n\n*git checkout -- file*命令中的“--”很重要，没有“--”，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到*git checkout*命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.webm\" /></video>\n\n现在假定是凌晨3点，你不但写了一些胡话，还*git add*到暂存区了：\n\n    $ cat readme.txt\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    My stupid boss still prefers SVN.\n    \n    $ git add readme.txt\n\n庆幸的是，在commit之前，你发现了这个问题。用*git status*查看一下，修改只是添加到了暂存区，还没有提交：\n\n    $ git status\n    # On branch master\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       modified:   readme.txt\n    #\n\nGit同样告诉我们，用命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n    $ git reset HEAD readme.txt\n    Unstaged changes after reset:\n    M       readme.txt\n\n*git reset*命令既可以回退版本，也可以把工作区的某些文件替换为版本库中的文件。当我们用HEAD时，表示最新的版本。\n\n再用*git status*查看一下，现在暂存区是干净的，工作区有修改：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n还记得如何丢弃工作区的修改吗？\n\n    $ git checkout -- readme.txt\n    \n    $ git status\n    # On branch master\n    nothing to commit (working directory clean)\n\n整个世界终于清静了！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.webm\" /></video>\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退](file/时光机穿梭.md#anchor_1)一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……\n\n**小结**\n\n又到了小结时间。\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令*git checkout -- file*。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令*git reset HEAD file*，就回到了场景1，第二步按场景1操作。\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](file/时光机穿梭.md#anchor_1)一节，不过前提是没有推送到远程库。\n\n##删除文件\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n\n    $ git add test.txt\n    $ git commit -m \"add test.txt\"\n    [master 94cdc44] add test.txt\n     1 file changed, 1 insertion(+)\n     create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n\n    $ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，*git status*命令会立刻告诉你哪些文件被删除了：\n\n    $ git status\n    # On branch master\n    # Changes not staged for commit:\n    #   (use \"git add/rm <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       deleted:    test.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令*git rm*删掉，并且commit：\n\n    $ git rm test.txt\n    rm 'test.txt'\n    $ git commit -m \"remove test.txt\"\n    [master d17efd8] remove test.txt\n     1 file changed, 1 deletion(-)\n     delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.webm\" /></video>\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n    $ git checkout -- test.txt\n\n*git checkout*其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**小结**\n\n命令*git rm*用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n\n#远程仓库\n\n到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。\n\n可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。\n\n没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。\n\nGit是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。\n\n你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？\n\n其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。\n\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\n\n完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫[GitHub](https://github.com/)的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n\n在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id\\_rsa和id\\_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n    $ ssh-keygen -t rsa -C \"your\\_email@example.com\"\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.webm\" /></video>\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id\\_rsa和id\\_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id\\_rsa是私钥，不能泄露出去，id\\_rsa.pub是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id\\_rsa.pub文件的内容：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130738501)\n\n点“Add Key”，你就应该看到已经添加的Key：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130748040)\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n\n**小结**\n\n“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机\n\n##添加远程库\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130803583)\n\n在Repository name填入*learngit*，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130812619)\n\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\n\n    $ git remote add origin git@github.com:michaelliao/learngit.git\n\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n\n添加后，远程库的名字就是*origin*，这是Git默认的叫法，也可以改成别的，但是*origin*这个名字一看就知道是远程库。\n\n下一步，就可以把本地库的所有内容推送到远程库上：\n\n    $ git push -u origin master\n    Counting objects: 19, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (19/19), done.\n    Writing objects: 100% (19/19), 13.73 KiB, done.\n    Total 23 (delta 6), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new branch]      master -> master\n    Branch master set up to track remote branch master from origin.\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.webm\" /></video>\n\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130830387)\n\n从现在起，只要本地作了提交，就可以通过命令：\n\n    $ git push origin master\n\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n**小结**\n\n要关联一个远程库，使用命令*git remote add origin git@server-name:path/repo-name.git*；\n\n关联后，使用命令*git push -u origin master*第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令*git push origin master*推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##从远程库克隆\n\n上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130842191)\n\n我们勾选*Initialize this repository with a README*，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130850414)\n\n现在，远程库已经准备好了，下一步是用命令*git clone*克隆一个本地库：\n\n    $ git clone git@github.com:michaelliao/gitskills.git\n    Cloning into 'gitskills'...\n    remote: Counting objects: 3, done.\n    remote: Total 3 (delta 0), reused 0 (delta 0)\n    Receiving objects: 100% (3/3), done.\n\n    $ cd gitskills\n    $ ls\n    README.md\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.webm\" /></video>\n\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用*https://github.com/michaelliao/gitskills.git*这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n**小结**\n\n要克隆一个仓库，首先必须知道仓库的地址，然后使用*git clone*命令克隆。\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n\n#分支管理\n\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\n\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。问题是，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130904432)\n\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。\n\n但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\n\n##创建与合并分支\n\n在[版本回退](file/时光机穿梭.md#anchor_1)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130949931)\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-branch-forward.webm\" /></video>\n\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212130958401)\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131005897)\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131013034)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131034735)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n<video width=\"400\" height=\"300\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/master-and-dev-ff.webm\" /></video>\n\n下面开始实战。\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n*git checkout*命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n    $ git branch dev\n    $ git checkout dev\n    Switched to branch 'dev'\n\n然后，用*git branch*命令查看当前分支：\n\n    $ git branch\n    * dev\n      master\n\n*git branch*命令会列出所有分支，当前分支前面会标一个\\*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\n\n    Creating a new branch is quick.\n\n然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"branch test\"\n    [dev fec145a] branch test\n     1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131104567)\n\n现在，我们把dev分支的工作成果合并到master分支上：\n\n    $ git merge dev\n    Updating d17efd8..fec145a\n    Fast-forward\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n*git merge*命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能*Fast-forward*，我们后面会将其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n\n    $ git branch -d dev\n    Deleted branch dev (was fec145a).\n\n删除后，查看branch，就只剩下master分支了：\n\n    $ git branch\n    * master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/create-dev-merge-delete.webm\" /></video>\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：git branch\n\n创建分支：git branch *name*\n\n切换分支：git checkout *name*\n\n创建+切换分支：git checkout -b *name*\n\n合并某分支到当前分支：git merge *name*\n\n删除分支：git branch -d *name*\n\n##解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的feature1分支，继续我们的新分支开发：\n\n    $ git checkout -b feature1\n    Switched to a new branch 'feature1'\n\n修改readme.txt最后一行，改为：\n\n    Creating a new branch is quick AND simple.\n\n在feature1分支上提交：\n\n    $ git add readme.txt \n    $ git commit -m \"AND simple\"\n    [feature1 75a857c] AND simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n切换到master分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 1 commit.\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n\n在master分支上把readme.txt文件的最后一行改为：\n\n    Creating a new branch is quick & simple.\n\n提交：\n\n    $ git add readme.txt \n    $ git commit -m \"& simple\"\n    [master 400b400] & simple\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131125396)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n    $ git merge feature1\n    Auto-merging readme.txt\n    CONFLICT (content): Merge conflict in readme.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。*git status*也可以告诉我们冲突的文件：\n\n    $ git status\n    # On branch master\n    # Your branch is ahead of 'origin/master' by 2 commits.\n    #\n    # Unmerged paths:\n    #   (use \"git add/rm <file>...\" as appropriate to mark resolution)\n    #\n    #       both modified:      readme.txt\n    #\n    no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n我们可以直接查看readme.txt的内容：\n\n    Git is a distributed version control system.\n    Git is free software distributed under the GPL.\n    Git has a mutable index called stage.\n    Git tracks changes of files.\n    <<<<<<< HEAD\n    Creating a new branch is quick & simple.\n    =======\n    Creating a new branch is quick AND simple.\n    >>>>>>> feature1\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：\n\n    Creating a new branch is quick and simple.\n\n再提交：\n\n    $ git add readme.txt \n    $ git commit -m \"conflict fixed\"\n    [master 59bc1cb] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131136505)\n\n用带参数的*git log*也可以看到分支的合并情况：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   59bc1cb conflict fixed\n    |\\\n    | * 75a857c AND simple\n    * | 400b400 & simple\n    |/\n    * fec145a branch test\n    ...\n\n现在，删除feature1分支：\n\n    $ git branch -d feature1\n    Deleted branch feature1 (was 75a857c).\n\n工作完成。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/resolv-conflix-on-merge.webm\" /></video>\n\n**小结**\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n用*git log --graph*命令可以看到分支合并图。\n\n##分支管理策略\n\n通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下*--no-ff*方式的merge：\n\n首先，仍然创建并切换dev分支：\n\n    $ git checkout -b dev\n    Switched to a new branch 'dev'\n\n修改readme.txt文件，并提交一个新的commit：\n\n    $ git add readme.txt \n    $ git commit -m \"add merge\"\n    [dev 6224937] add merge\n     1 file changed, 1 insertion(+)\n\n现在，我们切换会master：\n\n    $ git checkout master\n    Switched to branch 'master'\n\n准备合并dev分支，请注意*--no-ff*参数，表示禁用“Fast forward”：\n\n    $ git merge --no-ff -m \"merge with no-ff\" dev\n    Merge made by the 'recursive' strategy.\n     readme.txt |    1 +\n     1 file changed, 1 insertion(+)\n\n因为本次合并要创建一个新的commit，所以加上*-m*参数，把commit描述写进去。\n\n合并后，我们用*git log*看看分支历史：\n\n    $ git log --graph --pretty=oneline --abbrev-commit\n    *   7825a50 merge with no-ff\n    |\\\n    | * 6224937 add merge\n    |/\n    *   59bc1cb conflict fixed\n    ...\n\n可以看到，不使用“Fast forward”模式，merge后就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131151608)\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/merge-with-no-ff.webm\" /></video>\n\n### 分支策略\n\n在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131159864)\n\n**小结**\n\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上*--no-ff*参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而*fast forward*合并就看不出来曾经做过合并。\n\n##Bug分支\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n    $ git status\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n    $ git stash\n    Saved working directory and index state WIP on dev: 6224937 add merge\n    HEAD is now at 6224937 add merge\n\n现在，用*git status*查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 6 commits.\n    $ git checkout -b issue-101\n    Switched to a new branch 'issue-101'\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n    $ git add readme.txt \n    $ git commit -m \"fix bug 101\"\n    [issue-101 cc17032] fix bug 101\n     1 file changed, 1 insertion(+), 1 deletion(-)\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n    $ git checkout master\n    Switched to branch 'master'\n    Your branch is ahead of 'origin/master' by 2 commits.\n    $ git merge --no-ff -m \"merged bug fix 101\" issue-101\n    Merge made by the 'recursive' strategy.\n     readme.txt |    2 +-\n     1 file changed, 1 insertion(+), 1 deletion(-)\n    $ git branch -d issue-101\n    Deleted branch issue-101 (was cc17032).\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n    $ git checkout dev\n    Switched to branch 'dev'\n    $ git status\n    # On branch dev\n    nothing to commit (working directory clean)\n\n工作区是干净的，刚才的工作现场存到哪去了？用*git stash list*命令看看：\n\n    $ git stash list\n    stash@{0}: WIP on dev: 6224937 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用*git stash apply*恢复，但是恢复后，stash内容并不删除，你需要用*git stash drop*来删除；\n\n另一种方式是用*git stash pop*，恢复的同时把stash内容也删了：\n\n    $ git stash pop\n    # On branch dev\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   hello.py\n    #\n    # Changes not staged for commit:\n    #   (use \"git add <file>...\" to update what will be committed)\n    #   (use \"git checkout -- <file>...\" to discard changes in working directory)\n    #\n    #       modified:   readme.txt\n    #\n    Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)\n\n再用*git stash list*查看，就看不到任何stash内容了：\n\n    $ git stash list\n\n你可以多次stash，恢复的时候，先用*git stash list*查看，然后恢复指定的stash，用命令：\n\n    $ git stash apply stash@{0}\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/stash-fix-bug.webm\" /></video>\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场*git stash*一下，然后去修复bug，修复后，再*git stash pop*，回到工作现场。\n\n##Feature分支\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n    $ git checkout -b feature-vulcan\n    Switched to a new branch 'feature-vulcan'\n\n5分钟后，开发完毕：\n\n    $ git status\n    # On branch feature-vulcan\n    # Changes to be committed:\n    #   (use \"git reset HEAD <file>...\" to unstage)\n    #\n    #       new file:   vulcan.py\n    #\n    $ git commit -m \"add feature vulcan\"\n    [feature-vulcan 756d4af] add feature vulcan\n     1 file changed, 2 insertions(+)\n     create mode 100644 vulcan.py\n\n切回dev，准备合并：\n\n    $ git checkout dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是，\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个分支还是必须就地销毁：\n\n    $ git branch -d feature-vulcan\n    error: The branch 'feature-vulcan' is not fully merged.\n    If you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令*git branch -D feature-vulcan*。\n\n现在我们强行删除：\n\n    $ git branch -D feature-vulcan\n    Deleted branch feature-vulcan (was 756d4af).\n\n终于删除成功！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/force-delete-br.webm\" /></video>\n\n**小结**\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过*git branch -D name*强行删除。\n\n##多人协作\n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用*git remote*：\n\n    $ git remote\n    origin\n\n或者，用*git remote -v*显示更详细的信息：\n\n    $ git remote -v\n    origin  git@github.com:michaelliao/learngit.git (fetch)\n    origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n    $ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n\n    $ git push origin dev\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n* master分支是主分支，因此要时刻与远程同步；\n\n* dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n* bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n* feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-origin.webm\" /></video>\n\n### 抓取分支\n\n多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n    $ git clone git@github.com:michaelliao/learngit.git\n    Cloning into 'learngit'...\n    remote: Counting objects: 46, done.\n    remote: Compressing objects: 100% (26/26), done.\n    remote: Total 46 (delta 16), reused 45 (delta 15)\n    Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.\n    Resolving deltas: 100% (16/16), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用*git branch*命令看看：\n\n    $ git branch\n    * master\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n    $ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n    $ git commit -m \"add /usr/bin/env\"\n    [dev 291bea8] add /usr/bin/env\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    Counting objects: 5, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (2/2), done.\n    Writing objects: 100% (3/3), 349 bytes, done.\n    Total 3 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       fc38031..291bea8  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-push-by-xiaohuoban.webm\" /></video>\n\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n    $ git add hello.py \n    $ git commit -m \"add coding: utf-8\"\n    [dev bd6ae48] add coding: utf-8\n     1 file changed, 1 insertion(+)\n    $ git push origin dev\n    To git@github.com:michaelliao/learngit.git\n     ! [rejected]        dev -> dev (non-fast-forward)\n    error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\n    hint: Updates were rejected because the tip of your current branch is behind\n    hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')\n    hint: before pushing again.\n    hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用*git pull*把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n    $ git pull\n    remote: Counting objects: 5, done.\n    remote: Compressing objects: 100% (2/2), done.\n    remote: Total 3 (delta 0), reused 3 (delta 0)\n    Unpacking objects: 100% (3/3), done.\n    From github.com:michaelliao/learngit\n       fc38031..291bea8  dev        -> origin/dev\n    There is no tracking information for the current branch.\n    Please specify which branch you want to merge with.\n    See git-pull(1) for details\n    \n        git pull <remote> <branch>\n    \n    If you wish to set tracking information for this branch you can do so with:\n    \n        git branch --set-upstream dev origin/<branch>\n\n*git pull*也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n    $ git branch --set-upstream dev origin/dev\n    Branch dev set up to track remote branch dev from origin.\n\n再pull：\n\n    $ git pull\n    Auto-merging hello.py\n    CONFLICT (content): Merge conflict in hello.py\n    Automatic merge failed; fix conflicts and then commit the result.\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000)完全一样。解决后，提交，再push：\n\n    $ git commit -m \"merge & fix hello.py\"\n    [dev adca45d] merge & fix hello.py\n    $ git push origin dev\n    Counting objects: 10, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (5/5), done.\n    Writing objects: 100% (6/6), 747 bytes, done.\n    Total 6 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n       291bea8..adca45d  dev -> dev\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-pull-push-fix.webm\" /></video>\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用*git push origin branch-name*推送自己的修改；\n\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用*git pull*试图合并；\n\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n\n4. 没有冲突或者解决掉冲突后，再用*git push origin branch-name*推送就能成功！\n\n如果*git pull*提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令*git branch --set-upstream branch-name origin/branch-name*。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n* 查看远程库信息，使用*git remote -v*；\n\n* 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n* 从本地推送分支，使用*git push origin branch-name*，如果推送失败，先用*git pull*抓取远程的新提交；\n\n* 在本地创建和远程分支对应的分支，使用*git checkout -b branch-name origin/branch-name*，本地和远程分支的名称最好一致；\n\n* 建立本地分支和远程分支的关联，使用*git branch --set-upstream branch-name origin/branch-name*；\n\n* 从远程抓取分支，使用*git pull*，如果有冲突，要先处理冲突。\n\n\n#标签管理\n\n发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\n\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\n\n##创建标签\n\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n\n    $ git branch\n    * dev\n      master\n    $ git checkout master\n    Switched to branch 'master'\n\n然后，敲命令*git tag name*就可以打一个新标签：\n\n    $ git tag v1.0\n\n可以用命令*git tag*查看所有标签：\n\n    $ git tag\n    v1.0\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n\n方法是找到历史提交的commit id，然后打上就可以了：\n\n    $ git log --pretty=oneline --abbrev-commit\n    6a5819e merged bug fix 101\n    cc17032 fix bug 101\n    7825a50 merge with no-ff\n    6224937 add merge\n    59bc1cb conflict fixed\n    400b400 & simple\n    75a857c AND simple\n    fec145a branch test\n    d17efd8 remove test.txt\n    ...\n\n比方说要对“add merge”这次提交打标签，它对应的commit id是“6224937”，敲入命令：\n\n    $ git tag v0.9 6224937\n\n再用命令*git tag*查看标签：\n\n    $ git tag\n    v0.9\n    v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用*git show tagname*查看标签信息：\n\n    $ git show v0.9\n    commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 11:22:08 2013 +0800\n    \n        add merge\n    ...\n\n可以看到，“v0.9”确实打在“add merge”这次提交上。\n\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n\n    $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n\n用命令*git show tagname*可以看到说明文字：\n\n    $ git show v0.1\n    tag v0.1\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:11 2013 +0800\n    \n    version 0.1 released\n    \n    commit 3628164fb26d48395383f8f31179f24e0882e1e0\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Tue Aug 20 15:11:49 2013 +0800\n    \n        append GPL\n    ...\n\n还可以通过-s用私钥签名一个标签：\n\n    $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：\n\n    gpg: signing failed: secret key not available\n    error: gpg failed to sign the data\n    error: unable to sign the tag\n\n如果报错，请参考GnuPG帮助文档配置Key。\n\n用命令*git show tagname*可以看到PGP签名信息：\n\n    $ git show v0.2\n    tag v0.2\n    Tagger: Michael Liao <askxuefeng@gmail.com>\n    Date:   Mon Aug 26 07:28:33 2013 +0800\n    \n    signed version 0.2 released\n    -----BEGIN PGP SIGNATURE-----\n    Version: GnuPG v1.4.12 (Darwin)\n    \n    iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...\n    -----END PGP SIGNATURE-----\n    \n    commit fec145accd63cdc9ed95a2f557ea0658a2a6537f\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 10:37:30 2013 +0800\n    \n        branch test\n    ...\n\n用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tags.webm\" /></video>\n\n**小结**\n\n* 命令*git tag name*用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n* -a tagname -m \"blablabla...\"可以指定标签信息；\n\n* -s tagname -m \"blablabla...\"可以用PGP签名标签；\n\n* 命令*git tag*可以查看所有标签；\n\n##操作标签\n\n如果标签打错了，也可以删除：\n\n    $ git tag -d v0.1\n    Deleted tag 'v0.1' (was e078af9)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n\n如果要推送某个标签到远程，使用命令git push origin tagname：\n\n    $ git push origin v1.0\n    Total 0 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v1.0 -> v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n    $ git push origin --tags\n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 554 bytes, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To git@github.com:michaelliao/learngit.git\n     * [new tag]         v0.2 -> v0.2\n     * [new tag]         v0.9 -> v0.9\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n    $ git tag -d v0.9\n    Deleted tag 'v0.9' (was 6224937)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n    $ git push origin :refs/tags/v0.9\n    To git@github.com:michaelliao/learngit.git\n     - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n<video width=\"648\" height=\"434\" controls=\"controls\" preload=\"none\" style=\"border:solid 1px #ccc\"><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.mp4\" /><source src=\"http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-tag-d.webm\" /></video>\n\n**小结**\n\n* 命令*git push origin tagname*可以推送一个本地标签；\n\n* 命令*git push origin --tags*可以推送全部未推送过的本地标签；\n\n* 命令*git tag -d tagname*可以删除一个本地标签；\n\n* 命令*git push origin :refs/tags/tagname*可以删除一个远程标签。\n\n\n#自定义Git\n\n在[安装Git](file/git安装.md#anchor_0)一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。\n\n比如，让Git显示颜色，会让命令输出看起来更醒目：\n\n    $ git config --global color.ui true\n\n这样，Git会适当地显示不同的颜色，比如*git status*命令：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131228046)\n\n文件名就会标上颜色。\n\n我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。\n\n##忽略特殊文件\n\n有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次*git status*都会显示“Untracked files ...”，有强迫症的童鞋心里肯定不爽。\n\n好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的*.gitignore*文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n\n不需要从头写*.gitignore*文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：[https://github.com/github/gitignore](https://github.com/github/gitignore)\n\n忽略文件的原则是：\n\n1. 忽略操作系统自动生成的文件，比如缩略图等；\n2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的*.class*文件；\n3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n举个例子：\n\n假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有*Desktop.ini*文件，因此你需要忽略Windows自动生成的垃圾文件：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n\n然后，继续忽略Python编译产生的*.pyc*、*.pyo*、*dist*等文件或目录：\n\n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n\n加上你自己定义的文件，最终得到一个完整的*.gitignore*文件，内容如下：\n\n    # Windows:\n    Thumbs.db\n    ehthumbs.db\n    Desktop.ini\n    \n    # Python:\n    *.py[cod]\n    *.so\n    *.egg\n    *.egg-info\n    dist\n    build\n    \n    # My configurations:\n    db.ini\n    deploy_key_rsa\n\n最后一步就是把*.gitignore*也提交到Git，就完成了！当然检验*.gitignore*的标准是*git status*命令是不是说“working directory clean”。\n\n**小结**\n\n1. 忽略某些文件时，需要编写*.gitignore*。\n2. *.gitignore*文件本身要放到版本库里，并且可以对*.gitignore*做版本管理！\n\n##配置别名\n\n有没有经常敲错命令？比如*git status*？*status*这个单词真心不好记。\n\n如果敲*git st*就表示*git status*那就简单多了，当然这种偷懒的办法我们是极力赞成的。\n\n我们只需要敲一行命令，告诉Git，以后*st*就表示*status*：\n\n    $ git config --global alias.st status\n\n好了，现在敲*git st*看看效果。\n\n当然还有别的命令可以简写，很多人都用*co*表示*checkout*，*ci*表示*commit*，*br*表示*branch*：\n\n    $ git config --global alias.co checkout\n    $ git config --global alias.ci commit\n    $ git config --global alias.br branch\n\n以后提交就可以简写成：\n\n    $ git ci -m \"bala bala bala...\"\n\n*--global*参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。\n\n在[撤销修改](file/时光机穿梭.md#anchor_4)一节中，我们知道，命令*git reset HEAD file*可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：\n\n    $ git config --global alias.unstage 'reset HEAD'\n\n当你敲入命令：\n\n    $ git unstage test.py\n\n实际上Git执行的是：\n\n    $ git reset HEAD test.py\n\n配置一个*git last*，让其显示最后一次提交信息：\n\n    $ git config --global alias.last 'log -1'\n\n这样，用*git last*就能显示最近一次的提交：\n\n    $ git last\n    commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2\n    Merge: bd6ae48 291bea8\n    Author: Michael Liao <askxuefeng@gmail.com>\n    Date:   Thu Aug 22 22:49:22 2013 +0800\n    \n        merge & fix hello.py\n\n甚至还有人丧心病狂地把*lg*配置成了：\n\n    git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n\n来看看*git lg*的效果：\n\n![这里写图片描述](http://img.blog.csdn.net/20151212131238572)\n\n为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！\n\n**小结**\n\n给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。\n\n##搭建Git服务器\n\n在[远程仓库](file/远程仓库.md#anchor_0)一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。\n\nGitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。\n\n搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n\n假设你已经有sudo权限的用户账号，下面，正式开始安装。\n\n第一步，安装git：\n\n    $ sudo apt-get install git\n\n第二步，创建一个git用户，用来运行git服务：\n\n    $ sudo adduser git\n\n第三步，创建证书登录：\n\n收集所有需要登录的用户的公钥，就是他们自己的id\\_rsa.pub文件，把所有公钥导入到*/home/git/.ssh/authorized\\_keys*文件里，一行一个。\n\n第四步，初始化Git仓库：\n\n先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：\n\n    $ sudo git init --bare sample.git\n\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n\n    $ sudo chown -R git:git sample.git\n\n第五步，禁用shell登录：\n\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n\n    git:x:1001:1001:,,,:/home/git:/bin/bash\n\n改为：\n\n    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n\n第六步，克隆远程仓库：\n\n现在，可以通过*git clone*命令克隆远程仓库了，在各自的电脑上运行：\n\n    $ git clone git@server:/srv/sample.git\n    Cloning into 'sample'...\n    warning: You appear to have cloned an empty repository.\n\n剩下的推送就简单了。\n\n### 管理公钥\n\n如果团队很小，把每个人的公钥收集起来放到服务器的*/home/git/.ssh/authorized\\_keys*文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用[Gitosis](https://github.com/res0nat0r/gitosis)来管理公钥。\n\n这里我们不介绍怎么玩[Gitosis](https://github.com/res0nat0r/gitosis)了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。\n\n### 管理权限\n\n有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。[Gitolite](https://github.com/sitaramc/gitolite)就是这个工具。\n\n这里我们也不介绍[Gitolite](https://github.com/sitaramc/gitolite)了，不要把有限的生命浪费到权限斗争中。\n\n**小结**\n\n搭建Git服务器非常简单，通常10分钟即可完成；\n\n要方便管理公钥，用[Gitosis](https://github.com/sitaramc/gitolite)；\n\n要像SVN那样变态地控制权限，用[Gitolite](https://github.com/sitaramc/gitolite)。\n\n\n#期末总结\n\n终于到了期末总结的时刻了！\n\n经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。\n\nGit虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。\n\n友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：\n\n[Git Cheat Sheet](http://www.git-tower.com/blog/assets/2013-05-22-git-cheat-sheet/cheat-sheet-large01.png)\n\n现在告诉你Git的官方网站：[http://git-scm.com](http://git-scm.com)，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。\n\n如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。为了激励我写出更优秀的教程，你可以考虑赠送我一杯咖啡，至于是喝麦当劳还是星巴克就看你的心情了。有支付宝的童鞋请狠狠地点这里：\n\n<a href=\"https://me.alipay.com/askxuefeng\" target=\"_blank\" class=\"btn btn-success btn-large\" style=\"padding-left:60px;background-repeat:no-repeat;background-position:15px center;background-image:url(http://static.itranswarp.com/0013738742366844b31d0ceab84491682c4556f8daa5101000/attachment/2013/8/12/9d9043ba785d43ab8f4cffb04a4b1300.png)\">请我喝咖啡</a>\n\n谢谢观看！","slug":"Git教程","published":1,"updated":"2015-12-23T10:59:13.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvex003sigtgvk0mctjv","sticky":0},{"title":"Github资源整理","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2015/02/24/Github%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/Github资源整理.md","raw":"---\ntitle: Github资源整理\ntags:\n  - 工具\ncategories:\n  - 互联网\n  - 转载\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://andrewliu.in/2015/02/24/Github%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/\"><title></title></head><body></body></html>\n转载文章","slug":"Github资源整理","published":1,"date":"2015-12-21T11:02:40.700Z","updated":"2015-12-21T11:02:40.700Z","layout":"post","photos":[],"link":"","_id":"cijvfnvf6003zigtgwgrattip","sticky":0},{"title":"Git-简明指南","date":"2015-12-20T09:17:11.000Z","comments":0,"_content":"<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://arccode.net/2015/02/28/Git-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/\"><title></title></head><body></body></html>\n转载文章","source":"_posts/Git-简明指南.md","raw":"title: Git-简明指南\ntags:\n  - 教程\n  - 版本控制\ncategories:\n  - 互联网\n  - 转载\ndate: 2015-12-20 17:17:11\ncomments: false\n---\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://arccode.net/2015/02/28/Git-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/\"><title></title></head><body></body></html>\n转载文章","slug":"Git-简明指南","published":1,"updated":"2015-12-21T11:02:39.389Z","layout":"post","photos":[],"link":"","_id":"cijvfnvfb0043igtgvbb48thc","sticky":0},{"title":"Find the Path","date":"2015-08-17T01:41:00.000Z","_content":"Description\n--\nScofield刚从监狱里面跑出来，现在他要在进行大逃亡.\n\n你也知道, 逃亡是非常不容易的, 现在Scofield遇到了一些困难, 你可以帮助他吗?\n\nScofield面前的是一个美国的交通图, 图里面有一些城市, 有些城市之间有路连接. 路的长度scofield是知道的, 但是有些城市里面的警察很多, 所以scofield对这个问题很头疼. 他现在要安排一些逃亡路线, 所以他要对你做一些询问, 询问是这样的:某两个城市之间的最短路是什么? 但是这个最短路有个前提, 那就是路径上的每个城市里的警察不得超过k个. 起点和终点除外.\n\nInput\n--\n有多组测试数据, 数据第一行是一个整数T表示测试数据的个数。每组测试数据以二个整数N，M 开始。N是城市个数，M是道路数。\n下面一行有n个数, 表示每个城市里面的警察的个数Ci.\n再下面m行, 每行有三个数, u, v, w.\n再下面有一个整数Q\n下面有Q行, 每行三个整数u, v, k表示,查询的内容为从u到v的警察数不超过k的最短路.(u, v上的警察不用计算在内).\n\nTechnical Specification\n1. T <= 20\n2. 2 <= N <= 200, 0 <= M <= n * (n – 1) / 2\n3. 0 <= Ci <= 1000,000,000\n4. 0 <= u, v < N, 0 <= w <= 1000, 0 <= k <= 1000,000,000\n5. 0<= Q <= 100000\n6. 没有多重边和自环边\n7. 对于每一个询问，u！= v。\n8. 输入数据后面有一个空行。\n\nOutput\n--\n对于每一个询问，输出一行，表示最短路是什么，如果不存在的话就输出-1.\n每一个测试数据后面加一个空行。\n\nSample Input\n--\n```\n1\n4 4\n100 2 3 100\n0 1 1\n0 2 1\n1 3 2\n2 3 3\n2\n0 3 2\n0 3 1\n```\nSample Output \n--\n```\n3\n-1\n```\nAnalysis\n--\n这题是要我们求最短路，但是最短路有一定的要求，就是最短路上的警察要不超过k个。再看看数据范围，N非常的小，组数也不多。再求最短路的诸多算法中，floyd算法虽然慢，但是他在处理一些特殊问题(带条件)时却能发挥它的重要作用。\n我们都知道floyd算法，是通过枚举中间点，进而求出最短路。在枚举中间点的时候，未枚举到的中间点，并不在所求的最短路内。所以根据这个特性，我们就可以再求最短路的同时，进而保证警察数k在一个范围内，然后在回答每一个问题。\n实现起来可能略微复杂，首先我们将原先图上的点进行重编号。按照点的警察数从小到大排序，顺次编号。现在对于图上编号为i的点，在[1..i-1]中的点他们的警察数k都比i点的警察数k小。在对新图做一次floyd最短路。对于后面的每个询问，将询问的<u,v>转化为新图的<u,v>。再从满足警察数<=k个中选出一个最小的答案，作为此次询问的答案。整道题的算法复杂度为O((N^3+QN)*T)。其实复杂度还是蛮高的。\n\nCode\n--\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long LL;\nconst long long INF = 1042521604759584125;\nconst int N = 200+10;\nLL map[N][N][N];\nint pos[N];\n\nstruct node\n{\n\tint num,id;\n\tbool operator < (node a) const\n\t{\n\t\treturn num < a.num;\n\t}\n}cos[N];\n\nint main()\n{\n\t//freopen(\"1061.in\",\"r\",stdin);\n\t\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T --)\n\t{\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i = 0 ; i < n ; i ++)\n\t\t{\n\t\t\tscanf(\"%d\",&cos[i].num);\n\t\t\tcos[i].id = i;\n\t\t}\n\t\tsort(cos,cos + n);\n\t\tfor (int i = 0 ; i < n ; i ++)\\\n\t\t{\n\t\t\tpos[cos[i].id] = i+1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tmap[i][j][0]=INF;\n\t\tfor (int i = 1 ; i <= m ; i ++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tmap[pos[x]][pos[y]][0] = z;\n\t\t\tmap[pos[y]][pos[x]][0] = z;\n\t\t}\n\t\tfor (int k = 1;k <= n; k ++)\n\t\t{\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = map[i][j][k - 1];\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = min(map[i][j][k],map[i][k][k-1]+map[k][j][k-1]);\n\t\t\t\n\t\t}\n\t\tint Q;\n\t\tscanf(\"%d\",&Q);\n\t\twhile (Q --)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tLL ans = map[pos[x]][pos[y]][0];\n\t\t\tfor (int i = n-1 ; i >= 0; i --)\n\t\t\t{\n\t\t\t\tif (cos[i].num <= z) {\n\t\t\t\t\tans = map[pos[x]][pos[y]][i+1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == INF) puts(\"-1\"); else printf(\"%lld\\n\",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\t\t\n\treturn 0;\n}\n```","source":"_posts/Find-the-Path.md","raw":"---\ntitle: Find the Path\ndate: 2015-08-17 09:41:00\ntags:\n  - 题解\n  - floyd算法\ncategories:\n  - 信息学\n  - 原创\n---\nDescription\n--\nScofield刚从监狱里面跑出来，现在他要在进行大逃亡.\n\n你也知道, 逃亡是非常不容易的, 现在Scofield遇到了一些困难, 你可以帮助他吗?\n\nScofield面前的是一个美国的交通图, 图里面有一些城市, 有些城市之间有路连接. 路的长度scofield是知道的, 但是有些城市里面的警察很多, 所以scofield对这个问题很头疼. 他现在要安排一些逃亡路线, 所以他要对你做一些询问, 询问是这样的:某两个城市之间的最短路是什么? 但是这个最短路有个前提, 那就是路径上的每个城市里的警察不得超过k个. 起点和终点除外.\n\nInput\n--\n有多组测试数据, 数据第一行是一个整数T表示测试数据的个数。每组测试数据以二个整数N，M 开始。N是城市个数，M是道路数。\n下面一行有n个数, 表示每个城市里面的警察的个数Ci.\n再下面m行, 每行有三个数, u, v, w.\n再下面有一个整数Q\n下面有Q行, 每行三个整数u, v, k表示,查询的内容为从u到v的警察数不超过k的最短路.(u, v上的警察不用计算在内).\n\nTechnical Specification\n1. T <= 20\n2. 2 <= N <= 200, 0 <= M <= n * (n – 1) / 2\n3. 0 <= Ci <= 1000,000,000\n4. 0 <= u, v < N, 0 <= w <= 1000, 0 <= k <= 1000,000,000\n5. 0<= Q <= 100000\n6. 没有多重边和自环边\n7. 对于每一个询问，u！= v。\n8. 输入数据后面有一个空行。\n\nOutput\n--\n对于每一个询问，输出一行，表示最短路是什么，如果不存在的话就输出-1.\n每一个测试数据后面加一个空行。\n\nSample Input\n--\n```\n1\n4 4\n100 2 3 100\n0 1 1\n0 2 1\n1 3 2\n2 3 3\n2\n0 3 2\n0 3 1\n```\nSample Output \n--\n```\n3\n-1\n```\nAnalysis\n--\n这题是要我们求最短路，但是最短路有一定的要求，就是最短路上的警察要不超过k个。再看看数据范围，N非常的小，组数也不多。再求最短路的诸多算法中，floyd算法虽然慢，但是他在处理一些特殊问题(带条件)时却能发挥它的重要作用。\n我们都知道floyd算法，是通过枚举中间点，进而求出最短路。在枚举中间点的时候，未枚举到的中间点，并不在所求的最短路内。所以根据这个特性，我们就可以再求最短路的同时，进而保证警察数k在一个范围内，然后在回答每一个问题。\n实现起来可能略微复杂，首先我们将原先图上的点进行重编号。按照点的警察数从小到大排序，顺次编号。现在对于图上编号为i的点，在[1..i-1]中的点他们的警察数k都比i点的警察数k小。在对新图做一次floyd最短路。对于后面的每个询问，将询问的<u,v>转化为新图的<u,v>。再从满足警察数<=k个中选出一个最小的答案，作为此次询问的答案。整道题的算法复杂度为O((N^3+QN)*T)。其实复杂度还是蛮高的。\n\nCode\n--\n```\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long LL;\nconst long long INF = 1042521604759584125;\nconst int N = 200+10;\nLL map[N][N][N];\nint pos[N];\n\nstruct node\n{\n\tint num,id;\n\tbool operator < (node a) const\n\t{\n\t\treturn num < a.num;\n\t}\n}cos[N];\n\nint main()\n{\n\t//freopen(\"1061.in\",\"r\",stdin);\n\t\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T --)\n\t{\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i = 0 ; i < n ; i ++)\n\t\t{\n\t\t\tscanf(\"%d\",&cos[i].num);\n\t\t\tcos[i].id = i;\n\t\t}\n\t\tsort(cos,cos + n);\n\t\tfor (int i = 0 ; i < n ; i ++)\\\n\t\t{\n\t\t\tpos[cos[i].id] = i+1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tmap[i][j][0]=INF;\n\t\tfor (int i = 1 ; i <= m ; i ++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t\tmap[pos[x]][pos[y]][0] = z;\n\t\t\tmap[pos[y]][pos[x]][0] = z;\n\t\t}\n\t\tfor (int k = 1;k <= n; k ++)\n\t\t{\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = map[i][j][k - 1];\n\t\t\tfor (int i = 1 ; i <= n ; i ++)\n\t\t\tfor (int j = 1 ; j <= n ; j ++)\n\t\t\t\tmap[i][j][k] = min(map[i][j][k],map[i][k][k-1]+map[k][j][k-1]);\n\t\t\t\n\t\t}\n\t\tint Q;\n\t\tscanf(\"%d\",&Q);\n\t\twhile (Q --)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tLL ans = map[pos[x]][pos[y]][0];\n\t\t\tfor (int i = n-1 ; i >= 0; i --)\n\t\t\t{\n\t\t\t\tif (cos[i].num <= z) {\n\t\t\t\t\tans = map[pos[x]][pos[y]][i+1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == INF) puts(\"-1\"); else printf(\"%lld\\n\",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\t\t\n\treturn 0;\n}\n```","slug":"Find-the-Path","published":1,"updated":"2015-12-25T10:38:01.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvfg0048igtgyrf6nc84","sticky":0},{"title":"Debian 7 安装教程","date":"2015-10-28T00:03:00.000Z","_content":"First you should download the file of Debian 7 64 bit\n\n\nset source\n--\n```\n#vim /etc/apt/sources.list\n```\nEnter the following information\n```\ndeb http://mirrors.163.com/debian wheezy main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy main non-free contrib\n\n\ndeb http://mirrors.163.com/debian wheezy-updates main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy-updates main non-free contrib\n\n\ndeb http://security.debian.org/ wheezy/updates main\ndeb-src http://security.debian.org/ wheezy/updates main\n\n#apt-get update\n```\n\ninstall some software\n--\nOpen Terminal\ninput order\n```\n$su root\n#apt-get install vim\n#apt-get install gcc\n#apt-get install g++\n#apt-get install sudo\n#apt-get install fpc\n```\n\nTo solve the Chinese garbled\n--\n```\n$su\n#apt-get install ttf-arphic-uming\n#apt-get install ttf-wqy-zenhei\n#aptitude install locales\n#dpkg-reconfigure locales\n```\nchoose something\n```\nen_US.UTF8\nzh_CN GB2312\nzh_CN GBK GBK\nzh_CN UTF-8 UTF-8\n```\nchoose zh_CN UTF-8  \n```\n#vi /etc/default/locale\nLANG=en_US.UTF-8\n```\n\n安装中文输入法\n--\n```\n# apt-get install fcitx\n```\n创建脚本以便X Window启动时自动载入fcitx: \n```\n# cd /etc/X11/Xsession.d  \n# vi 25xchinput_start\n```\n输入以下内容并保存： \n```\nexport XMODIFIERS=@im=fcitx        \nexport XIM=fcitx        \nexport XIM_PROGRAM=fcitx        \n/usr/bin/fcitx &\n```\n在配置中激活输入法\nfcitx翻页按钮=向下-向上\n\n安装vmware tools\n```\ntar zxvf ***.tar.gz\n#sudo apt-get install make\n#sudo apt-get install gcc\n#sudo aptitude install linux-headers-`uname -r`\n```\n在root下运行vmware-install.pl\n\n\n查看windows共享文件\n--\n```\n#apt-get install samba\n```\n首先，下载samba；\n接着，Alt+F2,\nsmb://windows的IP/共享目录\n假设windows的ip是10.2.11.2.100, 共享目录是share和本地磁盘(E)\n于是\nsmb://10.2.112.100/share\nsmb://10.2.112.100/本地磁盘(E)\n即可直接访问。\n\n\n解压deb包\n--\ndpkg命令常用格式如下：\ndpkg -I iptux.deb#查看iptux.deb软件包的详细信息，\ndpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构\ndpkg -i iptux.deb#安装iptux.deb软件包\ndpkg -l iptux#查看iptux软件包的信息\ndpkg -L iptux#查看iptux软件包安装的所有文件\ndpkg -s iptux#查看iptux软件包的详细信息\ndpkg -r iptux#卸载iptux软件包\n注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。\ndpkg -l | grep qq\n用这个命令组合着出来了，列出已经安装的软件，并且包含qq关键字的。。\n再用-r卸载\n\n\ntar.gz文件解压\n--","source":"_posts/Debian-7-安装教程.md","raw":"---\ntitle: Debian 7 安装教程\ndate: 2015-10-28 08:03:00\ntags:\n  - 教程\ncategories:\n  - 互联网\n  - 原创\n---\nFirst you should download the file of Debian 7 64 bit\n\n\nset source\n--\n```\n#vim /etc/apt/sources.list\n```\nEnter the following information\n```\ndeb http://mirrors.163.com/debian wheezy main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy main non-free contrib\n\n\ndeb http://mirrors.163.com/debian wheezy-updates main non-free contrib\ndeb-src http://mirrors.163.com/debian wheezy-updates main non-free contrib\n\n\ndeb http://security.debian.org/ wheezy/updates main\ndeb-src http://security.debian.org/ wheezy/updates main\n\n#apt-get update\n```\n\ninstall some software\n--\nOpen Terminal\ninput order\n```\n$su root\n#apt-get install vim\n#apt-get install gcc\n#apt-get install g++\n#apt-get install sudo\n#apt-get install fpc\n```\n\nTo solve the Chinese garbled\n--\n```\n$su\n#apt-get install ttf-arphic-uming\n#apt-get install ttf-wqy-zenhei\n#aptitude install locales\n#dpkg-reconfigure locales\n```\nchoose something\n```\nen_US.UTF8\nzh_CN GB2312\nzh_CN GBK GBK\nzh_CN UTF-8 UTF-8\n```\nchoose zh_CN UTF-8  \n```\n#vi /etc/default/locale\nLANG=en_US.UTF-8\n```\n\n安装中文输入法\n--\n```\n# apt-get install fcitx\n```\n创建脚本以便X Window启动时自动载入fcitx: \n```\n# cd /etc/X11/Xsession.d  \n# vi 25xchinput_start\n```\n输入以下内容并保存： \n```\nexport XMODIFIERS=@im=fcitx        \nexport XIM=fcitx        \nexport XIM_PROGRAM=fcitx        \n/usr/bin/fcitx &\n```\n在配置中激活输入法\nfcitx翻页按钮=向下-向上\n\n安装vmware tools\n```\ntar zxvf ***.tar.gz\n#sudo apt-get install make\n#sudo apt-get install gcc\n#sudo aptitude install linux-headers-`uname -r`\n```\n在root下运行vmware-install.pl\n\n\n查看windows共享文件\n--\n```\n#apt-get install samba\n```\n首先，下载samba；\n接着，Alt+F2,\nsmb://windows的IP/共享目录\n假设windows的ip是10.2.11.2.100, 共享目录是share和本地磁盘(E)\n于是\nsmb://10.2.112.100/share\nsmb://10.2.112.100/本地磁盘(E)\n即可直接访问。\n\n\n解压deb包\n--\ndpkg命令常用格式如下：\ndpkg -I iptux.deb#查看iptux.deb软件包的详细信息，\ndpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构\ndpkg -i iptux.deb#安装iptux.deb软件包\ndpkg -l iptux#查看iptux软件包的信息\ndpkg -L iptux#查看iptux软件包安装的所有文件\ndpkg -s iptux#查看iptux软件包的详细信息\ndpkg -r iptux#卸载iptux软件包\n注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。\ndpkg -l | grep qq\n用这个命令组合着出来了，列出已经安装的软件，并且包含qq关键字的。。\n再用-r卸载\n\n\ntar.gz文件解压\n--","slug":"Debian-7-安装教程","published":1,"updated":"2015-12-26T04:00:23.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvfn004eigtgqi6nqbd9","sticky":0},{"title":"Crystal 李馨巧","_content":"李馨巧\n#序言#\n其实很早的时候，我就决定想在博客上写关于她的专题，但一直没时间写。现在寒假了也有这个机会和这个时间写。\n##为什么要写这个专题？\n首先是受到了知乎的影响，因为在知乎上，我看到了各行各业，各种各样的人在上面分享自己的见解和看法。所以就决定在博客上弄一个专题。\n写这个专题的主要目的也是为了记录，整理与她相关的信息。可以方便我以后的回忆和检索。\n她也是我第一个写的关于个人的专题。可能写的会有些不好，请见谅！我不想写成一个人物传记，更想用时间线的方式来叙述和评论我眼中的“Crystal 李馨巧”。\n##下面是关于她的百科信息。\n\n#时间线\n##2015年\n###《中国新生代》\n最早见到李馨巧是在《中国新生代》第一季的节目上，当时就留有了一定的印象。其实，我认为当时她在台上的形象并不太好，披头散发的，穿着一身红衣服，就显得特别的成熟，不像一个小孩应有的神态。\n####后台(上台前)\n之所以令我印象深刻，是因为在她出场前的介绍(在拍《激战》获奖以前)。当麦咭问到她说她有跟很多大明星合作过电影，她也就很从容淡定的如实回答，说跟周杰伦和谢霆锋合作过，还有一段关于影片《激战》的VCR。(需要核实)当时确实被影片中那可爱乖巧的表演打动到了。(也是在这个VCR中发现她会说粤语)接下来是麦咭问她带来陪同的人，她带了妈妈(她可是不折不扣的妈妈控啊！！)，和经纪人哥哥(What!!)，她是我目前为止唯一一个看到的，在新生代的舞台上，带经纪人陪同的小孩。当时的我是震惊的。所以在上台前就已经被她的经历所震撼到了。也怪不得海泉会评价其气场强大。\n####正式上台\n她带来的歌曲是《price tag》(只要有机会上台表演唱歌，这是她的首选歌曲)，这首歌也是我认为的，她所有翻唱歌曲中最好的一首。台上的表演那就是自然，活泼，气场强大。像一个专业演员在演出。声音也够甜美，完完全全未经修饰的童声！！\n####总结\n但是其实并没有太在意这个人，主要是她上台前的介绍以及当时的形象造成的。感觉特别有背景，对于非常有背景的人我一般都会否定掉的。再加之她是马来西亚人，不是中国人。而且在那之前，我已经粉上了同为这季新生代的另外一个小孩王睿卓，所以对她的关注就少了。\n###一段时间\n过了很长一段时间也没有怎么关注她，只是在新浪微博中顺带关注了她的微博帐号，我发现她的关注人数也并不怎么多嘛！而且微博信息也停留在了2014年，很久没有更新了！我想，也正常，毕竟是海外的人，人家的主战场应该在Facebook。(容许我再一次鄙视一下GFW)。\n在这期间，我将很多新生代学员的歌加进了酷狗音乐，唯独其中四人的歌最讨我喜欢，(其中就包括了李馨巧)。特别是当我听厌了其他三人的歌时。她的歌声真的令我百听不厌，我要的就是这种几乎不加修饰的童声，(天籁之音)而她的歌声做到了这一点。所以我决定上网爬取所有与她相关的信息，就在这个漫长的爬取过程中，我粉上了她。\n###百度百科&维基百科\n对于任何一个公众人物来说，想了解她的信息，最好不过的就是看百科中相应的词条。百科中的词条，往往都是各个网友从其他网页中，搜集并汇集的来源可靠的资料。(这里点名批评一下百度百科，参演的电影角色名称搞反了，关键是还不让我修改)\n我就先按照她获奖的电影或电视剧中依次找寻她的镜头。并且搜索与她相关的其他电影电视剧。\n####下面是我按照时间顺序观看她参演的电影电视剧\n《激战》\n《逆战》\n《足印》\n《天天好天》\n《逃出生天3D》\n《甲洞2》\n《哥妹俩之惊历48》\n《稽查专用》\n###激战\n这也是她在大陆出名的一部影片。因为上海国际电影节破天荒的将最佳女演员的奖项给了她。使她从此获得了史上最年轻影后的殊荣。最初我以为这个奖项只是针对这部影片而言，毕竟这部影片中的女演员也确实少，也不足为奇。后面才得知是在多部影片中评选出来的。\n在百度搜索中，可以发现大多数的搜索结果都是与这部影片相关的，国内的媒体采访(包括港澳台)都基本是围绕这部影片来采访的。所以说，她在中国大陆的出名完全就是因为这部影片和上海国际电影节的金爵奖。同时也要感谢这部电影的制作方和导演(林超贤)。\n影片内容\n\n#参考资料\n百度百科\n维基百科\n","source":"_posts/Crystal-李馨巧.md","raw":"---\ntitle: Crystal 李馨巧\ntags:\n  - 题解\ncategories:\n  - 信息学\n  - 原创\n---\n李馨巧\n#序言#\n其实很早的时候，我就决定想在博客上写关于她的专题，但一直没时间写。现在寒假了也有这个机会和这个时间写。\n##为什么要写这个专题？\n首先是受到了知乎的影响，因为在知乎上，我看到了各行各业，各种各样的人在上面分享自己的见解和看法。所以就决定在博客上弄一个专题。\n写这个专题的主要目的也是为了记录，整理与她相关的信息。可以方便我以后的回忆和检索。\n她也是我第一个写的关于个人的专题。可能写的会有些不好，请见谅！我不想写成一个人物传记，更想用时间线的方式来叙述和评论我眼中的“Crystal 李馨巧”。\n##下面是关于她的百科信息。\n\n#时间线\n##2015年\n###《中国新生代》\n最早见到李馨巧是在《中国新生代》第一季的节目上，当时就留有了一定的印象。其实，我认为当时她在台上的形象并不太好，披头散发的，穿着一身红衣服，就显得特别的成熟，不像一个小孩应有的神态。\n####后台(上台前)\n之所以令我印象深刻，是因为在她出场前的介绍(在拍《激战》获奖以前)。当麦咭问到她说她有跟很多大明星合作过电影，她也就很从容淡定的如实回答，说跟周杰伦和谢霆锋合作过，还有一段关于影片《激战》的VCR。(需要核实)当时确实被影片中那可爱乖巧的表演打动到了。(也是在这个VCR中发现她会说粤语)接下来是麦咭问她带来陪同的人，她带了妈妈(她可是不折不扣的妈妈控啊！！)，和经纪人哥哥(What!!)，她是我目前为止唯一一个看到的，在新生代的舞台上，带经纪人陪同的小孩。当时的我是震惊的。所以在上台前就已经被她的经历所震撼到了。也怪不得海泉会评价其气场强大。\n####正式上台\n她带来的歌曲是《price tag》(只要有机会上台表演唱歌，这是她的首选歌曲)，这首歌也是我认为的，她所有翻唱歌曲中最好的一首。台上的表演那就是自然，活泼，气场强大。像一个专业演员在演出。声音也够甜美，完完全全未经修饰的童声！！\n####总结\n但是其实并没有太在意这个人，主要是她上台前的介绍以及当时的形象造成的。感觉特别有背景，对于非常有背景的人我一般都会否定掉的。再加之她是马来西亚人，不是中国人。而且在那之前，我已经粉上了同为这季新生代的另外一个小孩王睿卓，所以对她的关注就少了。\n###一段时间\n过了很长一段时间也没有怎么关注她，只是在新浪微博中顺带关注了她的微博帐号，我发现她的关注人数也并不怎么多嘛！而且微博信息也停留在了2014年，很久没有更新了！我想，也正常，毕竟是海外的人，人家的主战场应该在Facebook。(容许我再一次鄙视一下GFW)。\n在这期间，我将很多新生代学员的歌加进了酷狗音乐，唯独其中四人的歌最讨我喜欢，(其中就包括了李馨巧)。特别是当我听厌了其他三人的歌时。她的歌声真的令我百听不厌，我要的就是这种几乎不加修饰的童声，(天籁之音)而她的歌声做到了这一点。所以我决定上网爬取所有与她相关的信息，就在这个漫长的爬取过程中，我粉上了她。\n###百度百科&维基百科\n对于任何一个公众人物来说，想了解她的信息，最好不过的就是看百科中相应的词条。百科中的词条，往往都是各个网友从其他网页中，搜集并汇集的来源可靠的资料。(这里点名批评一下百度百科，参演的电影角色名称搞反了，关键是还不让我修改)\n我就先按照她获奖的电影或电视剧中依次找寻她的镜头。并且搜索与她相关的其他电影电视剧。\n####下面是我按照时间顺序观看她参演的电影电视剧\n《激战》\n《逆战》\n《足印》\n《天天好天》\n《逃出生天3D》\n《甲洞2》\n《哥妹俩之惊历48》\n《稽查专用》\n###激战\n这也是她在大陆出名的一部影片。因为上海国际电影节破天荒的将最佳女演员的奖项给了她。使她从此获得了史上最年轻影后的殊荣。最初我以为这个奖项只是针对这部影片而言，毕竟这部影片中的女演员也确实少，也不足为奇。后面才得知是在多部影片中评选出来的。\n在百度搜索中，可以发现大多数的搜索结果都是与这部影片相关的，国内的媒体采访(包括港澳台)都基本是围绕这部影片来采访的。所以说，她在中国大陆的出名完全就是因为这部影片和上海国际电影节的金爵奖。同时也要感谢这部电影的制作方和导演(林超贤)。\n影片内容\n\n#参考资料\n百度百科\n维基百科\n","slug":"Crystal-李馨巧","published":1,"date":"2016-01-26T13:22:46.202Z","updated":"2016-01-26T13:22:46.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijvfnvfv004jigtg5xuo5s2e","sticky":0},{"title":"AC自动机算法详解","comments":0,"_content":"<a href=\"http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\"><title></title></head><body></body></html>\n\n","source":"_posts/AC自动机算法详解.md","raw":"---\ntitle: AC自动机算法详解\ntags:\n  - AC自动机\ncategories:\n  - 信息学\n  - 转载\ncomments: false\n---\n<a href=\"http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\">转载文章</a>\n****\n<html><head><meta \nhttp-equiv=\"Content-Language\" content=\"zh-CN\"><meta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; \ncharset=gb2312\"><meta http-equiv=\"refresh\" \ncontent=\"0.05;url=http://www.cppblog.com/mythit/archive/2009/04/21/80633.html\"><title></title></head><body></body></html>\n\n","slug":"AC自动机算法详解","published":1,"date":"2015-12-22T09:53:22.948Z","updated":"2015-12-22T09:53:22.948Z","layout":"post","photos":[],"link":"","_id":"cijvfnvfz004nigtg4u0svupv","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cijvfnusw0000igtgk9orb0ev","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnuuf0005igtgqkictpgr"},{"post_id":"cijvfnusw0000igtgk9orb0ev","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnuuf0006igtgh2zos78b"},{"post_id":"cijvfnv6y000aigtgg8c3709f","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv7m000bigtgi4b0r4t6"},{"post_id":"cijvfnv6y000aigtgg8c3709f","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnv7n000digtgvsksa82w"},{"post_id":"cijvfnv8b000higtgxohtbph4","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv8e000iigtgsxyry6vr"},{"post_id":"cijvfnv8b000higtgxohtbph4","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnv8f000kigtgkbeobavr"},{"post_id":"cijvfnv8n000rigtgpcniu04w","category_id":"cijvfnv8p000sigtg102o1gx1","_id":"cijvfnv8q000wigtgd8nm7wbc"},{"post_id":"cijvfnv8n000rigtgpcniu04w","category_id":"cijvfnv8q000uigtg7jzkxsjo","_id":"cijvfnv8r000xigtgfypj7eae"},{"post_id":"cijvfnv8w000yigtgk3thkqiu","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv8y000zigtgs4owklbr"},{"post_id":"cijvfnv8w000yigtgk3thkqiu","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnv8y0011igtgqvduagsg"},{"post_id":"cijvfnv910013igtgt5mmfvkz","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv960014igtgwdw1uwbm"},{"post_id":"cijvfnv910013igtgt5mmfvkz","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnv980016igtglea1admh"},{"post_id":"cijvfnv9h0018igtgh9tpvrb1","category_id":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnv9s001digtg6bj2938s"},{"post_id":"cijvfnv9h0018igtgh9tpvrb1","category_id":"cijvfnv9p001bigtgmmff8ybj","_id":"cijvfnv9s001eigtgo0u8przh"},{"post_id":"cijvfnv9t001figtg9wzebcn3","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnv9y001jigtg4jg20v7s"},{"post_id":"cijvfnv9t001figtg9wzebcn3","category_id":"cijvfnv9v001gigtg2lgpa94c","_id":"cijvfnv9z001kigtg61caj4b1"},{"post_id":"cijvfnva3001ligtgqdajjd2b","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnva6001migtgrifp20n4"},{"post_id":"cijvfnva3001ligtgqdajjd2b","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnva7001oigtg795yfegx"},{"post_id":"cijvfnvab001pigtgr8yy8tts","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvad001qigtglhn4vng7"},{"post_id":"cijvfnvab001pigtgr8yy8tts","category_id":"cijvfnv9v001gigtg2lgpa94c","_id":"cijvfnvad001rigtg2k5ja5v3"},{"post_id":"cijvfnvaf001sigtgnxs12xbg","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvaj001tigtg6behkwsn"},{"post_id":"cijvfnvaf001sigtgnxs12xbg","category_id":"cijvfnv9v001gigtg2lgpa94c","_id":"cijvfnvak001uigtgvyjyojom"},{"post_id":"cijvfnvam001vigtg2qx6bfov","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvao001wigtgdv8044v3"},{"post_id":"cijvfnvam001vigtg2qx6bfov","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvap001yigtgufk9khqd"},{"post_id":"cijvfnvaq0020igtgi6ieq6ci","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvb60021igtgyqmht4bi"},{"post_id":"cijvfnvaq0020igtgi6ieq6ci","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvb60023igtg2iofg511"},{"post_id":"cijvfnvba0024igtg793nh9dd","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvbd0025igtgh2ky6oy7"},{"post_id":"cijvfnvba0024igtg793nh9dd","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvbe0027igtgtx2ncqff"},{"post_id":"cijvfnvbg0028igtgowo4elhw","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvbi0029igtguhmb5c0t"},{"post_id":"cijvfnvbg0028igtgowo4elhw","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvbm002bigtgxurzoe1m"},{"post_id":"cijvfnvbo002cigtgeoawwqn8","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvbq002digtgarcqy2us"},{"post_id":"cijvfnvbo002cigtgeoawwqn8","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvbr002figtg6d1qjc1l"},{"post_id":"cijvfnvbs002gigtgazooo1re","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvbx002higtgdw4tv733"},{"post_id":"cijvfnvbs002gigtgazooo1re","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvby002jigtgzreeh60v"},{"post_id":"cijvfnvc0002kigtg73xsojxo","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvc9002ligtg6rembc6u"},{"post_id":"cijvfnvc0002kigtg73xsojxo","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvca002nigtgmsr8ci7i"},{"post_id":"cijvfnvcq002oigtggpryvh9o","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvcs002pigtg756r4gca"},{"post_id":"cijvfnvcq002oigtggpryvh9o","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvct002rigtgr5xk3vjn"},{"post_id":"cijvfnvcy002sigtgfbxh8oiq","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvd1002tigtgrw4qcrn3"},{"post_id":"cijvfnvcy002sigtgfbxh8oiq","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvd1002vigtg5wo5ofzu"},{"post_id":"cijvfnvd7002xigtge9hlwb5x","category_id":"cijvfnv8p000sigtg102o1gx1","_id":"cijvfnvd9002yigtgvoe4cxqk"},{"post_id":"cijvfnvd7002xigtge9hlwb5x","category_id":"cijvfnv8q000uigtg7jzkxsjo","_id":"cijvfnvd90030igtgqaghatku"},{"post_id":"cijvfnvdb0031igtgzh5owaqx","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvdd0032igtg9ixw16j5"},{"post_id":"cijvfnvdb0031igtgzh5owaqx","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvde0034igtg3hsw58cm"},{"post_id":"cijvfnvdj0039igtgnkvlgii1","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvdk003aigtgpsfwjn9g"},{"post_id":"cijvfnvdj0039igtgnkvlgii1","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvdm003cigtgjknh5rfv"},{"post_id":"cijvfnvdo003digtgu9wdidd3","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvdx003eigtgxnahjkhe"},{"post_id":"cijvfnvdo003digtgu9wdidd3","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnve0003gigtgmtv4qe5r"},{"post_id":"cijvfnve3003higtgo614xfjq","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvec003iigtgqq6h0tm6"},{"post_id":"cijvfnve3003higtgo614xfjq","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvef003jigtg1wil0ada"},{"post_id":"cijvfnvei003kigtg6b76t561","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvel003ligtg1tqmphtf"},{"post_id":"cijvfnvei003kigtg6b76t561","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnveo003nigtgxa8a0237"},{"post_id":"cijvfnveq003oigtg53g8z53q","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvet003pigtg16cmai8n"},{"post_id":"cijvfnveq003oigtg53g8z53q","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnveu003rigtg3lo95sqx"},{"post_id":"cijvfnvex003sigtgvk0mctjv","category_id":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnvf0003tigtg67tsuz7k"},{"post_id":"cijvfnvex003sigtgvk0mctjv","category_id":"cijvfnv9p001bigtgmmff8ybj","_id":"cijvfnvf1003vigtg8o74j23f"},{"post_id":"cijvfnvf6003zigtgwgrattip","category_id":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnvf80040igtgx26r2yq6"},{"post_id":"cijvfnvf6003zigtgwgrattip","category_id":"cijvfnv9p001bigtgmmff8ybj","_id":"cijvfnvf90042igtg7go4xxg3"},{"post_id":"cijvfnvfb0043igtgvbb48thc","category_id":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnvfd0044igtgy8jm7xg1"},{"post_id":"cijvfnvfb0043igtgvbb48thc","category_id":"cijvfnv9p001bigtgmmff8ybj","_id":"cijvfnvfe0046igtgsm8qx9yr"},{"post_id":"cijvfnvfg0048igtgyrf6nc84","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvfi0049igtge54g1egb"},{"post_id":"cijvfnvfg0048igtgyrf6nc84","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvfk004bigtgy1kp3rcw"},{"post_id":"cijvfnvfn004eigtgqi6nqbd9","category_id":"cijvfnv9o0019igtgoppapk7z","_id":"cijvfnvft004higtgcsz10iwl"},{"post_id":"cijvfnvfn004eigtgqi6nqbd9","category_id":"cijvfnvfr004figtgwoupcok8","_id":"cijvfnvft004iigtg3wwn7e1u"},{"post_id":"cijvfnvfv004jigtg5xuo5s2e","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvfy004kigtgjghcxd5q"},{"post_id":"cijvfnvfv004jigtg5xuo5s2e","category_id":"cijvfnute0003igtgjkrrt2xq","_id":"cijvfnvfy004migtgxqw7i8s3"},{"post_id":"cijvfnvfz004nigtg4u0svupv","category_id":"cijvfnut50001igtgurd5r3t5","_id":"cijvfnvg1004oigtg6pp2pl66"},{"post_id":"cijvfnvfz004nigtg4u0svupv","category_id":"cijvfnv9v001gigtg2lgpa94c","_id":"cijvfnvg2004qigtgj5729md5"}],"PostTag":[{"post_id":"cijvfnusw0000igtgk9orb0ev","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnute0004igtg2ayc23z4"},{"post_id":"cijvfnv6y000aigtgg8c3709f","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnv7o000figtgvroextt8"},{"post_id":"cijvfnv6y000aigtgg8c3709f","tag_id":"cijvfnv7n000eigtgz5hsko5z","_id":"cijvfnv7o000gigtgfmrsibag"},{"post_id":"cijvfnv8b000higtgxohtbph4","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnv8h000nigtg9k6ub7o1"},{"post_id":"cijvfnv8b000higtgxohtbph4","tag_id":"cijvfnv8f000jigtg9ijgjm9q","_id":"cijvfnv8h000oigtgqn9kesnm"},{"post_id":"cijvfnv8b000higtgxohtbph4","tag_id":"cijvfnv8f000ligtgnzi30whh","_id":"cijvfnv8i000pigtgga1m6ah7"},{"post_id":"cijvfnv8b000higtgxohtbph4","tag_id":"cijvfnv8h000migtgx95gpa0g","_id":"cijvfnv8i000qigtgr371uawi"},{"post_id":"cijvfnv8n000rigtgpcniu04w","tag_id":"cijvfnv8p000tigtgxxz5z68o","_id":"cijvfnv8q000vigtgn3qkczgv"},{"post_id":"cijvfnv8w000yigtgk3thkqiu","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnv8y0010igtghjfqlytc"},{"post_id":"cijvfnv8w000yigtgk3thkqiu","tag_id":"cijvfnv7n000eigtgz5hsko5z","_id":"cijvfnv8z0012igtgzmvzei96"},{"post_id":"cijvfnv910013igtgt5mmfvkz","tag_id":"cijvfnv970015igtgp12tw842","_id":"cijvfnv980017igtgxgm5hrbh"},{"post_id":"cijvfnv9h0018igtgh9tpvrb1","tag_id":"cijvfnv9o001aigtg5rjxjchp","_id":"cijvfnv9p001cigtgadac5o0a"},{"post_id":"cijvfnv9t001figtg9wzebcn3","tag_id":"cijvfnv9w001higtg24xia26z","_id":"cijvfnv9x001iigtgrjrzoxxi"},{"post_id":"cijvfnva3001ligtgqdajjd2b","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnva6001nigtgplq2w8la"},{"post_id":"cijvfnvam001vigtg2qx6bfov","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvao001xigtgwje9ixjm"},{"post_id":"cijvfnvam001vigtg2qx6bfov","tag_id":"cijvfnv8f000jigtg9ijgjm9q","_id":"cijvfnvap001zigtgfm2urzxr"},{"post_id":"cijvfnvaq0020igtgi6ieq6ci","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvb60022igtgfrn55g0t"},{"post_id":"cijvfnvba0024igtg793nh9dd","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvbe0026igtg55ukl9y1"},{"post_id":"cijvfnvbg0028igtgowo4elhw","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvbm002aigtglxbz0p7z"},{"post_id":"cijvfnvbo002cigtgeoawwqn8","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvbr002eigtg026diu2q"},{"post_id":"cijvfnvbs002gigtgazooo1re","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvby002iigtghptnjxl3"},{"post_id":"cijvfnvc0002kigtg73xsojxo","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvca002migtgpxkerej8"},{"post_id":"cijvfnvcq002oigtggpryvh9o","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvct002qigtgp0jg9jco"},{"post_id":"cijvfnvcy002sigtgfbxh8oiq","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvd1002uigtgqepuaps6"},{"post_id":"cijvfnvd7002xigtge9hlwb5x","tag_id":"cijvfnv8p000tigtgxxz5z68o","_id":"cijvfnvd9002zigtghxorwrr9"},{"post_id":"cijvfnvdb0031igtgzh5owaqx","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvdf0036igtg7wxjvtc3"},{"post_id":"cijvfnvdb0031igtgzh5owaqx","tag_id":"cijvfnvdd0033igtgklhwhcxf","_id":"cijvfnvdf0037igtgy9ovcp4d"},{"post_id":"cijvfnvdb0031igtgzh5owaqx","tag_id":"cijvfnvde0035igtg8bll1or4","_id":"cijvfnvdg0038igtgkffqdum6"},{"post_id":"cijvfnvdj0039igtgnkvlgii1","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvdm003bigtgg03ittpu"},{"post_id":"cijvfnvdo003digtgu9wdidd3","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvdy003figtgzkvtootr"},{"post_id":"cijvfnvei003kigtg6b76t561","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvel003migtgp2a1mw6d"},{"post_id":"cijvfnveq003oigtg53g8z53q","tag_id":"cijvfnut90002igtgk2b1tfwu","_id":"cijvfnvet003qigtgvkkhtj1i"},{"post_id":"cijvfnvex003sigtgvk0mctjv","tag_id":"cijvfnvf0003uigtgnu8ozsz2","_id":"cijvfnvf1003xigtg3ir7cxaq"},{"post_id":"cijvfnvex003sigtgvk0mctjv","tag_id":"cijvfnvf1003wigtgxtr5if87","_id":"cijvfnvf1003yigtg8apuq46l"},{"post_id":"cijvfnvf6003zigtgwgrattip","tag_id":"cijvfnv9o001aigtg5rjxjchp","_id":"cijvfnvf90041igtgs0tlse0d"},{"post_id":"cijvfnvfb0043igtgvbb48thc","tag_id":"cijvfnvf0003uigtgnu8ozsz2","_id":"cijvfnvfe0045igtgaa0sr72c"},{"post_id":"cijvfnvfb0043igtgvbb48thc","tag_id":"cijvfnvf1003wigtgxtr5if87","_id":"cijvfnvfe0047igtg6z2y4k40"},{"post_id":"cijvfnvfg0048igtgyrf6nc84","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvfl004cigtg5jdpqxam"},{"post_id":"cijvfnvfg0048igtgyrf6nc84","tag_id":"cijvfnvfk004aigtgxfvm8u26","_id":"cijvfnvfl004digtgungqeggk"},{"post_id":"cijvfnvfn004eigtgqi6nqbd9","tag_id":"cijvfnvf0003uigtgnu8ozsz2","_id":"cijvfnvfs004gigtguoe9819d"},{"post_id":"cijvfnvfv004jigtg5xuo5s2e","tag_id":"cijvfnv7m000cigtghp61fz65","_id":"cijvfnvfy004ligtgoxhm48yc"},{"post_id":"cijvfnvfz004nigtg4u0svupv","tag_id":"cijvfnvg1004pigtg87ovq9ey","_id":"cijvfnvg2004rigtgizgc2xeo"}],"Tag":[{"name":"总结","_id":"cijvfnut90002igtgk2b1tfwu"},{"name":"题解","_id":"cijvfnv7m000cigtghp61fz65"},{"name":"矩阵乘法","_id":"cijvfnv7n000eigtgz5hsko5z"},{"name":"线段树","_id":"cijvfnv8f000jigtg9ijgjm9q"},{"name":"hash","_id":"cijvfnv8f000ligtgnzi30whh"},{"name":"快速幂","_id":"cijvfnv8h000migtgx95gpa0g"},{"name":"软件","_id":"cijvfnv8p000tigtgxxz5z68o"},{"name":"模板","_id":"cijvfnv970015igtgp12tw842"},{"name":"工具","_id":"cijvfnv9o001aigtg5rjxjchp"},{"name":"KMP","_id":"cijvfnv9w001higtg24xia26z"},{"name":"LCA","_id":"cijvfnvdd0033igtgklhwhcxf"},{"name":"RMQ","_id":"cijvfnvde0035igtg8bll1or4"},{"name":"教程","_id":"cijvfnvf0003uigtgnu8ozsz2"},{"name":"版本控制","_id":"cijvfnvf1003wigtgxtr5if87"},{"name":"floyd算法","_id":"cijvfnvfk004aigtgxfvm8u26"},{"name":"AC自动机","_id":"cijvfnvg1004pigtg87ovq9ey"}]}}
>>>>>>> 13e8b8c8193256800de913bedce96c3f206a4f5f
