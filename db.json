{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":0},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0},{"_id":"themes/next/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0}],"Cache":[{"_id":"source/_posts/cc软件集.md","shasum":"9960ad2e7b2031d4d1a1809600efd3b5c1f5c7ca","modified":1450350973375},{"_id":"source/_posts/hello-world.md","shasum":"94da445cf40727689a120377e653ba867a21abe8","modified":1450350973375},{"_id":"source/_posts/【NOIP2013模拟联考9】阿Q的停车场.md","shasum":"bfd5a17f5cb948c1a687bc6e0926e226e54fea37","modified":1450350973376},{"_id":"source/_posts/【NOIP】剑与魔法(dragons).md","shasum":"9b07b642f13c2373bf550118264276d1a9db5a79","modified":1450350973420},{"_id":"source/_posts/【转载】有向图强连通分量的Tarjan算法.md","shasum":"88567223d255102874b96936fb342d8bcd0eba54","modified":1450350973421},{"_id":"source/_posts/【转载】表达式求值问题.md","shasum":"6e103f28ce1ad4c8b49c2251d9f563d0044f7b6a","modified":1450350973422},{"_id":"source/_posts/抽签程序.md","shasum":"0d346c263e33ea9cfbf2c00cd59751d808792e73","modified":1450350973423},{"_id":"source/about/index.md","shasum":"b767c113d9a6be83111e36162f7d146e62baf3ba","modified":1450350973424},{"_id":"source/categories/index.md","shasum":"725b598e4c04118279ed53013efa7d63e27b7b38","modified":1450350973425},{"_id":"source/tags/index.md","shasum":"d99b072725fcb3411592bc4c34f24d4f4b1fa876","modified":1450350973426},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976280},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976477},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976478},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976478},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1450350976526},{"_id":"themes/next/README.en.md","shasum":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1450350976000},{"_id":"themes/next/README.md","shasum":"b2499c61ef9cf6ee31ed5606ed43ef247c73de63","modified":1450350976000},{"_id":"themes/next/_config.yml","shasum":"c691ee11c633c5ff01e24b396c414517ffe42ef7","modified":1450350976001},{"_id":"themes/next/bower.json","shasum":"d46717b4a025790cda33d78339780c8749aee7fd","modified":1450350976001},{"_id":"themes/next/languages/de.yml","shasum":"3af67eda28640a99e17d06eec0c664e54e95fb2d","modified":1450350976002},{"_id":"themes/next/languages/default.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1450350976002},{"_id":"themes/next/languages/en.yml","shasum":"982bfffdb6ab495867255e79d852a9adb68bd10c","modified":1450350976002},{"_id":"themes/next/languages/fr-FR.yml","shasum":"eb05b50f49a29d46e90e45fabb12a14be6d7631d","modified":1450350976003},{"_id":"themes/next/languages/pt.yml","shasum":"e32711ad646d05911b515cc30e14c57f534a0045","modified":1450350976003},{"_id":"themes/next/languages/ru.yml","shasum":"4d1c2d4f4040d447a3511da51dc9fea7b177a7a6","modified":1450350976005},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"ba22a703638a23fce2cc51fcdfb1ba4dd7bcd114","modified":1450350976006},{"_id":"themes/next/languages/zh-hk.yml","shasum":"f80a494ecf23166152011cb5f4e9174fefa9197c","modified":1450350976006},{"_id":"themes/next/languages/zh-tw.yml","shasum":"f60af901f90fab657a1d27f981ad3381069842d0","modified":1450350976007},{"_id":"themes/next/layout/_layout.swig","shasum":"43dc8e01ca4d2e508db830250f2dcba7ded94830","modified":1450350976008},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"60766ca0cf5ba834d445c3304695d1a7ce0e1a36","modified":1450350976008},{"_id":"themes/next/layout/_macro/post.swig","shasum":"affea948ef5ad04dd089350340af722bcb2e7892","modified":1450350976009},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"c0f68851e8835b41fb60e7a78f096235067f7754","modified":1450350976009},{"_id":"themes/next/layout/_partials/comments.swig","shasum":"93055fc8e034037321280c182997a2a726e10c41","modified":1450350976010},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","shasum":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1450350976010},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"779fc2ec44464d66cadcc85913c49b2d8aad3d22","modified":1450350976011},{"_id":"themes/next/layout/_partials/head.swig","shasum":"471e197800829e9704ba9bb8f2d8f342c3e65c44","modified":1450350976011},{"_id":"themes/next/layout/_partials/header.swig","shasum":"8c8ae71c41722815540950ccefac47d6876d0413","modified":1450350976012},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"3c4d930d34c234725065173780a23673e1c574f5","modified":1450350976012},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1450350976013},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"73e8294939bbbb46755798215c605ebe5af5918f","modified":1450350976014},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1450350976014},{"_id":"themes/next/layout/_partials/search.swig","shasum":"1b86eb85017599392071d1230171e900045f8e69","modified":1450350976013},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1450350976015},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"12684840de632eb16e53ffa863166306a756fd4f","modified":1450350976016},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1450350976017},{"_id":"themes/next/layout/_scripts/analytics/facebook-sdk.swig","shasum":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1450350976017},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1450350976018},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"5e1b2b547a8f07ea0e3ab2a97dac9cc7d1e13c9a","modified":1450350976016},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"640d4dda003f54a0dffa4508fba4d91ac0dcfa6e","modified":1450350976018},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"0aad8d447567b683108b274c841c536b2daa176d","modified":1450350976019},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1450350976020},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"b03b2f596b7b9795f63dc4174329bf14aee7a48c","modified":1450350976021},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"701dfc53d750635de2f08f08d072d6ceb83b636c","modified":1450350976068},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1450350976068},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"8eecd19c756df615afb3f5ec6a527cd7bd06d20c","modified":1450350976069},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"de1fc505acbe8dc84f7376fe6ae9871f22d5582e","modified":1450350976069},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"ac600616e83e23ee446a646c57500706936bb45e","modified":1450350976070},{"_id":"themes/next/layout/_scripts/tinysou.swig","shasum":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1450350976070},{"_id":"themes/next/layout/archive.swig","shasum":"40e899e690172d8dd19317b17ec7be94406f114f","modified":1450350976102},{"_id":"themes/next/layout/category.swig","shasum":"c777432e1587826ccad5a4aa50309763a82df52b","modified":1450350976102},{"_id":"themes/next/layout/index.swig","shasum":"56a70d0cd51ce739787da3e07638969ccb6abd2f","modified":1450350976103},{"_id":"themes/next/layout/page.swig","shasum":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1450350976103},{"_id":"themes/next/layout/post.swig","shasum":"e67a6aabe4d71cbcf01a4cace652424bd49acc9b","modified":1450350976103},{"_id":"themes/next/layout/tag.swig","shasum":"06417b0b050c66d816323b6178c9376ba2e58dd9","modified":1450350976104},{"_id":"themes/next/scripts/filters/sticky.js","shasum":"4e4c9a837e186f94f256bd6eabb89b138cfc0db6","modified":1450350976105},{"_id":"themes/next/scripts/merge-configs.js","shasum":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1450350976105},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"99b66949f18398689b904907af23c013be1b978f","modified":1450350976106},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1450350976106},{"_id":"themes/next/scripts/tags/group-pictures.js","shasum":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1450350976106},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"dac21141c7893ab9de697a8183d3b3f4eb7f0a5a","modified":1450350976108},{"_id":"themes/next/source/css/_common/_component/blockquote-center.styl","shasum":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1450350976108},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"0a1730773478d843e123404ab4dae24d7cb0f2b7","modified":1450350976171},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1450350976171},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"cd2ec04433d6c98a0994945475fb47155d1015c0","modified":1450350976172},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1450350976173},{"_id":"themes/next/source/css/_common/_component/group-pictures.styl","shasum":"70d7c3b5f8f2485dcce1a27e2c9b43df988fbc6f","modified":1450350976174},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1450350976174},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"88559b13ce94311405b170a0506ded91273beceb","modified":1450350976175},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8909298333c6dfc6e3686d85e4d98c76dfcf75c9","modified":1450350976175},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"008d5f951144c7fe5c7e66dac330d5fb715a0a83","modified":1450350976176},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"f28f00b2acb0df0343e77400bcc8246b40ac046c","modified":1450350976177},{"_id":"themes/next/source/css/_common/_component/posts.styl","shasum":"52badf0e8a0a44bb67f16486ada44d945b1aba6b","modified":1450350976177},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1450350976178},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"90a36892f5f595dda58a86901782b1addbdb3b46","modified":1450350976179},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"b8e1b52b7aaa94b7c52d1681225e80f1af1219fa","modified":1450350976180},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1450350976180},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"3702c4c350524622f7dd658b05449fc425a819ef","modified":1450350976235},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"16a98866f5025c050c56e52312228355a16d00d9","modified":1450350976235},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"c46d16429b85570347373fd11db8c222f6ff914e","modified":1450350976236},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"7bdc92a55f2eee20b6b546e93e4566696b459b9d","modified":1450350976237},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"dbb0843ea5aa7c2ac2755a2d1ce60fa662f1b939","modified":1450350976277},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"692c01dcdc612c3e1e245cf93d0ace0a4e2aaf3f","modified":1450350976278},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"a9f5260198225801eb5c16345a69a7e3cab904fe","modified":1450350976278},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"df9e5a418f6e54abe69c1ab84649be46fb0c51a6","modified":1450350976279},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1450350976280},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1450350976335},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"6eaa5d9cb08ecfb2d377a475e541e41fbfe4c1b6","modified":1450350976336},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1450350976337},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"cd6527e4877f62f08e8668b020ec9f9e53f625a9","modified":1450350976337},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"9a9630b7aae08b5008f3a0ff1152bdca427ff644","modified":1450350976369},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"482784c04c0cd15a3f0d86444966fe306af7d13a","modified":1450350976370},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"406b78061c45bda0376ce2360ff2932262f5f2f0","modified":1450350976370},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"627cdd38b34b15c9fc17f4dc332b1be928f8ed0d","modified":1450350976474},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1450350976475},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1450350976476},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1450350976478},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","shasum":"e4b5b56e1a035c99ebd50d00e93d89e2e8d0b735","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","shasum":"452e71caf2c37fa5a06f8d9ada81337a57485885","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","shasum":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1450350976520},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","shasum":"3b0a186e8d9d5cfe30dd611456b61053ea535d7b","modified":1450350976521},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1450350976521},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"f10be4b0c642104a6f533b94ac09e22019aa640e","modified":1450350976522},{"_id":"themes/next/source/css/_schemes/default/_logo.styl","shasum":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1450350976522},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"dd667be3f5f24cebdc15d0262c7d397f23d751c5","modified":1450350976523},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"e315ee6f604c2bcc44a5ef9078f5ce420c153a4b","modified":1450350976523},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"ecd76494cea5fbf592cc13ba1e4ccdfedbc5bf1b","modified":1450350976525},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"932cb9c53d64b086638adca05dcf4e2df239a8f9","modified":1450350976526},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"9bc1cad0c7a9f4fdfa665098fb5c542dc9e640db","modified":1450350976526},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1450350976527},{"_id":"themes/next/source/css/main.styl","shasum":"6bb842ad45a575774299bed3848d46475820fb9f","modified":1450350976528},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1450350976529},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1450350976529},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1450350976530},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1450350976530},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1450350976531},{"_id":"themes/next/source/images/cc-by.svg","shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1450350976531},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1450350976532},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450350976532},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1450350976532},{"_id":"themes/next/source/images/quote-l.svg","shasum":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1450350976533},{"_id":"themes/next/source/images/quote-r.svg","shasum":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1450350976533},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1450350976533},{"_id":"themes/next/source/js/bootstrap.js","shasum":"5a963f40fb81d265a31679f8f543e50ffdcc7485","modified":1450350976534},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"97640be11a524b203781c1a03f623ef0b9195a02","modified":1450350976534},{"_id":"themes/next/source/js/fancy-box.js","shasum":"fbeabc936667a9e15556c8defb5fcd582add8067","modified":1450350976535},{"_id":"themes/next/source/js/helpers.js","shasum":"69d8ae9b686a82e3a4397b61a477eb8da68bd153","modified":1450350976535},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1450350976536},{"_id":"themes/next/source/js/motion.js","shasum":"a9327a3c0a5df289799c5ffe3e8bf7dd6e407797","modified":1450350976536},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"fc57202d8d952fceb3f1ad5b6e7183f47a3f1a0e","modified":1450350976537},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450350976538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450350976539},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450350976539},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450350976575},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450350976575},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450350976576},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450350976576},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1450350976577},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1450350976621},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1450350976621},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1450350976622},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1450350976622},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1450350976623},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1450350976624},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1450350976624},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1450350976625},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1450350976626},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1450350976650},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1450350976651},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1450350976651},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1450350976716},{"_id":"themes/next/source/vendors/font-awesome/bower.json","shasum":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1450350976716},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","shasum":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1450350976718},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1450350976719},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1450350976814},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1450350976846},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1450350976884},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","shasum":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1450350976884},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","shasum":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1450350976916},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1450350976917},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1450350976918},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1450350976920},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1450350976972},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1450350976974},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1450350976974},{"_id":"themes/next/test/helpers.js","shasum":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1450350976976},{"_id":"themes/next/test/intern.js","shasum":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1450350976977},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1450350976818},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1450350976819},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1450350976845},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1450350976849},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1450350976843},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1450350976924},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1450350976841},{"_id":"public/vendors/velocity/velocity.ui.min.js","modified":1450496011792,"shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908"},{"_id":"public/vendors/velocity/velocity.ui.js","modified":1450496011799,"shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df"},{"_id":"public/vendors/velocity/velocity.min.js","modified":1450496011802,"shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6"},{"_id":"public/vendors/velocity/velocity.js","modified":1450496011806,"shasum":"9f08181baea0cc0e906703b7e5df9111b9ef3373"},{"_id":"public/vendors/velocity/bower.json","modified":1450496011810,"shasum":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409"},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","modified":1450496011813,"shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1"},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","modified":1450496011818,"shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3"},{"_id":"public/vendors/jquery_lazyload/bower.json","modified":1450496011820,"shasum":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53"},{"_id":"public/vendors/jquery_lazyload/README.html","modified":1450496011860,"shasum":"c593e16f0d63d24b5d3933f3b9297884867ce4a0"},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","modified":1450496011873,"shasum":"bf8e477ee2d81833cff12572a8a5f61abffc187c"},{"_id":"public/vendors/jquery/index.js","modified":1450496011878,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1450496011887,"shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1450496011894,"shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1450496011899,"shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1450496011904,"shasum":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1450496011913,"shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6"},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","modified":1450496011918,"shasum":"0112e96f327d413938d37c1693806f468ffdbace"},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","modified":1450496011923,"shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22"},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","modified":1450496011931,"shasum":"1573904b82807abbb32c97a3632c6c6808eaac50"},{"_id":"public/vendors/font-awesome/css/font-awesome.css","modified":1450496011937,"shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7"},{"_id":"public/vendors/font-awesome/bower.json","modified":1450496011945,"shasum":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad"},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","modified":1450496011949,"shasum":"ed80b43dbc7e3009b2f436741b9796df8eb3be02"},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","modified":1450496011954,"shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18"},{"_id":"public/vendors/fastclick/lib/fastclick.js","modified":1450496011963,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/vendors/fastclick/bower.json","modified":1450496011967,"shasum":"4dcecf83afddba148464d5339c93f6d0aa9f42e9"},{"_id":"public/vendors/fastclick/README.html","modified":1450496011977,"shasum":"5bef8b8758435bc08129f6d374740527a6a9b942"},{"_id":"public/vendors/fastclick/LICENSE","modified":1450496011990,"shasum":"6f474ea75c42442da7bbcf2e9143ce98258efd8d"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","modified":1450496012009,"shasum":"53360764b429c212f424399384417ccc233bb3be"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","modified":1450496012015,"shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","modified":1450496012018,"shasum":"5f163444617b6cf267342f06ac166a237bb62df9"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1450496012023,"shasum":"53e194f4a72e649c04fb586dd57762b8c022800b"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1450496012028,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1450496012033,"shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1450496012037,"shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1450496012040,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1450496012045,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","modified":1450496012049,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","modified":1450496012055,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","modified":1450496012060,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","modified":1450496012063,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","modified":1450496012066,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/vendors/fancybox/source/blank.gif","modified":1450496012070,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/js/ua-parser.min.js","modified":1450496012074,"shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6"},{"_id":"public/js/motion.js","modified":1450496012079,"shasum":"b4132517fe499538ad725094593fb7ead8c04bf7"},{"_id":"public/js/hook-duoshuo.js","modified":1450496012082,"shasum":"eedaf52377991728f1e3e94f2bc4bf23ec41ecea"},{"_id":"public/js/helpers.js","modified":1450496012088,"shasum":"c15216ef897334362789ba37464298948b2eef95"},{"_id":"public/js/fancy-box.js","modified":1450496012091,"shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2"},{"_id":"public/js/bootstrap.scrollspy.js","modified":1450496012095,"shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625"},{"_id":"public/js/bootstrap.js","modified":1450496012099,"shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299"},{"_id":"public/images/searchicon.png","modified":1450496012104,"shasum":"67727a6a969be0b2659b908518fa6706eed307b8"},{"_id":"public/images/quote-r.svg","modified":1450496012109,"shasum":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41"},{"_id":"public/images/quote-l.svg","modified":1450496012113,"shasum":"cd108d6f44351cadf8e6742565217f88818a0458"},{"_id":"public/images/placeholder.gif","modified":1450496012116,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/loading.gif","modified":1450496012119,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/cc-zero.svg","modified":1450496012123,"shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d"},{"_id":"public/images/cc-by.svg","modified":1450496012128,"shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70"},{"_id":"public/images/cc-by-sa.svg","modified":1450496012133,"shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398"},{"_id":"public/images/cc-by-nd.svg","modified":1450496012137,"shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8"},{"_id":"public/images/cc-by-nc.svg","modified":1450496012141,"shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab"},{"_id":"public/images/cc-by-nc-sa.svg","modified":1450496012145,"shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3"},{"_id":"public/images/cc-by-nc-nd.svg","modified":1450496012148,"shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668"},{"_id":"public/css/main.css","modified":1450496012697,"shasum":"3695d82a380d4a03fc02a1e58763bb40fe6e527d"},{"_id":"public/tags/index.html","modified":1450496012973,"shasum":"95b17abfaf7683b359e93e8ff711b7b10499b678"},{"_id":"public/categories/index.html","modified":1450496013033,"shasum":"0f926467ff5928140ed1d8b65c54710469ef2fcf"},{"_id":"public/about/index.html","modified":1450496013093,"shasum":"ac744d2711da597fb79d28c32fccab70aa5a4b4f"},{"_id":"public/2015/12/17/【转载】表达式求值问题/index.html","modified":1450496013247,"shasum":"001a3225b96794435d0a43da0dc5d2fc6da77360"},{"_id":"public/2015/12/17/【转载】有向图强连通分量的Tarjan算法/index.html","modified":1450496013378,"shasum":"c693eb0e019df188259e78b4f29571d070effd82"},{"_id":"public/2015/12/17/【NOIP】剑与魔法(dragons)/index.html","modified":1450496013528,"shasum":"d6fcdfc6c155ddce13f77a3f50ce084f0e95dd5e"},{"_id":"public/2015/12/17/【NOIP2013模拟联考9】阿Q的停车场/index.html","modified":1450496013608,"shasum":"df918b07875758fea142770df573492536ddf8ec"},{"_id":"public/2015/12/17/hello-world/index.html","modified":1450496013676,"shasum":"e3af97a6e5bfca1e18d3f41351aa0403b92bb461"},{"_id":"public/2015/12/11/抽签程序/index.html","modified":1450496013754,"shasum":"0372cd5477a92b11399c3eb74af4da24e9954ed1"},{"_id":"public/2015/12/11/cc软件集/index.html","modified":1450496013824,"shasum":"326fc07e674979cfc4288023d98048252b3a45b0"},{"_id":"public/archives/index.html","modified":1450496013945,"shasum":"2e64b5866bfbfb1bdf13c4e959b44d9d45142bf8"},{"_id":"public/archives/2015/index.html","modified":1450496014041,"shasum":"a34dd51f04375d148745582797dcb687f39bbde8"},{"_id":"public/archives/2015/12/index.html","modified":1450496014143,"shasum":"175cdd2f9352671bb5ccd9693f669bd2c48d7ae7"},{"_id":"public/index.html","modified":1450496014231,"shasum":"4e832fb12933e851fe96a355ba1dce075dd3cc27"},{"_id":"public/page/2/index.html","modified":1450496014317,"shasum":"d8e2ce6136cccef4e332b87c03fd5daeccb57f15"},{"_id":"public/tags/软件/index.html","modified":1450496014385,"shasum":"d78ca25c3b0dca46a9825ce829f4236461f9af56"},{"_id":"public/tags/易语言/index.html","modified":1450496014463,"shasum":"7e3d3ac660251ba26c4f97131a5aee7e6a782fdc"},{"_id":"public/tags/原创/index.html","modified":1450496014540,"shasum":"66a9ec5401727c12899da7e7e79eb677c6e950f6"},{"_id":"public/tags/信息学/index.html","modified":1450496014610,"shasum":"409109a521303ca7fc4294b7b7538779e397fbd3"},{"_id":"public/tags/转载/index.html","modified":1450496014675,"shasum":"3ca34a958832f7ede79e97b9b4d9260f4c8afea7"},{"_id":"public/tags/题解/index.html","modified":1450496014745,"shasum":"dbb118ccf649e114373573763ad207d30bd6543a"}],"Category":[],"Data":[],"Page":[{"title":"Tagcloud","date":"2015-12-12T07:40:37.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: Tagcloud\ndate: 2015-12-12 15:40:37\ntype: \"tags\"\ncomments: false\n---\n","updated":"2015-12-17T11:16:13.426Z","path":"tags/index.html","layout":"page","_id":"ciicjvfue0007lktga8jh7upd"},{"title":"categories","date":"2015-12-12T07:43:24.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-12-12 15:43:24\ntype: \"categories\"\ncomments: false\n---\n","updated":"2015-12-17T11:16:13.425Z","path":"categories/index.html","layout":"page","_id":"ciicjvfv40008lktguztyh81k"},{"title":"about","date":"2015-12-11T10:55:44.000Z","comments":0,"_content":"Not Ready!","source":"about/index.md","raw":"title: about\ndate: 2015-12-11 18:55:44\ncomments: false\n---\nNot Ready!","updated":"2015-12-17T11:16:13.424Z","path":"about/index.html","layout":"page","_id":"ciicjvfv60009lktg80vgr0pu"}],"Post":[{"title":"cc软件集","date":"2015-12-11T10:59:00.000Z","_content":"cc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","source":"_posts/cc软件集.md","raw":"title: cc软件集\ndate: 2015-12-11 18:59:00\ntags: [软件,易语言,原创]\n---\ncc软件集最新版本Version 3.1\ncc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLr\ncc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYR\ncc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZY\ncc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEk\ncc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1o\ncc软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr\n目前没有升级补丁或升级包\n\n部分开源软件及项目获取地址:https://code.csdn.net/liuyuanzhe0515\n如有疑问，请发送邮件至:<a style=\"line-height: 28px;\" rel=\"nofollow\" href=\"mailto:294068487@qq.com\">liuyuanzhe0515</a></div>\n","slug":"cc软件集","published":1,"updated":"2015-12-17T11:16:13.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfrl0000lktg9iik3rhy","sticky":0},{"title":"抽签程序","date":"2015-12-11T11:01:37.000Z","_content":"最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","source":"_posts/抽签程序.md","raw":"title: 抽签程序\ndate: 2015-12-11 19:01:37\ntags: [软件,易语言,原创]\n---\n最新版本：2.5\nVersion 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJ\nVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1\nVersion 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl\n","slug":"抽签程序","published":1,"updated":"2015-12-17T11:16:13.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfv8000alktggra0w6ug","sticky":0},{"title":"【转载】表达式求值问题","_content":"\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","source":"_posts/【转载】表达式求值问题.md","raw":"title: 【转载】表达式求值问题\ntags: [信息学,转载]\n---\n\n　　中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。\n\n　　表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子：\n\n　　3+2\n\n　　这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。\n\n　　那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西：\n\n　　3+2*5\n\n　　此时的表达式很显然，如果进行计算，则先计算2*5，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）*5。\n\n　　而如果用后缀表达式来表示，则为 32+5*，那么该表达式的计算顺序为3+2 —> (3+2)*5。\n\n　　区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。\n\n　　今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲：\n\n - 中缀表达式如何直接求值？\n - 后缀表达式如何直接求值？\n - 中缀表达式如何转换为后缀表达式？\n\n\n1.中缀表达式直接求值\n\n　　对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。\n\n　　为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。\n\n　　假如有这样一个表达式：$（（3+5*2）+3）/5+6/4*2+3$\n\n　　对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？\n\n　　先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+2*5，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+2*5,栈的变化过程为：\n\n　　<font color=#1E90FF>操作数栈：3      操作数栈：3   操作数栈：3 2 </font>\n　　\n　　<font color=#1E90FF>操作符栈：空     操作符栈：+  操作符栈：+    \n</font>\n\n\n　　注意此时遇到操作符“*”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成：\n　　<font color=#1E90FF>操作数栈：3 2   操作数栈：3 2 5</font>\n　　\n　　<font color=#1E90FF>操作符栈：+ *  操作符栈：+ *</font>\n\n　　此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。\n\n　　再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化：\n<font color=#1E90FF>　　操作数栈：2     操作数栈：2   操作数栈：2 5  </font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：*   操作符栈：*     </font>\n\n\n 　　此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成：\n<font color=#1E90FF>　　操作数栈：10   操作数栈：10 3</font>\n\n<font color=#1E90FF>　　操作符栈：空    操作符栈：+</font>\n\n　　后面的过程跟前面一个例子类似。\n\n　　如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：<font color=#FF0000>**只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。**</font>而操作符的优先级为：+和-优先级是一样的，*和/优先级是一样的，+、-的优先级低于*、/的优先级。\n\n　　不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。\n\n　　对于“-”的区分，主要判别方法为：\n\n　　1）若前一个字符为‘('，则必定为负号；\n\n　　2）若前一个字符为')'或者数字，则必定为减号；\n\n　　3）若前面一个字符为其他运算符，如*，/，则必定是负号；\n\n　　3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。\n\n　　也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为')'或者数字的时候。\n\n　　如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2\n\n　　我采取的做法是将\"#\"入栈，然后当遇到“*”时，由于栈顶操作符为\"#\"，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。\n\n　　下面是具体实现：\n　　\n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \n \nvoid calculate(stack<int> &opdStack,string opt)\n{\n    if(opt==\"#\")  //进行负号运算\n    {\n        int opd = opdStack.top();\n        int result = 0-opd;\n        opdStack.pop();\n        opdStack.push(result);\n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<opd<<endl; \n    }\n    else if(opt==\"+\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd + rOpd;\n        opdStack.push(result); \n         \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"-\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd - rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"*\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd * rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n    else if(opt==\"/\")\n    {\n        int rOpd = opdStack.top();\n        opdStack.pop();\n        int lOpd = opdStack.top();\n        opdStack.pop();\n        int result = lOpd / rOpd;\n        opdStack.push(result); \n        cout<<\"操作符:\"<<opt<<\" \"<<\"操作数:\"<<lOpd<<\" \"<<rOpd<<endl; \n    }\n}\n \nint evaMidExpression(char *str)   //中缀表达式直接求值\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    stack<int> opdStack;     //存储操作数\n    stack<string> optStack;   //存储操作符\n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        calculate(opdStack,topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                calculate(opdStack,topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            opdStack.push(atoi(token.c_str()));\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        calculate(opdStack,topOpt);\n        optStack.pop();\n    }\n    return opdStack.top();\n}\n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    cout<<evaMidExpression(str)<<endl;\n    return 0;\n}\n```\n　运行结果：\n　![这里写图片描述](http://images.cnitblog.com/i/288799/201405/062023370104707.jpg)\n\n2.后缀表达式直接求值\n\n　　由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：\nhttp://www.cnblogs.com/dolphin0520/p/3708587.html\n3.中缀表达式如何转为后缀\n\n　　大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。\n\n - 利用二叉树进行转换\n\n\n　　由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式3*5+5/2+（3+5）*2，表示成二叉树的形式（注意其有等同的其他形式）就是：![这里写图片描述](http://images.cnitblog.com/i/288799/201405/072009283855034.jpg)\n其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。\n\n　　下面是具体实现：\n\n 　　参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。\nhttp://blog.csdn.net/ericming200409/article/details/5919883\n\n```\n/*\n测试环境：VS2010\n*/\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n \ntypedef struct node\n{\n    struct node *left;\n    struct node *right;\n    char *data;\n}BinTree;\n \nchar * preProcess(char *str)   //预处理，除去空格，将负号替代为#\n{\n    int len = strlen(str);\n    char *p = (char *)malloc(sizeof(char)*len);\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        if(p[j]=='-')\n        {\n            if(!(p[j-1]==')'||isdigit(p[j-1])))  //作为减号使用\n            {\n                p[j]='#';  \n            }\n        }\n        j++;\n    }\n    return p;\n}\n \n \n/*\n最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，\n*/\nint indexOfOpt(char *str,int begin ,int end)   //寻找最后执行的操作符的下标\n{\n    int i;\n    int brackets=0;                    //所在括号层次\n    int index = -1;\n    int existAddOrMinus = 0;\n    int existMulOrDevide = 0;\n    while(str[begin]=='('&&str[end]==')')   //去除最外层的括号\n    {\n        begin++;\n        end--;\n    }\n    for(i=begin;i<=end;i++)\n    {\n        if(str[i]=='(')\n            brackets++;\n        else if(str[i]==')')\n            brackets--;\n        else if((str[i]=='+'||str[i]=='-')&&brackets==0)\n        {\n            index = i;\n            existAddOrMinus = 1;    //存在加减号\n        }\n        else if((str[i]=='*'||str[i]=='/')&&brackets==0&&existAddOrMinus==0)\n        {\n            index = i;\n            existMulOrDevide = 1;  //存在乘除号\n        }\n        else if(str[i]=='#'&&brackets==0&&existAddOrMinus==0&&existMulOrDevide==0)  //用'#'代表负号\n        {\n            index = i;\n        }\n    }\n    return index;\n}\n \nBinTree * createBinTree(char *str,int begin,int end)\n{\n    BinTree *p =(BinTree *)malloc(sizeof(BinTree));;\n    int index = indexOfOpt(str,begin,end);\n    cout<<\"index:\"<<index<<endl; \n    if(index==-1)   //表示只有操作数了\n    {\n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        p->data = (char *)malloc(sizeof(end-begin+2));\n        int i,j=0;\n        for(i=begin;i<=end;i++) \n            p->data[j++] = str[i];\n        p->data[j]='\\0';\n        p->left = NULL;\n        p->right = NULL;\n        cout<<\"操作数:\"<<p->data<<endl;\n    }\n    else\n    {\n        p->data = (char*)malloc(2);\n        p->data[0] = str[index];\n        p->data[1]='\\0';\n        cout<<\"操作符:\"<<p->data<<endl;\n             \n        while(str[begin]=='('&&str[end]==')')\n        {\n            begin++;\n            end--;\n        }\n        if(str[index]=='#')  //是负号\n        {\n            p->left = NULL;\n        }\n        else\n        {\n            p->left = createBinTree(str,begin,index-1);\n        }\n        p->right = createBinTree(str,index+1,end);\n    }\n    return p;\n}\n \nvoid preOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        cout<<root->data<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n \nvoid inOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->data<<\" \";\n        inOrder(root->right);\n    }\n}\n \nvoid postOrder(BinTree *root)\n{\n    if(root!=NULL)\n    {\n        postOrder(root->left);\n        postOrder(root->right);\n        cout<<root->data<<\" \";\n    }\n}\n \n \n \nint main(void)\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    char *newStr = preProcess(str);\n    cout<<newStr<<endl;\n    BinTree *root=createBinTree(newStr,0,strlen(newStr)-1);\n    inOrder(root);\n    cout<<endl;\n    postOrder(root);\n    cout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果：\n![这里写图片描述](http://images.cnitblog.com/i/288799/201405/142108574687965.jpg)\n\n - 利用栈进行转换\n\n　　利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式\n\n　　1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈；\n\n　　2）遇到操作数，直接加到suffix的末尾\n\n　　3）遇到左括号，入栈；\n\n　　4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。\n\n　　具体实现：\n\n \n\n```\n/*2014.5.6 测试环境: mingw*/\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n \n \nvector<string> preParse(char *str)   //对中缀表达式进行预处理，分离出每个token\n{\n    vector<string> tokens;\n    int len = strlen(str);\n    char *p = (char *)malloc((len+1)*sizeof(char));  //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间\n    int i=0,j=0;\n    while(i<len)          //去除表达式中的空格\n    {\n        if(str[i]==' ')\n        {\n            i++;\n            continue;\n        }\n        p[j++] = str[i++];\n    }\n    p[j]='\\0';\n    j=0;\n    len = strlen(p);\n    while(j<len)\n    {\n        char temp[2];\n        string token;\n        switch(p[j])\n        {\n            case '+':\n            case '*':\n            case '/':\n            case '(':\n            case ')':\n                {\n                    temp[0] =p[j];\n                    temp[1] = '\\0';\n                    token=temp;\n                    tokens.push_back(token);\n                    break;\n                }\n            case '-':\n                {\n                    if(p[j-1]==')'||isdigit(p[j-1]))  //作为减号使用\n                    {\n                        temp[0] =p[j];\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }\n                    else    //作为负号使用\n                    {\n                        temp[0] ='#';\n                        temp[1] = '\\0';\n                        token=temp;\n                        tokens.push_back(token);\n                    }  \n                    break;\n                }\n            default:     //是数字\n                {\n                    i = j;\n                    while(isdigit(p[i])&&i<len)\n                    {\n                        i++;\n                    }\n                    char *opd = (char *)malloc(i-j+1);\n                    strncpy(opd,p+j,i-j);\n                    opd[i-j]='\\0';\n                    token=opd;\n                    tokens.push_back(token);\n                    j=i-1;\n                    free(opd);\n                    break;\n                }  \n        }\n        j++;\n    }\n    free(p);\n    return tokens;\n}\n \nint getPriority(string opt)\n{\n    int priority;\n    if(opt==\"#\")\n        priority = 3;  \n    else if(opt==\"*\"||opt==\"/\")\n        priority = 2;\n    else if(opt==\"+\"||opt==\"-\")\n        priority = 1;\n    else if(opt==\"(\")\n        priority = 0;\n    return priority;\n}\n \nvector<string> toSuffix(char *str)  //转变为后缀形式\n{\n    vector<string> tokens = preParse(str);\n    int i=0;\n    int size = tokens.size();\n     \n    vector<string> suffix;     //存储后缀表达式\n    stack<string> optStack;   //存储操作符\n     \n    for(i=0;i<size;i++)\n    {\n        string token = tokens[i];\n        if(token==\"#\"||token==\"+\"||token==\"-\"||token==\"*\"||token==\"/\")\n        {\n            if(optStack.size()==0)   //如果操作符栈为空\n            {\n                optStack.push(token);\n            }\n            else\n            {\n                int tokenPriority = getPriority(token);\n                string topOpt = optStack.top();\n                int topOptPriority = getPriority(topOpt);\n                if(tokenPriority>topOptPriority)\n                {\n                    optStack.push(token);\n                }\n                else\n                {\n                    while(tokenPriority<=topOptPriority)\n                    {\n                        optStack.pop();\n                        suffix.push_back(topOpt);\n                        if(optStack.size()>0)\n                        {\n                            topOpt = optStack.top();\n                            topOptPriority = getPriority(topOpt);\n                        }\n                        else\n                            break;\n                         \n                    }\n                    optStack.push(token);\n                }\n            }  \n        }\n        else if(token==\"(\")\n        {\n            optStack.push(token);\n        }\n        else if(token==\")\")\n        {\n            while(optStack.top()!=\"(\")\n            {\n                string topOpt = optStack.top();\n                suffix.push_back(topOpt);\n                optStack.pop();\n            }\n            optStack.pop();\n        }\n        else   //如果是操作数，直接入操作数栈\n        {\n            suffix.push_back(token);\n        }\n    }\n    while(optStack.size()!=0)\n    {\n        string topOpt = optStack.top();\n        suffix.push_back(topOpt);\n        optStack.pop();\n    }\n    return suffix;\n}\n \n \n \nint main(int argc, char *argv[])\n{\n    char *str = \"((3+5*2)+3)/5+(-6)/4*2+3\";\n    vector<string> suffix = toSuffix(str);\n    int size = suffix.size();\n    for(int i=0;i<size;i++)\n        cout<<suffix[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n```\n　测试结果：\n　http://images.cnitblog.com/i/288799/201405/142229201091309.jpg\n　\n\n - 简便验证办法\n\n\n　　最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。\n\n　　比如有表达式： （3+5*2）-2*3\n\n　　先对每一个小部分添加括号： （（3+（5*2））-（2*3））\n\n　　然后将每个操作符放到括号后面：（（3（52）*）+（23）*）-\n\n　　然后去括号：352*+23*-\n\n　　便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。\n\n***\n作者：[海子](http://www.cnblogs.com/dolphin0520/)\n来源：http://www.cnblogs.com/dolphin0520/p/3708602.html\n出处：http://www.cnblogs.com/dolphin0520/\n　　　　\n本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利\n***","slug":"【转载】表达式求值问题","published":1,"date":"2015-12-17T11:16:13.422Z","updated":"2015-12-17T11:16:13.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfvc000elktgo0j7hb7n","sticky":0},{"title":"【转载】有向图强连通分量的Tarjan算法","_content":"<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","source":"_posts/【转载】有向图强连通分量的Tarjan算法.md","raw":"title: 【转载】有向图强连通分量的Tarjan算法\ntags: [信息学,转载]\n---\n<strong> [有向图强连通分量]\n--\n\n在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。\n\n下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。\n\n![这里写图片描述](https://www.byvoid.com/upload/wp/2009/04/image1.png)\n\n直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。\n\n<strong>[Tarjan算法]\n--\nTarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树。</u>搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。\n\n定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，\n\n```\nLow(u)=Min\n{\n    DFN(u),\n    Low(v),(u,v)为树枝边，u为v的父节点\n    DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)\n}\n```\n<u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u>\n\n算法伪代码如下\n\n```\ntarjan(u)\n{\n    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值\n    Stack.push(u)                              // 将节点u压入栈中\n    for each (u, v) in E                       // 枚举每一条边\n        if (v is not visted)                   // 如果节点v未被访问过\n            tarjan(v)                          // 继续向下找\n            Low[u] = min(Low[u], Low[v])\n        else if (v in S)                       // 如果节点v还在栈内\n            Low[u] = min(Low[u], DFN[v])\n    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根\n        repeat\n            v = S.pop                          // 将v退栈，为该强连通分量中一个顶点 \n            print v\n        until (u== v)\n}\n```\n接下来是对算法流程的演示。\n\n从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。\n![image](https://www.byvoid.com/upload/wp/2009/04/image2.png)\n返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image3.png)\n\n返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image4.png)\n\n继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。\n\n![image](https://www.byvoid.com/upload/wp/2009/04/image5.png)\n\n至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。\n\n可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。\n\n求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。\n\n求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。\n\n附：tarjan算法的C++程序\n\n```\nvoid tarjan(int i)\n{\n    int j;\n    DFN[i]=LOW[i]=++Dindex;\n    instack[i]=true;\n    Stap[++Stop]=i;\n    for (edge *e=V[i];e;e=e->next)\n    {\n        j=e->t;\n        if (!DFN[j])\n        {\n            tarjan(j);\n            if (LOW[j]<LOW[i])\n                LOW[i]=LOW[j];\n        }\n        else if (instack[j] && DFN[j]<LOW[i])\n            LOW[i]=DFN[j];\n    }\n    if (DFN[i]==LOW[i])\n    {\n        Bcnt++;\n        do\n        {\n            j=Stap[Stop--];\n            instack[j]=false;\n            Belong[j]=Bcnt;\n        }\n        while (j!=i);\n    }\n}\nvoid solve()\n{\n    int i;\n    Stop=Bcnt=Dindex=0;\n    memset(DFN,0,sizeof(DFN));\n    for (i=1;i<=N;i++)\n        if (!DFN[i])\n            tarjan(i);\n}\n```\n附：tarjan算法的Pascal程序\n\n```\nprocedure tarjan(x:longint);\nvar i,j:longint;\nbegin\n\tinc(time);\n\tdfn[x]:=time;\n\tlow[x]:=time;\n\tinsta[x]:=true;\n\tinc(sta);\n\tstack[sta]:=x;\n\ti:=g[x];\n\twhile i<>0 do begin\n\t\tj:=v[i];\n\t\tif color[j]<>0 then begin\n\t\t\ti:=next[i];\n\t\t\tcontinue;\n\t\tend;\n\t\tif insta[j] then low[x]:=min(low[x],dfn[j])\n\t\telse begin\n\t\t\ttarjan(j);\n\t\t\tlow[x]:=min(low[x],low[j]);\n\t\tend;\n\t\ti:=next[i];\n\tend;\n\tif dfn[x]=low[x] then begin\n\t\tinc(tot);\n\t\tj:=0;\n\t\twhile j<>x do begin\n\t\t\tj:=stack[sta];\n\t\t\tdec(sta);\n\t\t\tcolor[j]:=tot;\n\t\t\tinsta[j]:=false;\n\t\t\tsum[tot]:=sum[tot]+w[j];\n\t\tend;\n\tend;\nend;\n\n```\n\n<strong>[参考资料]\n--\nWikipedia\nAmber的图论总结\n\n<strong>Sources\n--\nBYVoid 原创作品，转载请注明。\nhttps://www.byvoid.com/blog/scc-tarjan\n","slug":"【转载】有向图强连通分量的Tarjan算法","published":1,"date":"2015-12-17T11:16:13.421Z","updated":"2015-12-17T11:16:13.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfvh000jlktgp7u1yfmf","sticky":0},{"title":"【NOIP】剑与魔法(dragons)","_content":"Description\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","source":"_posts/【NOIP】剑与魔法(dragons).md","raw":"title: 【NOIP】剑与魔法(dragons)\ntags: [题解,原创]\n---\nDescription\n--\n万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。\n\n闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。   \n\nInput\n--\n第一行一个数N，表示输入文件有多少行。\n\n接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。   \nOutput\n--\n第一行一个整数，最多金钱数目。\n\n若不可能则输出-1。\nSample Input\n--\n\n```\n5\nc 10\nc 12\ne 2\nc 1\ne 2\n```\n\nSample Output\n--\n\n```\n13\n```\n\nData Constraint\n--\n30%的数据满足 N<=20\n\n60%的数据满足 N<=1,000\n\n100%的数据满足 N<=200,000\n\n每次涨RP事件赏金不超过10,000\n\n穿越事件的要求不超过200,000   \nAnalysis\n--\n显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。\n所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻)\n\nCode\n--\n\n```\nconst\tmaxn=200000;oo=100000000;\nvar\ti,j,n,size,last,t:longint;\n\th:array[1..maxn] of longint;\n\ta:array[0..maxn,1..2] of longint;\n\tb:array[0..maxn] of longint;\n\tch:char;\n\tans:int64;\nprocedure swap(var x,y:longint);\nvar\tt:longint;\nbegin\n\tt:=x;\n\tx:=y;\n\ty:=t;\nend;\nprocedure down(x:longint);\nvar\ty:longint;\nbegin\n\ty:=2*x;\n\twhile ((y<=size) and (h[x]>h[y])) or ((y+1<=size) and (h[x]>h[y+1])) do\n\tbegin\n\t\tif (y+1<=size) and (h[y+1]<h[y]) then inc(y);\n\t\tswap(h[x],h[y]);\n\t\tx:=y;\n\t\ty:=2*x;\n\tend;\nend;\nprocedure up(x:longint);\nbegin\n\twhile (x>1) and (h[x]<h[x>>1]) do begin\n\t\tswap(h[x],h[x>>1]);\n\t\tx:=x>>1;\n\tend;\nend;\nprocedure pop;\nbegin\n\th[1]:=h[size];\n\th[size]:=oo;\n\tdec(size);\n\tdown(1);\nend;\nprocedure push(x:longint);\nvar\ti:longint;\nbegin\n\tinc(size);\n\th[size]:=x;\n\tup(size);\nend;\nbegin\n\treadln(n);\n\tfor i:=1 to n do begin\n\t\treadln(ch,a[i,2]);\n\t\tif ch='c' then a[i,1]:=1 else a[i,1]:=2;\n\tend;\n\t\n\tfor i:=1 to n-1 do begin\n\t\tif a[i,1]=1 then push(a[i,2])\n\t\telse begin\n\t\t\tt:=a[i,2]-1;\n\t\t\twhile size>t do pop;\n\t\tend;\n\tend;\n\tans:=0;\n\tfor i:=1 to size do inc(ans,h[i]);\n\twriteln(ans);\nend.\n```","slug":"【NOIP】剑与魔法(dragons)","published":1,"date":"2015-12-17T11:16:13.420Z","updated":"2015-12-17T11:16:13.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfvk000mlktgwgqggo44","sticky":0},{"title":"【NOIP2013模拟联考9】阿Q的停车场","_content":"Description\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","source":"_posts/【NOIP2013模拟联考9】阿Q的停车场.md","raw":"title:  【NOIP2013模拟联考9】阿Q的停车场\ntags: [题解,原创]\n---\nDescription\n==\n刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。\n\nInput\n==\n第一行，两个整数 n 和 m，表示停车场大小和操作数；\n\n接下来 m 行，每行两个整数，F 和 x\n\nF 是 1 表示编号为 x 的车进停车场；\n\nF 是 2 表示编号为 x 的车出停车场；\n\n保证操作合法，即：\n\n出停车场的车一定目前仍在停车场里；\n\n停车场内的车不会超过 n； \n\nOutput\n==\n对于所有操作 1，输出一个整数，表示该车车位的编号。\n\nSample Input\n==\n7 11\n1 15\n1 123123\n1 3\n1 5\n2 123123\n2 15\n1 21\n2 3\n1 6\n1 7\n1 8\n\nSample Output\n==\n1\n7\n4\n2\n7\n4\n1\n3\n\nData Constraint\n==\n对30%的数据 n<=1000 ，m<=1000\n对60%的数据 n<=200000，m<=2000\n对100%的数据n，m<=200000，车的编号小于等于 10^6\n\nAnalysis\n==\n我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。\n\n**对于30%数据**\n\n通过暴力的O(n*m)就可以得出答案。\n先建立一个长度为n的bool数组，标示每个位置是否被车占用。\n用一个car[1e6]数组表示每一辆车对应的编号。\n再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.\n对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)\n对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1)\n\n**对于60%数据**\n嘿嘿，我也不知道了！\n\n**对于100%数据**\n我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。\n\n对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。\n对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可\n\n\nCode\n==\n\n```\nconst\tmaxc=1000005;maxn=200005;\ntype\tnode=record\n\t\tl,r,mid,p:longint;\n\tend;\nvar\ti,j,k,m,n,ch,num,sum:longint;\n\tcar:array[1..maxc] of longint;\n\th:array[1..4*maxn] of node;\nprocedure merger(x:longint);\nvar\tt:longint;\nbegin\n\tif h[x+x].l>0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l;\n\tif h[x+x+1].r>0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r;\n\th[x].mid:=h[x+x].mid;\n\th[x].p:=h[x+x].p;\n\tif (h[x+x+1].l>0) and (h[x+x].r>0) then begin\n\t\tt:=(h[x+x+1].l-h[x+x].r) div 2;\n\t\tif t>h[x].mid then begin\n\t\t\th[x].mid:=t;\n\t\t\th[x].p:=(h[x+x+1].l+h[x+x].r) div 2;\n\t\tend;\n\t\tif h[x+x+1].mid>h[x].mid then begin\n\t\t\th[x].mid:=h[x+x+1].mid;\n\t\t\th[x].p:=h[x+x+1].p;\n\t\tend;\n\tend;\nend;\nprocedure work(x,l,r,num,kind:longint);\nvar\tmid:longint;\nbegin\n\tif l=r then begin\n\t\tif kind=2 then begin\n\t\t\th[x].l:=0;h[x].r:=0;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend else begin\n\t\t\th[x].l:=l;h[x].r:=r;\n\t\t\th[x].mid:=0;h[x].p:=0;\n\t\tend;\n\t\texit;\n\tend;\n\tmid:=(l+r)>>1;\n\tif num<=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind);\n\tmerger(x);\nend;\nbegin\n\treadln(n,m);\n\tfor i:=1 to m do begin\n\t\treadln(ch,num);\n\t\tif ch=1 then begin\n\t\t\tif h[1].l=0 then begin\n\t\t\t\tcar[num]:=1;\n\t\t\tend else begin\n\t\t\t\tsum:=-maxlongint;\n\t\t\t\tif h[1].l-1>sum then begin\n\t\t\t\t\tsum:=h[1].l-1;\n\t\t\t\t\tcar[num]:=1;\n\t\t\t\tend;\n\t\t\t\tif h[1].mid>sum then begin\n\t\t\t\t\tsum:=h[1].mid;\n\t\t\t\t\tcar[num]:=h[1].p;\n\t\t\t\tend;\n\t\t\t\tif n-h[1].r>sum then begin\n\t\t\t\t\tsum:=n-h[1].r;\n\t\t\t\t\tcar[num]:=n;\n\t\t\t\tend;\n\t\t\tend;\n\t\t\twriteln(car[num]);\n\t\t\twork(1,1,n,car[num],1);\n\t\tend else begin\n\t\t\twork(1,1,n,car[num],2);\n\t\tend;\n\tend;\nend.\n```","slug":"【NOIP2013模拟联考9】阿Q的停车场","published":1,"date":"2015-12-17T11:16:13.376Z","updated":"2015-12-17T11:16:13.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfvo000qlktggikcjh0j","sticky":0},{"title":"Hello World","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2015-12-17T11:16:13.375Z","updated":"2015-12-17T11:16:13.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciicjvfvs000tlktgxia3xgdu","sticky":0}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciicjvfrl0000lktg9iik3rhy","tag_id":"ciicjvfru0001lktgw4aic1g2","_id":"ciicjvfrz0004lktgt94d2u0k"},{"post_id":"ciicjvfrl0000lktg9iik3rhy","tag_id":"ciicjvfrx0002lktg8jfx1m43","_id":"ciicjvfrz0005lktg9s5m0f4o"},{"post_id":"ciicjvfrl0000lktg9iik3rhy","tag_id":"ciicjvfrx0003lktgctc96xrt","_id":"ciicjvfrz0006lktgjduykjg1"},{"post_id":"ciicjvfv8000alktggra0w6ug","tag_id":"ciicjvfru0001lktgw4aic1g2","_id":"ciicjvfva000blktgx94jnzcd"},{"post_id":"ciicjvfv8000alktggra0w6ug","tag_id":"ciicjvfrx0002lktg8jfx1m43","_id":"ciicjvfvb000clktgzphutkrc"},{"post_id":"ciicjvfv8000alktggra0w6ug","tag_id":"ciicjvfrx0003lktgctc96xrt","_id":"ciicjvfvb000dlktg2ej5uwha"},{"post_id":"ciicjvfvc000elktgo0j7hb7n","tag_id":"ciicjvfvd000flktg6rs3hix3","_id":"ciicjvfvg000hlktgcrzkcd1g"},{"post_id":"ciicjvfvc000elktgo0j7hb7n","tag_id":"ciicjvfvf000glktgcnmfj3s6","_id":"ciicjvfvg000ilktgb2cpr6zb"},{"post_id":"ciicjvfvh000jlktgp7u1yfmf","tag_id":"ciicjvfvd000flktg6rs3hix3","_id":"ciicjvfvi000klktgu4v6ulk0"},{"post_id":"ciicjvfvh000jlktgp7u1yfmf","tag_id":"ciicjvfvf000glktgcnmfj3s6","_id":"ciicjvfvj000llktg0jfkebg9"},{"post_id":"ciicjvfvk000mlktgwgqggo44","tag_id":"ciicjvfvl000nlktgx0pwmfr3","_id":"ciicjvfvm000olktgn0amej8l"},{"post_id":"ciicjvfvk000mlktgwgqggo44","tag_id":"ciicjvfrx0003lktgctc96xrt","_id":"ciicjvfvm000plktggw2vngwz"},{"post_id":"ciicjvfvo000qlktggikcjh0j","tag_id":"ciicjvfvl000nlktgx0pwmfr3","_id":"ciicjvfvq000rlktgfqcn70pe"},{"post_id":"ciicjvfvo000qlktggikcjh0j","tag_id":"ciicjvfrx0003lktgctc96xrt","_id":"ciicjvfvr000slktgjvgqh2ks"}],"Tag":[{"name":"软件","_id":"ciicjvfru0001lktgw4aic1g2"},{"name":"易语言","_id":"ciicjvfrx0002lktg8jfx1m43"},{"name":"原创","_id":"ciicjvfrx0003lktgctc96xrt"},{"name":"信息学","_id":"ciicjvfvd000flktg6rs3hix3"},{"name":"转载","_id":"ciicjvfvf000glktgcnmfj3s6"},{"name":"题解","_id":"ciicjvfvl000nlktgx0pwmfr3"}]}}