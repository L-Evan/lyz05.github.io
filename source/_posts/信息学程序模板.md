---
title: 信息学程序模板
date: 2015-11-06 11:52:00
tags:
  - 模板
categories:
  - 信息学
  - 原创
---
tarjan
<script src="https://code.csdn.net/snippets/1310789.js"></script>

拓扑排序
<script src="https://code.csdn.net/snippets/1310702.js"></script>



最小生成树 && 并查集
<script src="https://code.csdn.net/snippets/1310674.js"></script>



快速幂
<script src="https://code.csdn.net/snippets/1310653.js"></script>



LCA
<script src="https://code.csdn.net/snippets/1310621.js"></script>



dijkstra
<script src="https://code.csdn.net/snippets/1310589.js"></script>


spfa
<script src="https://code.csdn.net/snippets/1310489.js"></script>


sort
<script src="https://code.csdn.net/snippets/1310393.js"></script>


网络流最大流sap
<script src="https://code.csdn.net/snippets/1375597.js"></script>

tri树


```

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;

const int N = 300005, M = 4000005;
struct node
{
	node(){len = -1;}
	bool num;
	int len;
	int next,dep;
	int s[26];
} h[M];
int n,m,tot;
int a[N],f[N];
char s[N];
queue <int> Q;

void init()
{
	scanf("%d\n%s\n%d",&n,s,&m);
	for (int i=0;i<n;i ++) a[i] = s[i] - 'a';
	for (int i=1;i<=m;i ++)
	{
		scanf("%s",s);
		int len = strlen(s),now = 0;
		for (int j=0;j<len;j ++)
		{
			if (!h[now].s[s[j]-'a'])
				h[now].s[s[j]-'a'] = ++ tot;
			now = h[now].s[s[j]-'a'];
		}
		h[now].num = 1;
	}
	//普通建tri
	for (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);

	for (int x=Q.front();!Q.empty();x=Q.front())
	{
		Q.pop();
		for (int j=0;j<26;j ++)
			if (h[x].s[j])
			{
				int y = h[x].s[j];
				h[y].next = h[h[x].next].s[j];
				h[y].dep = h[x].dep + 1;
				Q.push(y);
			}
			else h[x].s[j] = h[h[x].next].s[j];
		if (h[x].num) h[x].len = h[x].dep;
		if (h[x].len<0) h[x].len = h[h[x].next].len;
	}
	//求fail指针
}

void work()
{
	for (int i=0,x=0;i<n;i ++)
	{
		x = h[x].s[a[i]];
		if (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];
	}
	int ans = 0;
	for (int i=0,sum = 0;i<n;i ++)
		sum += f[i],ans += !sum;
	printf("%d\n",ans);
}

int main()
{
	//freopen("3172.in","r",stdin);
	//freopen(".out","w",stdout);

	init();
	work();

	return 0;
}

```

匈牙利算法-二分图最大匹配
```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int N = 55,M = 55;
int tot,ans,n,m;
bool flag,p[M];
int f[M],Edge[N][N];

double sqr(int x) {return (double)x*x;}

bool check(int x)
{
	if (x==0) return 1;			//没有被选中
	for (int i=1;i<=tot;i ++)		//扫描每个匹配点
	{
		if (!p[i] && Edge[x][i])
		{
			//有边相连可以匹配,且在这次查找递归路径中没有尝试改变归属问题
			p[i] = 1;
			if (check(f[i]))	//匹配点没有归属或者可以腾出位置
			{
				f[i] = x;
				return 1;
			}
		}
	}
	return 0;
}

int main()
{
	bool flag;
	memset(f,0,sizeof f);		//匹配数组
	for (int i=1;i<=m;i ++)		//对每一个点都尝试匹配
	{
		memset(p,0,sizeof p);	//清空标记数组
		flag = check(i);
		if (flag) ans ++;		//匹配成功
	}
	return 0;
}


```
