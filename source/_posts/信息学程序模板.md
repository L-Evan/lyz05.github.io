---
title: 信息学程序模板
date: 2015-11-06 11:52:00
tags:
  - 模板
categories:
  - 信息学
  - 原创
---
# tarjan
<script src="https://code.csdn.net/snippets/1310789.js"></script>

# 拓扑排序
<script src="https://code.csdn.net/snippets/1310702.js"></script>



# 最小生成树 && 并查集
<script src="https://code.csdn.net/snippets/1310674.js"></script>



# 快速幂
<script src="https://code.csdn.net/snippets/1310653.js"></script>



# LCA
<script src="https://code.csdn.net/snippets/1310621.js"></script>



# dijkstra
<script src="https://code.csdn.net/snippets/1310589.js"></script>


# spfa
<script src="https://code.csdn.net/snippets/1310489.js"></script>


# sort
<script src="https://code.csdn.net/snippets/1310393.js"></script>


# 网络流最大流sap
<script src="https://code.csdn.net/snippets/1375597.js"></script>

# tri树


```

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;

const int N = 300005, M = 4000005;
struct node
{
	node(){len = -1;}
	bool num;
	int len;
	int next,dep;
	int s[26];
} h[M];
int n,m,tot;
int a[N],f[N];
char s[N];
queue <int> Q;

void init()
{
	scanf("%d\n%s\n%d",&n,s,&m);
	for (int i=0;i<n;i ++) a[i] = s[i] - 'a';
	for (int i=1;i<=m;i ++)
	{
		scanf("%s",s);
		int len = strlen(s),now = 0;
		for (int j=0;j<len;j ++)
		{
			if (!h[now].s[s[j]-'a'])
				h[now].s[s[j]-'a'] = ++ tot;
			now = h[now].s[s[j]-'a'];
		}
		h[now].num = 1;
	}
	//普通建tri
	for (int i=0;i<26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]);

	for (int x=Q.front();!Q.empty();x=Q.front())
	{
		Q.pop();
		for (int j=0;j<26;j ++)
			if (h[x].s[j])
			{
				int y = h[x].s[j];
				h[y].next = h[h[x].next].s[j];
				h[y].dep = h[x].dep + 1;
				Q.push(y);
			}
			else h[x].s[j] = h[h[x].next].s[j];
		if (h[x].num) h[x].len = h[x].dep;
		if (h[x].len<0) h[x].len = h[h[x].next].len;
	}
	//求fail指针
}

void work()
{
	for (int i=0,x=0;i<n;i ++)
	{
		x = h[x].s[a[i]];
		if (h[x].len>=0) ++ f[i-h[x].len],-- f[i+1];
	}
	int ans = 0;
	for (int i=0,sum = 0;i<n;i ++)
		sum += f[i],ans += !sum;
	printf("%d\n",ans);
}

int main()
{
	//freopen("3172.in","r",stdin);
	//freopen(".out","w",stdout);

	init();
	work();

	return 0;
}

```

# 匈牙利算法-二分图最大匹配
```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int N = 55,M = 55;
int tot,ans,n,m;
bool flag,p[M];
int f[M],Edge[N][N];

double sqr(int x) {return (double)x*x;}

bool check(int x)
{
	if (x==0) return 1;			//没有被选中
	for (int i=1;i<=tot;i ++)		//扫描每个匹配点
	{
		if (!p[i] && Edge[x][i])
		{
			//有边相连可以匹配,且在这次查找递归路径中没有尝试改变归属问题
			p[i] = 1;
			if (check(f[i]))	//匹配点没有归属或者可以腾出位置
			{
				f[i] = x;
				return 1;
			}
		}
	}
	return 0;
}

int main()
{
	bool flag;
	memset(f,0,sizeof f);		//匹配数组
	for (int i=1;i<=m;i ++)		//对每一个点都尝试匹配
	{
		memset(p,0,sizeof p);	//清空标记数组
		flag = check(i);
		if (flag) ans ++;		//匹配成功
	}
	return 0;
}


```

# 高精度
```
#include<iostream>
#include<string>
#include<iomanip>
#include<algorithm>
using namespace std;

#define MAXN 9999
#define MAXSIZE 10
#define DLEN 4

class BigNum
{
private:
    int a[500];    //可以控制大数的位数
    int len;       //大数长度
public:
    BigNum(){ len = 1;memset(a,0,sizeof(a)); }   //构造函数
    BigNum(const int);       //将一个int类型的变量转化为大数
    BigNum(const char*);     //将一个字符串类型的变量转化为大数
    BigNum(const BigNum &);  //拷贝构造函数
    BigNum &operator=(const BigNum &);   //重载赋值运算符，大数之间进行赋值运算

    friend istream& operator>>(istream&,  BigNum&);   //重载输入运算符
    friend ostream& operator<<(ostream&,  BigNum&);   //重载输出运算符

    BigNum operator+(const BigNum &) const;   //重载加法运算符，两个大数之间的相加运算
    BigNum operator-(const BigNum &) const;   //重载减法运算符，两个大数之间的相减运算
    BigNum operator*(const BigNum &) const;   //重载乘法运算符，两个大数之间的相乘运算
    BigNum operator/(const int   &) const;    //重载除法运算符，大数对一个整数进行相除运算

    BigNum operator^(const int  &) const;    //大数的n次方运算
    int    operator%(const int  &) const;    //大数对一个int类型的变量进行取模运算    
    bool   operator>(const BigNum & T)const;   //大数和另一个大数的大小比较
    bool   operator>(const int & t)const;      //大数和一个int类型的变量的大小比较

    void print();       //输出大数
};
BigNum::BigNum(const int b)     //将一个int类型的变量转化为大数
{
    int c,d = b;
    len = 0;
    memset(a,0,sizeof(a));
    while(d > MAXN)
    {
        c = d - (d / (MAXN + 1)) * (MAXN + 1);
        d = d / (MAXN + 1);
        a[len++] = c;
    }
    a[len++] = d;
}
BigNum::BigNum(const char*s)     //将一个字符串类型的变量转化为大数
{
    int t,k,index,l,i;
    memset(a,0,sizeof(a));
    l=strlen(s);   
    len=l/DLEN;
    if(l%DLEN)
        len++;
    index=0;
    for(i=l-1;i>=0;i-=DLEN)
    {
        t=0;
        k=i-DLEN+1;
        if(k<0)
            k=0;
        for(int j=k;j<=i;j++)
            t=t*10+s[j]-'0';
        a[index++]=t;
    }
}
BigNum::BigNum(const BigNum & T) : len(T.len)  //拷贝构造函数
{
    int i;
    memset(a,0,sizeof(a));
    for(i = 0 ; i < len ; i++)
        a[i] = T.a[i];
}
BigNum & BigNum::operator=(const BigNum & n)   //重载赋值运算符，大数之间进行赋值运算
{
    int i;
    len = n.len;
    memset(a,0,sizeof(a));
    for(i = 0 ; i < len ; i++)
        a[i] = n.a[i];
    return *this;
}
istream& operator>>(istream & in,  BigNum & b)   //重载输入运算符
{
    char ch[MAXSIZE*4];
    int i = -1;
    in>>ch;
    int l=strlen(ch);
    int count=0,sum=0;
    for(i=l-1;i>=0;)
    {
        sum = 0;
        int t=1;
        for(int j=0;j<4&&i>=0;j++,i--,t*=10)
        {
            sum+=(ch[i]-'0')*t;
        }
        b.a[count]=sum;
        count++;
    }
    b.len =count++;
    return in;

}
ostream& operator<<(ostream& out,  BigNum& b)   //重载输出运算符
{
    int i;  
    cout << b.a[b.len - 1];
    for(i = b.len - 2 ; i >= 0 ; i--)
    {
        cout.width(DLEN);
        cout.fill('0');
        cout << b.a[i];
    }
    return out;
}

BigNum BigNum::operator+(const BigNum & T) const   //两个大数之间的相加运算
{
    BigNum t(*this);
    int i,big;      //位数   
    big = T.len > len ? T.len : len;
    for(i = 0 ; i < big ; i++)
    {
        t.a[i] +=T.a[i];
        if(t.a[i] > MAXN)
        {
            t.a[i + 1]++;
            t.a[i] -=MAXN+1;
        }
    }
    if(t.a[big] != 0)
        t.len = big + 1;
    else
        t.len = big;   
    return t;
}
BigNum BigNum::operator-(const BigNum & T) const   //两个大数之间的相减运算
{  
    int i,j,big;
    bool flag;
    BigNum t1,t2;
    if(*this>T)
    {
        t1=*this;
        t2=T;
        flag=0;
    }
    else
    {
        t1=T;
        t2=*this;
        flag=1;
    }
    big=t1.len;
    for(i = 0 ; i < big ; i++)
    {
        if(t1.a[i] < t2.a[i])
        {
            j = i + 1;
            while(t1.a[j] == 0)
                j++;
            t1.a[j--]--;
            while(j > i)
                t1.a[j--] += MAXN;
            t1.a[i] += MAXN + 1 - t2.a[i];
        }
        else
            t1.a[i] -= t2.a[i];
    }
    t1.len = big;
    while(t1.a[len - 1] == 0 && t1.len > 1)
    {
        t1.len--;
        big--;
    }
    if(flag)
        t1.a[big-1]=0-t1.a[big-1];
    return t1;
}

BigNum BigNum::operator*(const BigNum & T) const   //两个大数之间的相乘运算
{
    BigNum ret;
    int i,j,up;
    int temp,temp1;   
    for(i = 0 ; i < len ; i++)
    {
        up = 0;
        for(j = 0 ; j < T.len ; j++)
        {
            temp = a[i] * T.a[j] + ret.a[i + j] + up;
            if(temp > MAXN)
            {
                temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);
                up = temp / (MAXN + 1);
                ret.a[i + j] = temp1;
            }
            else
            {
                up = 0;
                ret.a[i + j] = temp;
            }
        }
        if(up != 0)
            ret.a[i + j] = up;
    }
    ret.len = i + j;
    while(ret.a[ret.len - 1] == 0 && ret.len > 1)
        ret.len--;
    return ret;
}
BigNum BigNum::operator/(const int & b) const   //大数对一个整数进行相除运算
{
    BigNum ret;
    int i,down = 0;   
    for(i = len - 1 ; i >= 0 ; i--)
    {
        ret.a[i] = (a[i] + down * (MAXN + 1)) / b;
        down = a[i] + down * (MAXN + 1) - ret.a[i] * b;
    }
    ret.len = len;
    while(ret.a[ret.len - 1] == 0 && ret.len > 1)
        ret.len--;
    return ret;
}
int BigNum::operator %(const int & b) const    //大数对一个int类型的变量进行取模运算    
{
    int i,d=0;
    for (i = len-1; i>=0; i--)
    {
        d = ((d * (MAXN+1))% b + a[i])% b;  
    }
    return d;
}
BigNum BigNum::operator^(const int & n) const    //大数的n次方运算
{
    BigNum t,ret(1);
    int i;
    if(n<0)
        exit(-1);
    if(n==0)
        return 1;
    if(n==1)
        return *this;
    int m=n;
    while(m>1)
    {
        t=*this;
        for( i=1;i<<1<=m;i<<=1)
        {
            t=t*t;
        }
        m-=i;
        ret=ret*t;
        if(m==1)
            ret=ret*(*this);
    }
    return ret;
}
bool BigNum::operator>(const BigNum & T) const   //大数和另一个大数的大小比较
{
    int ln;
    if(len > T.len)
        return true;
    else if(len == T.len)
    {
        ln = len - 1;
        while(a[ln] == T.a[ln] && ln >= 0)
            ln--;
        if(ln >= 0 && a[ln] > T.a[ln])
            return true;
        else
            return false;
    }
    else
        return false;
}
bool BigNum::operator >(const int & t) const    //大数和一个int类型的变量的大小比较
{
    BigNum b(t);
    return *this>b;
}

void BigNum::print()    //输出大数
{
    int i;   
    cout << a[len - 1];
    for(i = len - 2 ; i >= 0 ; i--)
    {
        cout.width(DLEN);
        cout.fill('0');
        cout << a[i];
    }
    cout << endl;
}
int main()
{
    int i,n;
    BigNum x[101];      //定义大数的对象数组
    x[0]=1;
    for(i=1;i<101;i++)
        x[i]=x[i-1]*(4*i-2)/(i+1);
    while(scanf("%d",&n)==1 && n!=-1)
    {
        x[n].print();
    }
}
```
